---
title: 基础知识
date: 2023-05-21 11:11:40
permalink: /pages/601d7e/
categories:
  - 《Algorithm Guide》
  - 树
tags:
  - 
author: 
  name: citccld
  link: https://github.com/citccld
---
## 基础知识

**快速排序就是个⼆叉树的前序遍历，归并排序就是个⼆叉树的后序遍历。**

为什么快速排序和归并排序能和⼆叉树扯上关系？我们来简单分析⼀下他们的算法思想和代码框架：

快速排序的逻辑是，若要对 nums[lo..hi] 进⾏排序，我们先找⼀个分界点 p，通过交换元素使得

nums[lo..p-1] 都⼩于等于 nums[p]，且 nums[p+1..hi] 都⼤于 nums[p]，然后递归地去

nums[lo..p-1] 和 nums[p+1..hi] 中寻找新的分界点，最后整个数组就被排序了。

快速排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) {
 /****** 前序遍历位置 ******/
 // 通过交换元素构建分界点 p
 int p = partition(nums, lo, hi);
 /************************/
 sort(nums, lo, p - 1);
 sort(nums, p + 1, hi);
}
```

先构造分界点，然后去左右⼦数组构造分界点，你看这不就是⼀个⼆叉树的前序遍历吗？

再说说归并排序的逻辑，若要对 nums[lo..hi] 进⾏排序，我们先对 nums[lo..mid] 排序，再对

nums[mid+1..hi] 排序，最后把这两个有序的⼦数组合并，整个数组就排好序了。

归并排序的代码框架如下：

```java
void sort(int[] nums, int lo, int hi) {
 int mid = (lo + hi) / 2;
 sort(nums, lo, mid);
 sort(nums, mid + 1, hi);
 /****** 后序遍历位置 ******/
 // 合并两个排好序的⼦数组
 merge(nums, lo, mid, hi);
 /************************/
}
```

先对左右⼦数组排序，然后合并（类似合并有序链表的逻辑），你看这是不是⼆叉树的后序遍历框架？另外，这不就是传说中的分治算法嘛，不过如此呀。

> 写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利⽤这个定义推导最终结果，绝不要跳⼊递归的细节。

> 写树相关的算法，简单说就是，先搞清楚当前 **root** 节点「该做什么」以及「什么时候做」，然后根据函数
>
> 定义递归调⽤⼦节点，递归调⽤会让孩⼦节点做相同的事情。
>
> 所谓「该做什么」就是让你想清楚写什么代码能够实现题⽬想要的效果，所谓「什么时候做」，就是让你思
>
> 考这段代码到底应该写在前序、中序还是后序遍历的代码位置上。
>
> ⼆叉树题⽬的⼀个难点就是，如何把题⽬的要求细化成每个节点需要做的事情。
>
> 根据题意，思考⼀个⼆叉树节点需要做什么，到底⽤什么遍历顺序就清楚了。

























