## Java实现调用HTTP请求的几种常见方式

### 一、概述

在实际开发过程中，经常需要调用对方提供的接口或者自己写的接口是否有接口。短信、天气等）。

Java项目中调用接口的方式有：

- 通过JDK网络类Java.net.HttpURLConnection；
- 通过common封装好HttpClient；
- 通过 Apache 封装好`CloseableHttpClient`；
- 通过SpringBoot-RestTemplate；

### 二、Java调用http接口的方式

#### 2.1、通过JDK网络类`Java.net.HttpURLConnection`

原始比较的一种调用方法，这里get请求和post请求都可以找到一个方法里面。

实现过程：

**得到：**

1. 创建远程连接
2. 设置连接方式（get、post、put。。。）
3. 设置连接时间
4. 设置响应读取时间
5. 发起请求
6. 获取请求数据
7. 关闭连接

**邮政：**

1. 创建远程连接
2. 设置连接方式（get、post、put。。。）
3. 设置连接时间
4. 设置响应读取时间
5. 当向远程服务器传送数据/写入数据时，需要设置为true（`setDoOutput`）
6. 当前向远程服务读取数据时，设置为true，该参数可有可无（`setDoInput`）
7. 设置参数格式的属性：（请求参数）
8. 设置鉴权信息：授权：（`setRequestProperty`）
9. 参数设置
10. 发起请求
11. 获取请求数据
12. 关闭连接

直接上代码：

```java
package com.fcant.springbootdemo.util.common.httpConnectionUtil;
 
import org.springframework.lang.Nullable;
 
import java.io.*;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

public class HttpURLConnectionUtil {
 
    /**
     * Http get请求
     * @param httpUrl 连接
     * @return 响应数据
     */
    public static String doGet(String httpUrl){
        //链接
        HttpURLConnection connection = null;
        InputStream is = null;
        BufferedReader br = null;
        StringBuffer result = new StringBuffer();
        try {
            //创建连接
            URL url = new URL(httpUrl);
            connection = (HttpURLConnection) url.openConnection();
            //设置请求方式
            connection.setRequestMethod("GET");
            //设置连接超时时间
            connection.setReadTimeout(15000);
            //开始连接
            connection.connect();
            //获取响应数据
            if (connection.getResponseCode() == 200) {
                //获取返回的数据
                is = connection.getInputStream();
                if (null != is) {
                    br = new BufferedReader(new InputStreamReader(is, "UTF-8"));
                    String temp = null;
                    while (null != (temp = br.readLine())) {
                        result.append(temp);
                    }
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (null != br) {
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != is) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            //关闭远程连接
            connection.disconnect();
        }
        return result.toString();
    }
 
    /**
     * Http post请求
     * @param httpUrl 连接
     * @param param 参数
     * @return
     */
    public static String doPost(String httpUrl, @Nullable String param) {
        StringBuffer result = new StringBuffer();
        //连接
        HttpURLConnection connection = null;
        OutputStream os = null;
        InputStream is = null;
        BufferedReader br = null;
        try {
            //创建连接对象
            URL url = new URL(httpUrl);
            //创建连接
            connection = (HttpURLConnection) url.openConnection();
            //设置请求方法
            connection.setRequestMethod("POST");
            //设置连接超时时间
            connection.setConnectTimeout(15000);
            //设置读取超时时间
            connection.setReadTimeout(15000);
            //DoOutput设置是否向httpUrlConnection输出，DoInput设置是否从httpUrlConnection读入，此外发送post请求必须设置这两个
            //设置是否可读取
            connection.setDoOutput(true);
            connection.setDoInput(true);
            //设置通用的请求属性
            connection.setRequestProperty("accept", "*/*");
            connection.setRequestProperty("connection", "Keep-Alive");
            connection.setRequestProperty("user-agent", "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)");
            connection.setRequestProperty("Content-Type", "application/json;charset=utf-8");
 
            //拼装参数
            if (null != param && param.equals("")) {
                //设置参数
                os = connection.getOutputStream();
                //拼装参数
                os.write(param.getBytes("UTF-8"));
            }
            //设置权限
            //设置请求头等
            //开启连接
            //connection.connect();
            //读取响应
            if (connection.getResponseCode() == 200) {
                is = connection.getInputStream();
                if (null != is) {
                    br = new BufferedReader(new InputStreamReader(is, "GBK"));
                    String temp = null;
                    while (null != (temp = br.readLine())) {
                        result.append(temp);
                        result.append("\r\n");
                    }
                }
            }
 
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            //关闭连接
            if(br!=null){
                try {
                    br.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(os!=null){
                try {
                    os.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if(is!=null){
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            //关闭连接
            connection.disconnect();
        }
        return result.toString();
    }
 
    public static void main(String[] args) {
        String message = doPost("https://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=13026194071", "");
        System.out.println(message);
    }
}
```

#### 2.2 通过apache通用封装好的HttpClient

httpClient的get或post请求方式步骤：

1. 生成一个`HttpClient`对象并设置相应的参数；
2. 生成一个`GetMethod`对象或`PostMethod`并设置响应的参数；
3. 用`HttpClient`生成的对象来执行`GetMethod`生成的Get方法；
4. 处理响应状态码；
5. 如果正常响应，处理HTTP响应内容；
6. 释放连接。

导入以下jar包：

```xml
<!--HttpClient-->
<dependency>
    <groupId>commons-httpclient</groupId>
    <artifactId>commons-httpclient</artifactId>
    <version>3.1</version>
</dependency>
 
<!--fastjson-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.32</version>
</dependency>
```

代码如下：

```java
package com.fcant.springbootdemo.util.common.httpConnectionUtil;
 
import com.alibaba.fastjson.JSONObject;
import org.apache.commons.httpclient.*;
import org.apache.commons.httpclient.methods.GetMethod;
import org.apache.commons.httpclient.methods.PostMethod;
import org.apache.commons.httpclient.params.HttpMethodParams;
 
import java.io.IOException;

public class HttpClientUtil {
    /**
     * httpClient的get请求方式
     * 使用GetMethod来访问一个URL对应的网页实现步骤：
     * 1.生成一个HttpClient对象并设置相应的参数；
     * 2.生成一个GetMethod对象并设置响应的参数；
     * 3.用HttpClient生成的对象来执行GetMethod生成的Get方法；
     * 4.处理响应状态码；
     * 5.若响应正常，处理HTTP响应内容；
     * 6.释放连接。
     * @param url
     * @param charset
     * @return
     */
    public static String doGet(String url, String charset) {
        //1.生成HttpClient对象并设置参数
        HttpClient httpClient = new HttpClient();
        //设置Http连接超时为5秒
        httpClient.getHttpConnectionManager().getParams().setConnectionTimeout(5000);
        //2.生成GetMethod对象并设置参数
        GetMethod getMethod = new GetMethod(url);
        //设置get请求超时为5秒
        getMethod.getParams().setParameter(HttpMethodParams.SO_TIMEOUT, 5000);
        //设置请求重试处理，用的是默认的重试处理：请求三次
        getMethod.getParams().setParameter(HttpMethodParams.RETRY_HANDLER, new DefaultHttpMethodRetryHandler());
        String response = "";
        //3.执行HTTP GET 请求
        try {
            int statusCode = httpClient.executeMethod(getMethod);
            //4.判断访问的状态码
            if (statusCode != HttpStatus.SC_OK) {
                System.err.println("请求出错：" + getMethod.getStatusLine());
            }
            //5.处理HTTP响应内容
            //HTTP响应头部信息，这里简单打印
            Header[] headers = getMethod.getResponseHeaders();
            for(Header h : headers) {
                System.out.println(h.getName() + "---------------" + h.getValue());
            }
            //读取HTTP响应内容，这里简单打印网页内容
            //读取为字节数组
            byte[] responseBody = getMethod.getResponseBody();
            response = new String(responseBody, charset);
            System.out.println("-----------response:" + response);
            //读取为InputStream，在网页内容数据量大时候推荐使用
            //InputStream response = getMethod.getResponseBodyAsStream();
        } catch (HttpException e) {
            //发生致命的异常，可能是协议不对或者返回的内容有问题
            System.out.println("请检查输入的URL!");
            e.printStackTrace();
        } catch (IOException e) {
            //发生网络异常
            System.out.println("发生网络异常!");
        } finally {
            //6.释放连接
            getMethod.releaseConnection();
        }
        return response;
    }
 
    /**
     * post请求
     * @param url
     * @param json
     * @return
     */
    public static String doPost(String url, JSONObject json){
        HttpClient httpClient = new HttpClient();
        PostMethod postMethod = new PostMethod(url);
 
        postMethod.addRequestHeader("accept", "*/*");
        postMethod.addRequestHeader("connection", "Keep-Alive");
        //设置json格式传送
        postMethod.addRequestHeader("Content-Type", "application/json;charset=GBK");
        //必须设置下面这个Header
        postMethod.addRequestHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36");
        //添加请求参数
        postMethod.addParameter("commentId", json.getString("commentId"));
 
        String res = "";
        try {
            int code = httpClient.executeMethod(postMethod);
            if (code == 200){
                res = postMethod.getResponseBodyAsString();
                System.out.println(res);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return res;
    }
 
    public static void main(String[] args) {
        System.out.println(doGet("http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=13026194071", "GBK"));
        System.out.println("-----------分割线------------");
        System.out.println("-----------分割线------------");
        System.out.println("-----------分割线------------");
 
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("commentId", "13026194071");
        System.out.println(doPost("http://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=13026194071", jsonObject));
    }
}
```

post请求的`jsonObject`参数也成功写入

#### 2.3 通过Apache封装好的`CloseableHttpClient`

`CloseableHttpClient`是在`HttpClient`的基础上修改可以更新而来的，这里还涉及到请求头的设置（请求），利用fastjson转换请求或返回请求结果字符串为json格式，当然方式也是设置头token、 json的，这里只在下面说明。

导入以下jar包：

```xml
<!--CloseableHttpClient-->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpclient</artifactId>
    <version>4.5.2</version>
</dependency>
 
<!--fastjson-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.32</version>
</dependency>
```

代码如下：

```java
package com.fcant.springbootdemo.util.common.httpConnectionUtil;
 
import com.alibaba.fastjson.JSONObject;
import org.apache.http.HttpResponse;
import org.apache.http.HttpStatus;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.apache.http.util.EntityUtils;
 
import java.io.IOException;
import java.io.UnsupportedEncodingException;

public class CloseableHttpClientUtil {
 
    private static String tokenString = "";
    private static String AUTH_TOKEN_EXPIRED = "AUTH_TOKEN_EXPIRED";
    private static CloseableHttpClient httpClient = null;
 
    /**
     * 以get方式调用第三方接口
     * @param url
     * @param token
     * @return
     */
    public static String doGet(String url, String token) {
        //创建HttpClient对象
        CloseableHttpClient httpClient = HttpClientBuilder.create().build();
        HttpGet httpGet = new HttpGet(url);
        if (null != tokenString && !tokenString.equals("")) {
            tokenString = getToken();
        }
        //api_gateway_auth_token自定义header头，用于token验证使用
        httpGet.addHeader("api_gateway_auth_token",tokenString);
        httpGet.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36");
        try {
            HttpResponse response = httpClient.execute(httpGet);
            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                //返回json格式
                String res = EntityUtils.toString(response.getEntity());
                return res;
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }
 
    /**
     * 以post方式调用第三方接口
     * @param url
     * @param json
     * @return
     */
    public static String doPost(String url, JSONObject json) {
        if (null == httpClient) {
            httpClient = HttpClientBuilder.create().build();
        }
        HttpPost httpPost = new HttpPost(url);
        if (null != tokenString && tokenString.equals("")) {
            tokenString = getToken();
        }
        //api_gateway_auth_token自定义header头，用于token验证使用
        httpPost.addHeader("api_gateway_auth_token", tokenString);
        httpPost.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36");
        try {
            StringEntity se = new StringEntity(json.toString());
            se.setContentEncoding("UTF-8");
            //发送json数据需要设置contentType
            se.setContentType("application/x-www-form-urlencoded");
            //设置请求参数
            httpPost.setEntity(se);
            HttpResponse response = httpClient.execute(httpPost);
            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                //返回json格式
                String res = EntityUtils.toString(response.getEntity());
                return res;
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (httpClient != null){
                try {
                    httpClient.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return null;
    }
 
    /**
     * 获取第三方接口的token
     */
    public static String getToken() {
        String token = "";
        JSONObject object = new JSONObject();
        object.put("appid", "appid");
        object.put("secretkey", "secretkey");
        if (null == httpClient) {
            httpClient = HttpClientBuilder.create().build();
        }
        HttpPost httpPost = new HttpPost("http://localhost/login");
        httpPost.addHeader("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.81 Safari/537.36");
        try {
            StringEntity se = new StringEntity(object.toString());
            se.setContentEncoding("UTF-8");
            //发送json数据需要设置contentType
            se.setContentType("application/x-www-form-urlencoded");
            //设置请求参数
            httpPost.setEntity(se);
            HttpResponse response = httpClient.execute(httpPost);
            //这里可以把返回的结果按照自定义的返回数据结果，把string转换成自定义类
            //ResultTokenBO result = JSONObject.parseObject(response, ResultTokenBO.class);
            //把response转为jsonObject
            JSONObject result = (JSONObject) JSONObject.parseObject(String.valueOf(response));
            if (result.containsKey("token")) {
                token = result.getString("token");
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return token;
    }
 
    /**
     * 测试
     */
    public static void test(String telephone) {
 
        JSONObject object = new JSONObject();
        object.put("telephone", telephone);
 
        //首先获取token
        tokenString = getToken();
        String response = doPost("http://localhost/searchUrl", object);
        //如果返回的结果是list形式的，需要使用JSONObject.parseArray转换
        //List<Result> list = JSONObject.parseArray(response, Result.class);
        System.out.println(response);
    }
 
    public static void main(String[] args) {
        test("12345678910");
    }
}
```

#### 2.4 通过SpringBoot-RestTemplate

springBoot-RestTemple是这些代码的集合的大成者，编写简单，目前可以采用的调用接口有：

- `delete()` HTTP DELETE在特定操作的 URL 上对资源执行
- `exchange()` 在URL上执行特定的HTTP方法，返回包含对象的`ResponseEntity`，这个对象是从请求体中映射到的
- `execute()` 在上执行特定的HTTP方法，返回一个从响应体映射到的对象
- `get()` 发送一个HTTP GET请求返回的`ResponseEntity`包含了响应体，映射成的对象
- `getForObject()` 发送HTTP GET请求，返回的请求体将映射为一个对象
- `postForEntity()` POST 数据到一个URL，返回包含一个对象的`ResponseEntity`，这个对象是从响应体中映射的
- `postForObject()` POST 数据到一个 URL，返回根据响应体形成的对象
- `headForHeaders()` 发送HTTP HEAD请求，返回包含特定资源URL的HTTP头
- `optionsForAllow()` 发送HTTP OPTIONS请求，返回对特定URL的Allow头信息
- `postForLocation()` POST 数据到一个 URL，返回新创建资源的 URL
- `put()` PUT 资源到特定的 URL

首先导入springboot的web包

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.0.4.RELEASE</version>
</parent>

<dependencies>
    <!--CloseableHttpClient-->
    <dependency>
        <groupId>org.apache.httpcomponents</groupId>
        <artifactId>httpclient</artifactId>
        <version>4.5.2</version>
    </dependency>

    <!--spring restTemplate-->
    <!-- @ConfigurationProperties annotation processing (metadata for IDEs)
            生成spring-configuration-metadata.json类，需要引入此类-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-configuration-processor</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-tomcat</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jetty</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

在启动类同包下创建RestTemplateConfig.java类

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.client.ClientHttpRequestFactory;
import org.springframework.http.client.SimpleClientHttpRequestFactory;
import org.springframework.web.client.RestTemplate;

@Configuration
public class RestTemplateConfig {
 
    @Bean
    public RestTemplate restTemplate(ClientHttpRequestFactory factory){
        return new RestTemplate(factory);
    }
 
    @Bean
    public ClientHttpRequestFactory simpleClientHttpRequestFactory(){
        SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
        factory.setConnectTimeout(15000);
        factory.setReadTimeout(5000);
        return factory;
    }
}
```

然后在Service类（`RestTemplateToInterface`）中注入使用

具体代码如下：

```java
import com.alibaba.fastjson.JSONObject;
import com.swordfall.model.User;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class RestTemplateToInterface {
 
    @Autowired
    private RestTemplate restTemplate;
 
    /**
     * 以get方式请求第三方http接口 getForEntity
     * @param url
     * @return
     */
    public User doGetWith1(String url){
        ResponseEntity<User> responseEntity = restTemplate.getForEntity(url, User.class);
        User user = responseEntity.getBody();
        return user;
    }
 
    /**
     * 以get方式请求第三方http接口 getForObject
     * 返回值返回的是响应体，省去了我们再去getBody()
     * @param url
     * @return
     */
    public User doGetWith2(String url){
        User user  = restTemplate.getForObject(url, User.class);
        return user;
    }
 
    /**
     * 以post方式请求第三方http接口 postForEntity
     * @param url
     * @return
     */
    public String doPostWith1(String url){
        User user = new User("小白", 20);
        ResponseEntity<String> responseEntity = restTemplate.postForEntity(url, user, String.class);
        String body = responseEntity.getBody();
        return body;
    }
 
    /**
     * 以post方式请求第三方http接口 postForEntity
     * @param url
     * @return
     */
    public String doPostWith2(String url){
        User user = new User("小白", 20);
        String body = restTemplate.postForObject(url, user, String.class);
        return body;
    }
 
    /**
     * exchange
     * @return
     */
    public String doExchange(String url, Integer age, String name){
        //header参数
        HttpHeaders headers = new HttpHeaders();
        String token = "asdfaf2322";
        headers.add("authorization", token);
        headers.setContentType(MediaType.APPLICATION_JSON);
 
        //放入body中的json参数
        JSONObject obj = new JSONObject();
        obj.put("age", age);
        obj.put("name", name);
 
        //组装
        HttpEntity<JSONObject> request = new HttpEntity<>(obj, headers);
        ResponseEntity<String> responseEntity = restTemplate.exchange(url, HttpMethod.POST, request, String.class);
        String body = responseEntity.getBody();
        return body;
    }
}
```

#### 2.5 通过okhttp

现在也是蛮流行的，基于手机端很火的，这里分享一下OkHttpClient客户端，业务代码get、post请求直接调用http就好了。

pom文件引入依赖包

```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>3.10.0</version>
</dependency>
```

```java
@Slf4j
public class OkHttpClient {
    private static final MediaType JSON = MediaType.parse("application/json; charset=utf-8");
 
    private volatile static okhttp3.OkHttpClient client;
 
    private static final int MAX_IDLE_CONNECTION = Integer
            .parseInt(ConfigManager.get("httpclient.max_idle_connection"));
 
    private static final long KEEP_ALIVE_DURATION = Long
            .parseLong(ConfigManager.get("httpclient.keep_alive_duration"));
 
    private static final long CONNECT_TIMEOUT = Long.parseLong(ConfigManager.get("httpclient.connectTimeout"));
 
    private static final long READ_TIMEOUT = Long.parseLong(ConfigManager.get("httpclient. "));
 
    /**
     * 单例模式(双重检查模式) 获取类实例
     *
     * @return client
     */
    private static okhttp3.OkHttpClient getInstance() {
        if (client == null) {
            synchronized (okhttp3.OkHttpClient.class) {
                if (client == null) {
                    client = new okhttp3.OkHttpClient.Builder()
                            .connectTimeout(CONNECT_TIMEOUT, TimeUnit.SECONDS)
                            .readTimeout(READ_TIMEOUT, TimeUnit.SECONDS)
                            .connectionPool(new ConnectionPool(MAX_IDLE_CONNECTION, KEEP_ALIVE_DURATION,
                                    TimeUnit.MINUTES))
                            .build();
                }
            }
        }
        return client;
    }
 
    public static String syncPost(String url, String json) throws IOException {
        RequestBody body = RequestBody.create(JSON, json);
        Request request = new Request.Builder()
                .url(url)
                .post(body)
                .build();
        try {
            Response response = OkHttpClient.getInstance().newCall(request).execute();
            if (response.isSuccessful()) {
                String result = response.body().string();
                log.info("syncPost response = {}, responseBody= {}", response, result);
                return result;
            }
            String result = response.body().string();
            log.info("syncPost response = {}, responseBody= {}", response, result);
            throw new IOException("三方接口返回http状态码为" + response.code());
        } catch (Exception e) {
            log.error("syncPost() url:{} have a ecxeption {}", url, e);
            throw new RuntimeException("syncPost() have a ecxeption {}" + e.getMessage());
        }
    }
 
    public static String syncGet(String url, Map<String, Object> headParamsMap) throws IOException {
        Request request;
        final Request.Builder builder = new Request.Builder().url(url);
        try {
            if (!CollectionUtils.isEmpty(headParamsMap)) {
                final Iterator<Map.Entry<String, Object>> iterator = headParamsMap.entrySet()
                        .iterator();
                while (iterator.hasNext()) {
                    final Map.Entry<String, Object> entry = iterator.next();
                    builder.addHeader(entry.getKey(), (String) entry.getValue());
                }
            }
            request = builder.build();
            Response response = OkHttpClient.getInstance().newCall(request).execute();
            String result = response.body().string();
            log.info("syncGet response = {},responseBody= {}", response, result);
            if (!response.isSuccessful()) {
                throw new IOException("三方接口返回http状态码为" + response.code());
            }
            return result;
        } catch (Exception e) {
            log.error("remote interface url:{} have a ecxeption {}", url, e);
            throw new RuntimeException("三方接口返回异常");
        }
    }
 
}
```







### 案例1

以下是使用Java发送带请求体JSON的HTTP POST请求的简单方法：

```java
 import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.HashMap;
import java.util.Map;

import org.json.JSONObject;

public class HttpPostExample {
    public static void main(String[] args) {
        try {
            // 构建请求URL
            URL url = new URL("http://example.com/api");

            // 建立连接
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();

            // 设置请求方法为POST
            conn.setRequestMethod("POST");

            // 设置请求头
            conn.setRequestProperty("Content-Type", "application/json");

            // 设置连接超时时间
            conn.setConnectTimeout(5000);

            // 设置读取超时时间
            conn.setReadTimeout(5000);

            // 发送请求
            conn.connect();

            // 构造请求体JSON
            JSONObject jsonObj = new JSONObject();
            jsonObj.put("name", "John");
            jsonObj.put("age", 25);

            // 发送请求体JSON
            DataOutputStream dos = new DataOutputStream(conn.getOutputStream());
            dos.writeBytes(jsonObj.toString());
            dos.flush();
            dos.close();

            // 接收响应
            BufferedReader reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                System.out.println(line);
            }
            reader.close();

            // 关闭连接
            conn.disconnect();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## HTTP 连接客户端 HttpClient 与 OkHttp 比较

### 使用

HttpClient和OkHttp一般用于调用其它服务，一般服务暴露出来的接口都为http，http常用请求类型就为GET、PUT、POST和DELETE，因此主要介绍这些请求类型的调用。

#### HttpClient使用介绍

使用HttpClient发送请求主要分为以下几步骤：

- 创建 `CloseableHttpClient`对象或`CloseableHttpAsyncClient`对象，前者同步，后者为异步
- 创建Http请求对象
- 调用`execute`方法执行请求，如果是异步请求在执行之前需调用`start`方法

#### 创建连接：

```java
CloseableHttpClient httpClient = HttpClientBuilder.create().build();
```

该连接为同步连接

#### GET请求：

```java
@Test  
public void testGet() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpGet httpGet = new HttpGet(url);  
    CloseableHttpResponse response = httpClient.execute(httpGet);  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

使用HttpGet表示该连接为GET请求，HttpClient调用`execute`方法发送GET请求

#### PUT请求：

```java
@Test  
public void testPut() throws IOException {  
    String api = "/api/user";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpPut httpPut = new HttpPut(url);  
    UserVO userVO = UserVO.builder().name("h2t").id(16L).build();  
    httpPut.setHeader("Content-Type", "application/json;charset=utf8");  
    httpPut.setEntity(new StringEntity(JSONObject.toJSONString(userVO), "UTF-8"));  
    CloseableHttpResponse response = httpClient.execute(httpPut);  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

#### POST请求：

添加对象

```java
@Test  
public void testPost() throws IOException {  
    String api = "/api/user";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpPost httpPost = new HttpPost(url);  
    UserVO userVO = UserVO.builder().name("h2t2").build();  
    httpPost.setHeader("Content-Type", "application/json;charset=utf8");  
    httpPost.setEntity(new StringEntity(JSONObject.toJSONString(userVO), "UTF-8"));  
    CloseableHttpResponse response = httpClient.execute(httpPost);  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

该请求是一个创建对象的请求，需要传入一个json字符串

##### 上传文件

```java
@Test  
public void testUpload1() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpPost httpPost = new HttpPost(url);  
    File file = new File("C:/Users/hetiantian/Desktop/学习/docker_practice.pdf");  
    FileBody fileBody = new FileBody(file);  
    MultipartEntityBuilder builder = MultipartEntityBuilder.create();  
    builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE);  
    builder.addPart("file", fileBody);  //addPart上传文件  
    HttpEntity entity = builder.build();  
    httpPost.setEntity(entity);  
    CloseableHttpResponse response = httpClient.execute(httpPost);  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

通过addPart上传文件

#### DELETE请求：

```java
@Test  
public void testDelete() throws IOException {  
    String api = "/api/user/12";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpDelete httpDelete = new HttpDelete(url);  
    CloseableHttpResponse response = httpClient.execute(httpDelete);  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

请求的取消：

```java
@Test  
public void testCancel() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    HttpGet httpGet = new HttpGet(url);  
    httpGet.setConfig(requestConfig);  //设置超时时间  
    //测试连接的取消  
  
    long begin = System.currentTimeMillis();  
    CloseableHttpResponse response = httpClient.execute(httpGet);  
    while (true) {  
        if (System.currentTimeMillis() - begin > 1000) {  
          httpGet.abort();  
          System.out.println("task canceled");  
          break;  
      }  
    }  
  
    System.out.println(EntityUtils.toString(response.getEntity()));  
}
```

调用`abort`方法取消请求 执行结果：

```xml
task canceled  
cost 8098 msc  
Disconnected from the target VM, address: '127.0.0.1:60549', transport: 'socket'  
  
java.net.SocketException: socket closed...【省略】
```

### OkHttp使用

使用OkHttp发送请求主要分为以下几步骤：

- 创建OkHttpClient对象
- 创建Request对象
- 将Request 对象封装为Call
- 通过Call 来执行同步或异步请求，调用`execute`方法同步执行，调用`enqueue`方法异步执行

#### 创建连接：

```java
private OkHttpClient client = new OkHttpClient();
```

#### GET请求：

```java
@Test  
public void testGet() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    Request request = new Request.Builder()  
            .url(url)  
            .get()   
            .build();  
    final Call call = client.newCall(request);  
    Response response = call.execute();  
    System.out.println(response.body().string());  
}
```

#### PUT请求：

```java
@Test  
public void testPut() throws IOException {  
    String api = "/api/user";  
    String url = String.format("%s%s", BASE_URL, api);  
    //请求参数  
    UserVO userVO = UserVO.builder().name("h2t").id(11L).build();  
    RequestBody requestBody = RequestBody.create(MediaType.parse("application/json; charset=utf-8"),  
    JSONObject.toJSONString(userVO));  
    Request request = new Request.Builder()  
            .url(url)  
            .put(requestBody)  
            .build();  
    final Call call = client.newCall(request);  
    Response response = call.execute();  
    System.out.println(response.body().string());  
}
```

#### POST请求：

添加对象

```java
@Test  
public void testPost() throws IOException {  
    String api = "/api/user";  
    String url = String.format("%s%s", BASE_URL, api);  
    //请求参数  
    JSONObject json = new JSONObject();  
    json.put("name", "hetiantian");  
    RequestBody requestBody = RequestBody.create(MediaType.parse("application/json; charset=utf-8"),     String.valueOf(json));  
    Request request = new Request.Builder()  
            .url(url)  
            .post(requestBody) //post请求  
           .build();  
    final Call call = client.newCall(request);  
    Response response = call.execute();  
    System.out.println(response.body().string());  
}
```

##### 上传文件

```java
@Test  
public void testUpload() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    RequestBody requestBody = new MultipartBody.Builder()  
            .setType(MultipartBody.FORM)  
            .addFormDataPart("file", "docker_practice.pdf",  
                    RequestBody.create(MediaType.parse("multipart/form-data"),  
                            new File("C:/Users/hetiantian/Desktop/学习/docker_practice.pdf")))  
            .build();  
    Request request = new Request.Builder()  
            .url(url)  
            .post(requestBody)  //默认为GET请求，可以不写  
            .build();  
    final Call call = client.newCall(request);  
    Response response = call.execute();  
    System.out.println(response.body().string());  
}
```

通过`addFormDataPart`方法模拟表单方式上传文件。

#### DELETE请求：

```java
@Test  
public void testDelete() throws IOException {  
  String url = String.format("%s%s", BASE_URL, api);  
  //请求参数  
  Request request = new Request.Builder()  
          .url(url)  
          .delete()  
          .build();  
  final Call call = client.newCall(request);  
  Response response = call.execute();  
  System.out.println(response.body().string());  
}
```

#### 请求的取消：

```java
@Test  
public void testCancelSysnc() throws IOException {  
    String api = "/api/files/1";  
    String url = String.format("%s%s", BASE_URL, api);  
    Request request = new Request.Builder()  
            .url(url)  
            .get()    
            .build();  
    final Call call = client.newCall(request);  
    Response response = call.execute();  
    long start = System.currentTimeMillis();  
    //测试连接的取消  
    while (true) {  
         //1分钟获取不到结果就取消请求  
        if (System.currentTimeMillis() - start > 1000) {  
            call.cancel();  
            System.out.println("task canceled");  
            break;  
        }  
    }  
  
    System.out.println(response.body().string());  
}
```

调用`cancel`方法进行取消 测试结果：

```plain
task canceled  
cost 9110 msc  

java.net.SocketException: socket closed...【省略】  
```

### 小结

OkHttp使用build模式创建对象来的更简洁一些，并且使用.post/.delete/.put/.get方法表示请求类型，不需要像HttpClient创建HttpGet、HttpPost等这些方法来创建请求类型

依赖包上，如果HttpClient需要发送异步请求、实现文件上传，需要额外的引入异步请求依赖

```xml
<!---文件上传-->  
<dependency>  
  <groupId>org.apache.httpcomponents</groupId>  
  <artifactId>httpmime</artifactId>  
  <version>4.5.3</version>  
</dependency>  
<!--异步请求-->  
<dependency>  
  <groupId>org.apache.httpcomponents</groupId>  
  <artifactId>httpasyncclient</artifactId>  
  <version>4.5.3</version>  
</dependency>
```

请求的取消，HttpClient使用`abort`方法，OkHttp使用`cancel`方法，都挺简单的，如果使用的是异步client，则在抛出异常时调用取消请求的方法即可

### 超时设置

#### HttpClient超时设置：

在HttpClient4.3+版本以上，超时设置通过`RequestConfig`进行设置

```java
private CloseableHttpClient httpClient = HttpClientBuilder.create().build();  
private RequestConfig requestConfig =  RequestConfig.custom()  
        .setSocketTimeout(60 * 1000)  
        .setConnectTimeout(60 * 1000).build();  
String api = "/api/files/1";  
String url = String.format("%s%s", BASE_URL, api);  
HttpGet httpGet = new HttpGet(url);  
httpGet.setConfig(requestConfig);  //设置超时时间  
```

超时时间是设置在请求类型HttpGet上，而不是HttpClient上

#### OkHttp超时设置：

直接在OkHttp上进行设置

```java
private OkHttpClient client = new OkHttpClient.Builder()  
    .connectTimeout(60, TimeUnit.SECONDS)//设置连接超时时间  
    .readTimeout(60, TimeUnit.SECONDS)//设置读取超时时间  
    .build();
```

### 小结：

如果client是单例模式，HttpClient在设置超时方面来的更灵活，针对不同请求类型设置不同的超时时间，OkHttp一旦设置了超时时间，所有请求类型的超时时间也就确定

## OkHttp3使用总结

### 一、摘要

现在开源的市场上，能网络请求的工具非常的多，比如 HttpURLConnection 、Apache HttpClient、okHttp、Retrofit 等等。

虽然可选择的工具很多，但是作为一名开发者，希望在写代码的时候，能够轻松地调试应用程序的网络通信，选择适合的工具至关重要！

就目前所熟悉的，其中 Apache HttpClient 因其高效的性能、丰富的 api，在开源项目中使用非常广泛，Android 系统最早默认的网络请求工具也是使用 Apache HttpClient，但因为兼容性问题，Android 后期的版本中谷歌不愿意维护相关包，改而使用 okHttp。

现在 Android 系统中的网络请求框架，基本都是 okhttp 和 Retrofit 一统天下，两者其实都是 square 公司出品的，不同的地方在于 Retrofit 是基于 OkHttp 封装的一套 RESTful 网络请求框架，使用方面更加灵活，属于后起之秀！

既然大家都觉得 OkHttp 好用，一起来认识一下它！

来着网上对于 OkHttp 相关的介绍如下！

OkHttp 是 Square 公司基于 Java 和 Android 程序，封装的一个高性能 http 网络请求客户端，并且对外开源，它的设计初衷是为了更快地加载资源并节省带宽。

以下是使用 OkHttp 的主要优势：

- 支持HTTP/2（有效使用套接字）
- 连接池（在没有HTTP/2的情况下减少请求延迟）
- GZIP压缩（缩小下载大小）
- 响应缓存（避免了重新获取相同的数据）
- 从常见的连接问题中无声恢复
- 替代 IP 地址检测（在 IPv4 和 IPv6 环境下）
- 支持现代TLS功能（TLS 1.3，ALPN，证书钉子）
- 支持同步和异步调用

目前 OkHttp 在开源项目中被广泛使用，同时也是 Retrofit、Picasso 等库的核心库。

既然这么厉害，在网络通信中如何使用呢，一起来学习一下！

### 二、案例实践

#### 2.1、添加依赖包

在使用之前，需要先导入okhttp依赖包，不同的版本号，相关 api 稍有区别，本次介绍的 api 操作基于3.14.9版本号。

```xml
<dependency>
  <groupId>com.squareup.okhttp3</groupId>
  <artifactId>okhttp</artifactId>
  <version>3.14.9</version>
</dependency>
```

#### 2.2、get 同步请求

okhttp发起get同步请求非常的简单，只需要几行代码就可以搞定。

案例如下：

```java
String url = "https://www.baidu.com/";

OkHttpClient client = new OkHttpClient();
// 配置GET请求
Request request = new Request.Builder()
        .url(url)
        .get()
        .build();

// 发起同步请求
try (Response response = client.newCall(request).execute()){
    // 打印返回结果
    System.out.println(response.body().string());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 2.3、post 表单同步请求

okhttp发起post表单格式的数据提交，同步请求编程也非常的简单，只需要几行代码就可以搞定。

案例如下：

```java
String url = "https://www.baidu.com/";

OkHttpClient client = new OkHttpClient();
// 配置 POST + FORM 格式数据请求
RequestBody body = new FormBody.Builder()
        .add("userName", "zhangsan")
        .add("userPwd", "123456")
        .build();
Request request = new Request.Builder()
        .url(url)
        .post(body)
        .build();

// 发起同步请求
try (Response response = client.newCall(request).execute()){
    // 打印返回结果
    System.out.println(response.body().string());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 2.4、post 表单 + 文件上传，同步请求

如果在发起表单请求的时候，还需要上传文件，该如何实现呢？

案例如下：

```java
String url = "https://www.baidu.com/";

OkHttpClient client = new OkHttpClient();

// 要上传的文件
File file = new File("/doc/Downloads/429545913565844e9b26f97dbb57a1c3.jpeg");
RequestBody fileBody = RequestBody.create(MediaType.parse("image/jpg"), file);

// 表单 + 文件数据提交
RequestBody multipartBody = new MultipartBody.Builder()
        .setType(MultipartBody.FORM)
        .addFormDataPart("userName", "zhangsan")
        .addFormDataPart("userPwd", "123456")
        .addFormDataPart("userFile", "00.png", fileBody)
        .build();
Request request = new Request.Builder()
        .url(url)
        .post(multipartBody)
        .build();

// 发起同步请求
try (Response response = client.newCall(request).execute()){
    // 打印返回结果
    System.out.println(response.body().string());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 2.5、post + json 数据，同步请求

okhttp发起post + json格式的数据提交，同步请求编程也很简单。

案例如下：

```java
MediaType contentType = MediaType.get("application/json; charset=utf-8");
String url = "https://www.baidu.com/";
String json = "{}";

OkHttpClient client = new OkHttpClient();
// 配置 POST + JSON 请求
RequestBody body = RequestBody.create(contentType, json);
Request request = new Request.Builder()
        .url(url)
        .post(body)
        .build();

// 发起同步请求
try (Response response = client.newCall(request).execute()){
    // 打印返回结果
    System.out.println(response.body().string());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 2.5、文件下载，同步请求

文件下载，通常是get方式请求，只需要在响应端使用字节流接受数据即可！

案例如下：

```java
public static void main(String[] args)  {
    //目标存储文件
    String targetFile = "/doc/Downloads/1.png";
    //需要下载的原始文件
    String url = "https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png";

    OkHttpClient client = new OkHttpClient();
    // 配置GET请求
    Request request = new Request.Builder()
            .url(url)
            .build();

    // 发起同步请求
    try (Response response = client.newCall(request).execute()){
        // 获取文件字节流
        byte[] stream = response.body().bytes();
        // 写入目标文件
        writeFile(targetFile, stream);
    } catch (Exception e) {
        e.printStackTrace();
    }
}


/**
 * 写入目标文件
 * @param targetFile
 * @param stream
 * @throws IOException
 */
private static void writeFile(String targetFile, byte[] stream) throws IOException {
    String filePath = StringUtils.substringBeforeLast(targetFile, "/");
    Path folderPath = Paths.get(filePath);
    if(!Files.exists(folderPath)){
        Files.createDirectories(folderPath);
    }
    Path targetFilePath = Paths.get(targetFile);
    if(!Files.exists(targetFilePath)){
        Files.write(targetFilePath, stream, StandardOpenOption.CREATE);
    }
}
```

#### 2.6、其他方式的同步请求

在实际的项目开发中，有的接口需要使用put或者delete方式请求，应该如何处理呢？

put方式请求，案例如下：

```java
// 只需要在 Request 配置类中，换成 put 方式即可
Request request = new Request.Builder()
        .url(url)
        .put(body)
        .build();
```

同样的，delete方式请求也类似，案例如下：

```java
// 只需要在 Request 配置中，换成 delete 方式即可
Request request = new Request.Builder()
        .url(url)
        .delete(body)
        .build();
```

#### 2.7、自定义添加请求头部

大部分的时候，基于安全的考虑，很多时候需要把相关的鉴权参数放在请求头部，应该如何处理呢？

以post + json格式请求为例，添加头部请求参数，案例如下：

```java
MediaType contentType = MediaType.get("application/json; charset=utf-8");
String url = "https://www.baidu.com/";
String json = "{}";

OkHttpClient client = new OkHttpClient();

// 配置 header 头部请求参数
Headers headers = new Headers.Builder()
        .add("token", "11111-22222-333")
        .build();

// 配置 POST + JSON 请求
RequestBody body = RequestBody.create(contentType, json);
Request request = new Request.Builder()
        .url(url)
        .headers(headers)
        .post(body)
        .build();

// 发起同步请求
try (Response response = client.newCall(request).execute()){
    // 打印返回结果
    System.out.println(response.body().string());
} catch (Exception e) {
    e.printStackTrace();
}
```

#### 2.8、发起异步请求

在上文中介绍的都是同步请求，在最开始也说到 OkHttp 不仅支持同步调用，也异步调用，那么如何进行异步请求编程呢？其实操作很简单，案例如下：

```java
String url = "https://www.baidu.com/";
OkHttpClient client = new OkHttpClient().newBuilder().build();
Request request = new Request.Builder()
        .url(url)
        .get()
        .build();

// 发起异步请求
client.newCall(request).enqueue(new Callback() {
    @Override
    public void onFailure(Call call, IOException e) {
        System.out.println("请求异常 + " + e.getMessage());
    }

    @Override
    public void onResponse(Call call, Response response) throws IOException {
        System.out.println("请求完成，返回结果：" + response.body().string());
    }
});
```

### 三、小结

以上就是针对 OkHttp 在使用上，做了一次简单的内容总结，整体下来，从使用上来讲，api 的操作确实比 Apache HttpClient 要简单很多。

关于 OkHttp 的内容其实还有很多，比如请求参数的全局配置、全局拦截器、websocket 等功能。

## OkHttp 核心配置

### 一、摘要

OkHttp 的网络请求操作方式，虽然能满足基本日常网络请求使用，但是离实际的业务需求定制化开发还远远不够，这里重点介绍 OkHttp 的一些配置项的使用方式。

### 二、案例实践

本次采用okhttp3库版本为3.14.9，依赖包如下！

```xml
<dependency>
  <groupId>com.squareup.okhttp3</groupId>
  <artifactId>okhttp</artifactId>
  <version>3.14.9</version>
</dependency>
```

#### 2.1、全局设置超时时长

如果想设置全局配置请求的超时时间，可以通过如下方式实现！

案例如下！

```java
// 设置请求配置相关参数
OkHttpClient client = new OkHttpClient().newBuilder()
        .connectTimeout(5, TimeUnit.SECONDS)     //设置socket连接超时时间
        .readTimeout(5, TimeUnit.SECONDS)        // 设置数据读取连接超时时间
        .writeTimeout(5, TimeUnit.SECONDS)       // 设置数据写入连接超时时间
        .retryOnConnectionFailure(true)                  //是否自动重连
        .build();
```

#### 2.2、全局配置连接池

默认的情况下，共享连接池的配置为：最多有 5 个空闲连接，每个空闲连接最多保持 5 分钟，源码如下：

```java
public final class ConnectionPool {
    final RealConnectionPool delegate;

    public ConnectionPool() {
        this(5, 5L, TimeUnit.MINUTES);
    }

    //....
}
```

当然，也可以自定义连接池配置，实现方式如下！

案例如下！

```java
// 设置请求配置相关参数，配置共享连接池
OkHttpClient client = new OkHttpClient().newBuilder()
        .connectionPool(new ConnectionPool(5, 10, TimeUnit.MINUTES))
        .build();
```

表示最多有 5 个空闲连接，每个空闲连接最多保持 10 分钟。

#### 2.3、配置全局拦截器

某些时候，想为通过使用 okhttp 的网路请求，统一加上固定的请求头部或者对返回参数进行统一解析，可以添加一个请求拦截器。

案例如下！

```java
// 设置请求配置相关参数，添加一个拦截器
OkHttpClient client = new OkHttpClient().newBuilder().addInterceptor(new Interceptor() {
    @Override
    public Response intercept(Chain chain) throws IOException {
        Request request = chain.request();
        System.out.println("请求前拦截，请求参数：" + request.toString());
        Response response = chain.proceed(request);
        System.out.println("请求后拦截，返回参数：" + response.toString());
        return response;
    }
})
.build();
```

拦截器在实际的开发中，使用的非常频繁，比如想知道每个请求阶段的详细日志，OkHttp 已经预制了一个日志拦截器，只需要添加相应的依赖包文件，即可进行打印。

```xml
<!--添加日志拦截器-->
<dependency>
  <groupId>com.squareup.okhttp3</groupId>
  <artifactId>logging-interceptor</artifactId>
  <version>3.14.9</version>
</dependency>
```

在请求头部里面添加它，即可对每个阶段的请求日志进行详细打印。

```java
// 日志拦截器
HttpLoggingInterceptor logInterceptor = new HttpLoggingInterceptor();
logInterceptor.setLevel(HttpLoggingInterceptor.Level.BASIC);

// 设置请求配置相关参数
OkHttpClient client = new OkHttpClient().newBuilder()
        .addInterceptor(logInterceptor)
        .build();
```

#### 2.4、全局配置缓存

在调试接口的时候，可能已经注意到，完成了很多不必要的请求，给服务器带来了额外的负载。如果请求服务端返回的结果都是一样的，此时配置缓存，可以很大的缓解服务端的请求压力。

在 OkHttp  中有一个默认的缓存实现，只需要指定缓存位置和它的大小即可。

案例如下！

```java
// 设置请求配置相关参数，配置缓存文件
OkHttpClient client = new OkHttpClient().newBuilder()
        .cache(new Cache(new File("/local/cacheDirectory"), 10 * 1024 * 1024))
        .build();
```

如果某个接口不想走缓存，每次直接进行网络请求，可以通过在请求配置上指定`CacheControl.FORCE_NETWORK`，设置此次请求能使用网络，不用缓存。

案例如下！

```java
// 设置请求配置相关参数，全局配置缓存
OkHttpClient client = new OkHttpClient().newBuilder()
        .cache(new Cache(new File("/local/cacheDirectory"), 10 * 1024 * 1024))
        .build();

// 配置GET请求，配置FORCE_NETWORK，强制走网路请求
Request request = new Request.Builder()
        .url(url)
        .cacheControl(CacheControl.FORCE_NETWORK)
        .build();
```

#### 2.5、全局配置代理

有些环境，无法直接请求服务端的接口，而是需要通过代理服务器进行请求，此时如何配置呢？

案例如下！

```java
// 配置代理服务器的ip和端口
Proxy proxy = new Proxy(
    Proxy.Type.HTTP,
    new InetSocketAddress("192.168.1.100", 8080) // the local proxy
);

// 设置请求配置相关参数
OkHttpClient client = new OkHttpClient().newBuilder()
.proxy(proxy)
.build();
```

#### 2.6、全局配置 https

有些环境，需要以 https 的安全协议进行请求，此时如何配置呢？

案例如下！

```java
import okhttp3.*;
import okhttp3.internal.platform.Platform;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.net.ssl.*;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public class TestClientHttps {

    public static void main(String[] args)  {
        String url = "https://www.baidu.com/";

        OkHttpClient client = new OkHttpClient().newBuilder()
        .sslSocketFactory(getSSLSocketFactory(), getX509TrustManager())
        .hostnameVerifier(getHostnameVerifier())
        .build();

        Request request = new Request.Builder()
        .url(url)
        .get()
        .build();

        // 发起同步请求
        try (Response response = client.newCall(request).execute()){
            // 打印返回结果
            System.out.println(response.body().string());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    /**
     * 获取SSLSocketFactory
     * @return
     */
    public static SSLSocketFactory getSSLSocketFactory() {
        try {
            SSLContext sslContext = SSLContext.getInstance("SSL");
            sslContext.init(null, getTrustManager(), new SecureRandom());
            return sslContext.getSocketFactory();
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 获取TrustManager
     * @return
     */
    private static TrustManager[] getTrustManager() {
        TrustManager[] trustAllCerts = new TrustManager[]{
            new X509TrustManager() {
                @Override
                public void checkClientTrusted(X509Certificate[] chain, String authType) {
                }

                @Override
                public void checkServerTrusted(X509Certificate[] chain, String authType) {
                }

                @Override
                public X509Certificate[] getAcceptedIssuers() {
                    return new X509Certificate[]{};
                }
            }
        };
        return trustAllCerts;
    }


    /**
     * 获取HostnameVerifier，验证主机名
     * @return
     */
    public static HostnameVerifier getHostnameVerifier() {
        HostnameVerifier hostnameVerifier = (s, sslSession) -> true;
        return hostnameVerifier;
    }


    /**
     * X509TrustManager：证书信任器管理类
     * @return
     */
    public static X509TrustManager getX509TrustManager() {
        X509TrustManager x509TrustManager = new X509TrustManager() {
            //检查客户端的证书是否可信
            @Override
            public void checkClientTrusted(X509Certificate[] chain, String authType) {

            }
            //检查服务器端的证书是否可信
            @Override
            public void checkServerTrusted(X509Certificate[] chain, String authType) {

            }

            @Override
            public X509Certificate[] getAcceptedIssuers() {
                return new X509Certificate[0];
            }
        };
        return x509TrustManager;
    }
}
```

#### 2.7、全局配置 WebSocket

某些场景下，希望客户端与服务器实现长链接的模式进行数据通行，使用 OkHttp 客户端如何处理呢？

案例如下！

```java
OkHttpClient client = new OkHttpClient();

// 服务端请求地址
String socketServerUrl = "ws://mytodoserver.com/realtime";
Request request = new Request.Builder().url(socketServerUrl).build();

// connecting to a socket and receiving messages
client.newWebSocket(request, new WebSocketListener() {
    @Override
    public void onClosed(@NotNull WebSocket webSocket, int code, @NotNull String reason) {
        super.onClosed(webSocket, code, reason);
        //TODO: implement your own event handling
    }

    @Override
    public void onClosing(@NotNull WebSocket webSocket, int code, @NotNull String reason) {
        super.onClosing(webSocket, code, reason);
        //TODO: implement your own event handling
    }

    @Override
    public void onFailure(@NotNull WebSocket webSocket, @NotNull Throwable t, @Nullable Response response) {
        super.onFailure(webSocket, t, response);
        //TODO: implement your own event handling
    }

    @Override
    public void onMessage(@NotNull WebSocket webSocket, @NotNull String text) {
        super.onMessage(webSocket, text);
        //TODO: implement your own event handling for incoming messages
    }

    @Override
    public void onMessage(@NotNull WebSocket webSocket, @NotNull ByteString bytes) {
        super.onMessage(webSocket, bytes);
        //TODO: implement your own event handling for incoming messages
    }

    @Override
    public void onOpen(@NotNull WebSocket webSocket, @NotNull Response response) {
        super.onOpen(webSocket, response);
        //TODO: implement your own event handling
    }
});
```

#### 2.8、完整的全局配置参数介绍

kHttp 支持的全局配置参数非常多，以上只是介绍了一些大家常用的配置，详细的参数配置如下！

```java
// 设置请求配置相关参数
OkHttpClient client = new OkHttpClient.Builder()
        .cache(cache) // configure cache, see above
        .proxy(proxy) // configure proxy, see above
        .certificatePinner(certificatePinner) // certificate pinning, see above
        .addInterceptor(interceptor) // app level interceptor, see above
        .addNetworkInterceptor(interceptor) // network level interceptor, see above
        .authenticator(authenticator) // authenticator for requests (it supports similar use-cases as "Authorization header" earlier
        .callTimeout(10000) // default timeout for complete calls
        .readTimeout(10000) // default read timeout for new connections
        .writeTimeout(10000) // default write timeout for new connections
        .dns(dns) // DNS service used to lookup IP addresses for hostnames
        .followRedirects(true) // follow requests redirects
        .followSslRedirects(true) // follow HTTP tp HTTPS redirects
        .connectionPool(connectionPool) // connection pool used to recycle HTTP and HTTPS connections
        .retryOnConnectionFailure(true) // retry or not when a connectivity problem is encountered
        .cookieJar(cookieJar) // cookie manager
        .dispatcher(dispatcher) // dispatcher used to set policy and execute asynchronous requests
        .build();
```

如果有需要的，可以参考官方文档，地址如下：https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/-builder/

### 三、小结

以上就是针对 OkHttp 在配置使用上，做了一次简单的内容总结，尤其是客户端的全局超时配置、全局连接池配置、全局拦截器等功能，在实际的开发中，使用的比较多；关于 OkHttp 的原理介绍会，后续的文章中进行介绍。

## OkHttp完美封装

### OKHttpUtil

在Java的世界中，Http客户端之前一直是Apache家的HttpClient占据主导，但是由于此包较为庞大，API又比较难用，因此并不使用很多场景。而新兴的OkHttp、Jodd-http固然好用，但是面对一些场景时，学习成本还是有一些的。

很多时候，想追求轻量级的Http客户端，并且追求简单易用。而OKHttp是一套处理 HTTP 网络请求的依赖库，由 Square 公司设计研发并开源，目前可以在 Java 和 Kotlin 中使用。

对于 Android App来说，OkHttp 现在几乎已经占据了所有的网络请求操作，对于服务器端请求外部接口也是必备的选择 。针对OKHttp，OkHttpUtil做了一层封装，使Http请求变得无比简单。

### OKHttpUtil 功能

- 根据URL自动判断是请求HTTP还是HTTPS，不需要单独写多余的代码。
- 默认情况下Cookie自动记录，比如可以实现模拟登录，即第一次访问登录URL后后续请求就是登录状态。
- 自动识别304跳转并二次请求
- 支持代理配置
- 支持referer配置
- 支持User-Agent配置
- 自动识别并解压Gzip格式返回内容
- 支持springboot 配置文件
- 极简的封装调用

### OKHttpUtil使用

Maven引入

```xml
<dependency>
  <groupId>io.github.admin4j</groupId>
  <artifactId>http</artifactId>
  <version>0.4.0</version>
</dependency>
```

最新版查询：https://search.maven.org/artifact/io.github.admin4j/http

#### GET

最简单的使用莫过于用HttpUtil工具类快速请求某个接口：

```java
Response response = HttpUtil.get("https://github.com/search", Pair.of("q", "okhttp"));
System.out.println("response = " + response);
```

#### POST

一行代码即可搞定，当然Post请求也很简单：

```java
// JSON 格式的body
Response post = HttpUtil.post("https://oapi.dingtalk.com/robot/send?access_token=27f5954ab60ea8b2e431ae9101b1289c138e85aa6eb6e3940c35ee13ff8b6335", "{\"msgtype\": \"text\",\"text\": {\"content\":\"【反馈提醒】我就是我, 是不一样的烟火\"}}");
System.out.println("post = " + post);

// form 请求
Map<String, Object> formParams = new HashMap<>(16);
formParams.put("username", "admin");
formParams.put("password", "admin123");
Response response = HttpUtil.postForm("http://192.168.1.13:9100/auth/login",
                                      formParams
                                     );
System.out.println("response = " + response);
```

返回格式为JSON的 可以使用 HttpJsonUtil 自动返回JsonObject

```java
JSONObject object=HttpJsonUtil.get("https://github.com/search",
                                   Pair.of("q","http"),
                                   Pair.of("username","agonie201218"));
System.out.println("object = "+object);
```

#### 文件上传

```java
File file=new File("C:\\Users\\fcant\\Downloads\\Sql.txt");
Map<String, Object> formParams=new HashMap<>();
formParams.put("key","test");
formParams.put("file",file);
formParams.put("token","WXyUseb-D4sCum-EvTIDYL-mEehwDtrSBg-Zca7t:qgOcR2gUoKmxt-VnsNb657Oatzo=:eyJzY29wZSI6InpoYW56aGkiLCJkZWFkbGluZSI6MTY2NTMwNzUxNH0=");
Response response=HttpUtil.upload("https://upload.qiniup.com/",formParams);
System.out.println(response);
```

#### 下载文件

```java
HttpUtil.down("https://gitee.com/admin4j/common-http","path/");
```

### HttpRequest 链式请求

```java
// get
Response response=HttpRequest.get("https://search.gitee.com/?skin=rec&type=repository")
.queryMap("q","admin4j")
.header(HttpHeaderKey.USER_AGENT,"admin4j")
.execute();
System.out.println("response = "+response);

// post form
Response response=HttpRequest.get("http://192.168.1.13:9100/auth/login")
.queryMap("q","admin4j")
.header(HttpHeaderKey.USER_AGENT,"admin4j")
.form("username","admin")
.form("password","admin123")
.execute();
System.out.println("response = "+response);
```

post form 日志

```plain
16:49:14.092[main]DEBUG io.github.admin4j.http.core.HttpLogger- -->GET http://192.168.1.13:9100/auth/login?q=admin4j http/1.1
16:49:14.094[main]DEBUG io.github.admin4j.http.core.HttpLogger-User-Agent:admin4j
16:49:14.094[main]DEBUG io.github.admin4j.http.core.HttpLogger-Host:192.168.1.13:9100
16:49:14.094[main]DEBUG io.github.admin4j.http.core.HttpLogger-Connection:Keep-Alive
16:49:14.094[main]DEBUG io.github.admin4j.http.core.HttpLogger-Accept-Encoding:gzip
16:49:14.094[main]DEBUG io.github.admin4j.http.core.HttpLogger- -->END GET
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-<--200OK http://192.168.1.13:9100/auth/login?q=admin4j (575ms)
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-transfer-encoding:chunked
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Origin
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Access-Control-Request-Method
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Access-Control-Request-Headers
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Origin
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Access-Control-Request-Method
16:49:14.670[main]DEBUG io.github.admin4j.http.core.HttpLogger-Vary:Access-Control-Request-Headers
16:49:14.671[main]DEBUG io.github.admin4j.http.core.HttpLogger-Content-Type:application/json;charset=utf-8
16:49:14.671[main]DEBUG io.github.admin4j.http.core.HttpLogger-Date:Tue,08Nov 2022 08:49:14GMT
16:49:14.671[main]DEBUG io.github.admin4j.http.core.HttpLogger-
16:49:14.671[main]DEBUG io.github.admin4j.http.core.HttpLogger-{"code":406,"msg":"Full authentication is required to access this resource"}
16:49:14.671[main]DEBUG io.github.admin4j.http.core.HttpLogger-<--END HTTP(76-byte body)
response=Response{protocol=http/1.1,code=200,message=OK,url=http://192.168.1.13:9100/auth/login?q=admin4j}
```

### 在 Springboot 中使用

maven引入

```xml
<dependency>
  <groupId>io.github.admin4j</groupId>
  <artifactId>common-http-starter</artifactId>
  <version>0.4.0</version>
</dependency>
```

最新版查询 io.github.admin4j:common-http-starter

Spring 版可以对 OkHttp进行个性化配置

配置详见

```java
public class HttpConfig {
    /**
     * 日志等级
     */
    private HttpLoggingInterceptor.Level loggLevel = HttpLoggingInterceptor.Level.BODY;

    /**
     * 读取超时时间，秒
     */
    private long readTimeout = 30;
    /**
     * 链接超时时间
     */
    private long connectTimeout = 30;

    private boolean followRedirects = false;

    /**
     * 最大的连接数
     */
    private int maxIdleConnections = 5;

    /**
     * 最大的kepAlive 时间 秒
     */
    private long keepAliveDuration = 5;

    private String userAgent = "OKHTTP";
    /**
     * 是否支持cookie
     */
    private boolean cookie = false;
    private ProxyConfig proxy;


    @Data
    public static class ProxyConfig {

        private Proxy.Type type = Proxy.Type.HTTP;
        private String host;
        private Integer port = 80;
        private String userName;
        private String password;
    }
}
```

### 如何快速封装外部接口

以实体项目为例，封装 ebay接口

```java
public class EbayClient extends ApiJsonClient {

    /**
     * 店铺配置
     *
     * @param storeId
     */
    public EbayClient(Long storeId) {

        //TODO 获取店铺相关配置
        Map<String, String> config = new HashMap<>();

        basePath = "https://api.ebay.com";
        defaultHeaderMap.put("Authorization", "Bearer " + config.get("accessToken"));
        defaultHeaderMap.put("X-EBAY-C-MARKETPLACE-ID", config.get("marketplaceId"));
    }
}
```

EbayClient 封装ebay api请求 基础类

```java
/**
 * ebay 库存相关api
 */
public class EbayInventoryClient extends EbayClient {

    /**
     * 店铺配置
     *
     * @param storeId
     */
    public EbayInventoryClient(Long storeId) {
        super(storeId);
    }

    /**
     * 库存列表
     *
     * @param limit
     * @param offset
     * @return
     * @throws IOException
     */
    public JSONObject inventoryItem(Integer limit, Integer offset) throws IOException {

        Map<String, Object> queryMap = new HashMap(2);
        queryMap.put("limit", limit);
        queryMap.put("offset", offset);
        return get("/sell/inventory/v1/inventory_item", queryMap);
    }
}
```

`EbayInventoryClient` 封装ebay 库存 api请求

使用

```java
EbayInventoryClient ebayInventoryClient=new EbayInventoryClient(1L);
JSONObject jsonObject=ebayInventoryClient.inventoryItem(0,10);
```

```java
/**
 * 订单相关api
 */
public class EbayOrderClient extends EbayClient {


    /**
     * 店铺配置
     *
     * @param storeId
     */
    public EbayOrderClient(Long storeId) {
        super(storeId);
    }

    /**
     * 订单列表
     *
     * @param beginTime
     * @param endTime
     * @param limit
     * @param offset
     * @return
     */
    public JSONObject orders(String beginTime, String endTime, int limit, int offset) {

        final String path = "/sell/fulfillment/v1/order";

        String filter = MessageFormat.format("lastmodifieddate:[{0}..{1}]", beginTime, endTime);

        //
        Map<String, Object> queryMap = new HashMap<>(8);
        queryMap.put("filter", filter);
        queryMap.put("limit", limit);
        queryMap.put("offset", offset);

        return get("/sell/inventory/v1/inventory_item", queryMap);
    }
}
```

库存相关的使用`EbayInventoryClient`，订单相关的使用`EbayOrderClient`，是不是很清晰.

## OkHttp3 工具类封装

### 一、摘要

在实际的系统开发过程中，通常会基于项目环境，封装一个公共的网络请求工具库，以便开发接口请求相关的需求时，能更加方便的使用。

以服务端编程为例，以下是封装工具类的实践过程。

### 二、案例实践

#### 2.1、首先在项目中导入相关的依赖包

```xml
<!-- okhttp3 -->
<dependency>
  <groupId>com.squareup.okhttp3</groupId>
  <artifactId>okhttp</artifactId>
  <version>3.14.9</version>
</dependency>
```

```xml
<!--jackson依赖包-->
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-core</artifactId>
  <version>2.9.8</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-annotations</artifactId>
  <version>2.9.8</version>
</dependency>
<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.9.8</version>
</dependency>
<dependency>
  <groupId>commons-collections</groupId>
  <artifactId>commons-collections</artifactId>
  <version>3.2.2</version>
  <scope>compile</scope>
</dependency>
```

#### 2.2、封装 OkHttpClient 相关请求方法

首先将 OkHttpClient 客户端配置参数单独拎出来，方便后续独立配置。

```java
public class OkHttpClientFactory {

    /**
     * 默认允许的最大并发数
     */
    private static int concurrentSize = 100;

    private OkHttpClientFactory(){}

    /**
     * 实例化客户端配置
     * @return
     */
    public static OkHttpClient.Builder newInstance() {
        OkHttpClient.Builder httpClientBuilder = new OkHttpClient.Builder();

        // 设置超时时间
        httpClientBuilder.connectTimeout(5, TimeUnit.SECONDS);
        httpClientBuilder.writeTimeout(5, TimeUnit.SECONDS);
        httpClientBuilder.readTimeout(5, TimeUnit.SECONDS);

        // 设置连接池，连接池的最大数量=并发数，30秒空闲的连接会释放掉
        httpClientBuilder.connectionPool(new ConnectionPool(concurrentSize, 30, TimeUnit.SECONDS));

        // 设置分发器处理的最大容量，这里的数量=连接池数量=并发数，表示此客户端有同时能够处理xx并发数的能力
        Dispatcher dispatcher = new Dispatcher();
        dispatcher.setMaxRequests(concurrentSize);
        dispatcher.setMaxRequestsPerHost(concurrentSize);
        httpClientBuilder.dispatcher(dispatcher);

        return httpClientBuilder;
    }

}
```

然后，构建一个 OkHttpClient 客户端单例对象。

```java
public class OkHttpClientBuilder {

    private static final Logger LOGGER = LoggerFactory.getLogger(OkHttpClientBuilder.class);

    /**
     * 同步阻塞等待执行结果的时间，单位毫秒
     */
    private static Integer DEFAULT_WAIT_TIMEOUT = 3000;

    /**
     * 服务启动时初始化OkHttpClient对象，确保客户端对象单例
     */
    private static OkHttpClient okHttpClient = OkHttpClientFactory.newInstance().build();

    private OkHttpClientBuilder() {}


    static {
        // 向JVM注册一个关闭钩子，当服务准备停止时，等待 OkHttpClient 中任务执行完毕再停止，防止线程池中正在执行的任务突然中断
        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
            @Override
            public void run() {
                final Logger logger = LoggerFactory.getLogger(OkHttpClient.class);
                int count = 100;
                Dispatcher dispatcher = okHttpClient.dispatcher();
                logger.info("ShutdownHook start：queuedCallsCount {} , runningCallsCount {}", dispatcher.queuedCallsCount(), dispatcher.runningCallsCount());
                while (dispatcher.queuedCallsCount() > 0 || dispatcher.runningCallsCount() > 0) {
                    try {
                        TimeUnit.MILLISECONDS.sleep(100);
                    } catch (InterruptedException e) {
                        logger.error("ShutdownHook interrupted：queuedCallsCount {} , runningCallsCount {}", dispatcher.queuedCallsCount(), dispatcher.runningCallsCount());
                        break;
                    }
                    // 防止无限循环
                    if (--count == 0) {
                        LOGGER.error("ShutdownHook timeout：queuedCallsCount {} , runningCallsCount {}", dispatcher.queuedCallsCount(), dispatcher.runningCallsCount());
                        break;
                    }
                }
                logger.info("ShutdownHook end：queuedCallsCount {} , runningCallsCount {}", dispatcher.queuedCallsCount(), dispatcher.runningCallsCount());
            }
        }));
    }


    /**
     * 同步执行请求，公共方法
     * @param request
     * @return
     */
    public static OkHttpClientResult syncRequest(Request request){
        try (Response response = okHttpClient.newCall(request).execute()){
            return buildResponseResult(request, response);
        } catch (Exception e) {
            LOGGER.error("request error，request:" +  request, e);
            return new OkHttpClientResult(false, 500, "request error");
        }
    }



    /**
     * 异步执行请求，同步阻塞编程等待返回结果
     * 此方式在多线程环境下请求处理依然能保持高性能，根据不同的场景显式对ConnectionPool进行调优处理
     * @param request
     * @return
     */
    public static OkHttpClientResult syncResponse(Request request){
        if(LOGGER.isDebugEnabled()){
            LOGGER.debug("request start，request:{}", request);
        }
        // 使用异步编程，在指定时间内阻塞获取 OKHttp 异步执行结果
        CompletableFuture<Response> completableFuture = new CompletableFuture();
        // 发起异步请求调用
        Call call = okHttpClient.newCall(request);
        call.enqueue(new Callback(){

            @Override
            public void onFailure(Call call, IOException e) {
                completableFuture.completeExceptionally(e);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                completableFuture.complete(response);
            }
        });
        // 这里的异步执行结果等待时间，取决于get同步获取时间的设定，而不是全局请求超时配置
        try (Response response = completableFuture.get(DEFAULT_WAIT_TIMEOUT, TimeUnit.MILLISECONDS);) {
            return buildResponseResult(request, response);
        } catch (TimeoutException e){
            call.cancel();
            LOGGER.error("request timeout，request:" +  request, e);
            return new OkHttpClientResult(false, 500, "request timeout");
        } catch (Exception e){
            LOGGER.error("request error，request:" +  request, e);
            return new OkHttpClientResult(false, 500, "request error");
        }
    }

    /**
     * 封装返回值
     * @param request
     * @param response
     * @return
     * @throws IOException
     */
    private static OkHttpClientResult buildResponseResult(Request request, Response response) throws IOException {
        if(LOGGER.isDebugEnabled()){
            LOGGER.debug("request end，request:{}, response:{}", request, response);
        }
        ResponseBody responseBody = response.body();
        OkHttpClientResult result = new OkHttpClientResult();
        result.setSuccess(response.isSuccessful());
        result.setCode(response.code());
        result.setMessage(response.message());
        result.setHeaders(response.headers().toMultimap());
        if(Objects.nonNull(responseBody)){
            result.setBody(responseBody.bytes());
        }
        if(!result.isSuccess()){
            LOGGER.warn("request fail, request:{}, response:{}", request, response);
        }
        return result;
    }
}
```

相关的返回实体类对象

```java
public class OkHttpClientResult {

    /**
     * 是否成功
     */
    private boolean success = false;

    /**
     * http级，状态标识码
     */
    private Integer code;

    /**
     * http级，错误信息
     */
    private String message;

    /**
     * http级，返回头部
     */
    private Map<String, List<String>> headers;

    /**
     * http级，返回body
     */
    private byte[] body;

    public boolean isSuccess() {
        return success;
    }

    public void setSuccess(boolean success) {
        this.success = success;
    }

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Map<String, List<String>> getHeaders() {
        return headers;
    }

    public void setHeaders(Map<String, List<String>> headers) {
        this.headers = headers;
    }

    public byte[] getBody() {
        return body;
    }

    public void setBody(byte[] body) {
        this.body = body;
    }

    public OkHttpClientResult() {
    }

    public OkHttpClientResult(boolean success, int code, String message) {
        this.success = success;
        this.code = code;
        this.message = message;
    }
}
```

最后，基于以上的方法，封装一个独立的网络请求工具类

```java
public class OkHttpClientUtils {

    /**
     * get请求
     * @param url
     * @param headers
     * @return
     */
    public static String get(String url, Map<String, String> headers){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .get()
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result);
    }

    /**
     * get请求（支持范型对象返回参数）
     * @param url
     * @param headers
     * @param responseType
     * @param <T>
     * @return
     */
    public static <T> T get(String url, Map<String, String> headers, TypeReference<T> responseType){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .get()
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result, responseType);
    }

    /**
     * post表单请求
     * @param url
     * @param paramMap
     * @param headers
     * @return
     */
    public static String postByForm(String url, Map<String, String> paramMap, Map<String, String> headers){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .post(buildFormBody(paramMap))
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result);
    }

    /**
     * post表单请求（支持范型对象返回参数）
     * @param url
     * @param paramMap
     * @param headers
     * @param responseType
     * @param <T>
     * @return
     */
    public static <T> T postByForm(String url, Map<String, String> paramMap, Map<String, String> headers, TypeReference<T> responseType){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .post(buildFormBody(paramMap))
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result, responseType);
    }


    /**
     * post + json请求
     * @param url
     * @param value
     * @param headers
     * @return
     */
    public static String postByJson(String url, Object value, Map<String, String> headers){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .post(buildJsonBody(value))
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result);
    }


    /**
     * post + json请求（支持范型对象返回参数）
     * @param url
     * @param value
     * @param headers
     * @param responseType
     * @param <T>
     * @return
     */
    public static <T> T postByJson(String url, Object value, Map<String, String> headers, TypeReference<T> responseType){
        Request request = new Request.Builder()
                .url(url)
                .headers(buildHeaders(headers))
                .post(buildJsonBody(value))
                .build();
        OkHttpClientResult result = commonRequest(request);
        return buildResponse(result, responseType);
    }


    /**
     * 包装请求头部
     * @param headers
     * @return
     */
    private static Headers buildHeaders(Map<String, String> headers){
        Headers.Builder headerBuilder = new Headers.Builder();
        if(MapUtils.isNotEmpty(headers)){
            headers.entrySet().forEach(entry -> headerBuilder.add(entry.getKey(), entry.getValue()));
        }
        return headerBuilder.build();
    }


    /**
     * 包装请求表单
     * @param paramMap
     * @return
     */
    private static FormBody buildFormBody(Map<String, String> paramMap){
        FormBody.Builder formBodyBuilder = new FormBody.Builder();
        if(MapUtils.isNotEmpty(paramMap)){
            paramMap.entrySet().forEach(entry -> formBodyBuilder.add(entry.getKey(), entry.getValue()));
        }
        return formBodyBuilder.build();
    }

    /**
     * 包装请求json数据
     * @param request
     * @return
     */
    private static RequestBody buildJsonBody(Object request){
        MediaType contentType = MediaType.parse("application/json; charset=utf-8");
        RequestBody requestBody = RequestBody.create(contentType, JacksonObjectUtil.objToJson(request));
        return requestBody;
    }

    /**
     * 包装返回结果，针对字符串
     * @param result
     * @return
     */
    private static String buildResponse(OkHttpClientResult result){
        if(!result.isSuccess() && StringUtils.isNotBlank(result.getMessage())){
            throw new RuntimeException(result.getMessage());
        }
        return byteToString(result.getBody());
    }

    /**
     * 包装返回结果，针对返回范型对象
     * @param result
     * @return
     */
    private static <T> T buildResponse(OkHttpClientResult result, TypeReference<T> responseType){
        if(!result.isSuccess() && StringUtils.isNotBlank(result.getMessage())){
            throw new RuntimeException(result.getMessage());
        }
        return JacksonObjectUtil.byteToObj(result.getBody(), responseType);
    }

    /**
     * 获取内容
     * @param bytes
     * @return
     */
    private static String byteToString(byte[] bytes){
        if(Objects.nonNull(bytes)){
            return new String(bytes, Charset.forName("utf-8"));
        }
        return StringUtils.EMPTY;
    }

    /**
     * 公共请求调用
     * @param request
     * @return
     */
    private static OkHttpClientResult commonRequest(Request request){
        return OkHttpClientBuilder.syncResponse(request);
    }
}
```

以上就是基于 OkHttp 封装的整套工具类，可能有的网友对`OkHttpClientBuilder.syncResponse`编程方法不太理解，会在下面进行详细的讲解。

#### 2.3、封装对象序列化工具

在上文的`OkHttpClientUtils`工具类中，提到了范型对象的返回。

其中用到了一个很重要的类库工具，那就是jackson类库，所以在上文第一段就介绍了导入jackson相关的库包。

基于jackson库封装的工具类JacksonObjectUtil，代码如下：

```java
public class JacksonObjectUtil {

    private static final Logger LOGGER = LoggerFactory.getLogger(JacksonObjectUtil.class);


    private static ObjectMapper objectMapper = new ObjectMapper();


    static {
        // 忽略未知的字段
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 读取不认识的枚举时，当null值处理
        objectMapper.configure(DeserializationFeature.READ_UNKNOWN_ENUM_VALUES_AS_NULL, true);
        // 全部输出
        objectMapper.configure(JsonParser.Feature.AUTO_CLOSE_SOURCE, true);
    }


    /**
     * 将对象序列化成字节流
     * @param value
     * @return
     */
    public static byte[] objToByte(Object value){
        try {
            if(Objects.nonNull(value)){
                return objectMapper.writeValueAsBytes(value);
            }
        } catch (Exception e){
            LOGGER.warn("将对象序列化成字节失败",e);
        }
        return null;
    }

    /**
     * 将对象序列化成json字符串
     * @param value
     * @return
     */
    public static String objToJson(Object value){
        try {
            if(Objects.nonNull(value)){
                return objectMapper.writeValueAsString(value);
            }
        } catch (Exception e){
            LOGGER.warn("将对象序列化成json字符串失败",e);
        }
        return "";
    }

    /**
     * 将json字符串转对象，支持指定类
     * @param value
     * @return
     */
    public static <T> T jsonToObj(String value, Class<T> classType){
        try {
            if(StringUtils.isNotBlank(value)){
                return objectMapper.readValue(value, classType);
            }
        } catch (Exception e){
            LOGGER.warn("将json字符串转对象失败，字符串：" + value, e);
        }
        return null;
    }


    /**
     * 将json字符串转对象，支持范型类
     * @param value
     * @return
     */
    public static <T> T jsonToObj(String value, TypeReference<T> referenceType){
        try {
            if(StringUtils.isNotBlank(value)){
                return objectMapper.readValue(value, referenceType);
            }
        } catch (Exception e){
            LOGGER.warn("将json字符串转对象失败，字符串：" + value, e);
        }
        return null;
    }

    /**
     * 将字节流转对象，支持范型类
     * @param value
     * @return
     */
    public static <T> T byteToObj(byte[] value, TypeReference<T> referenceType){
        try {
            if(Objects.nonNull(value)){
                return objectMapper.readValue(value, referenceType);
            }
        } catch (Exception e){
            LOGGER.warn("将字节流转对象失败", e);
        }
        return null;
    }
}
```

###  三、性能测试 

OkHttp 支持同步、异步两种模式的网络请求编程方法。

其实每种请求方式，带来的性能体验也大为不同。

以 200 个线程同时发起网络请求，同步请求／异步请求耗时如下：

```text
同步请求平均耗时：1997 ms
异步请求平均耗时：1798 ms
```

从数据显示结果，两者差异并不大。

下面以循环发起 200 请求为例，同步请求／异步请求耗时如下：

```text
同步请求平均耗时：6478 ms
异步请求平均耗时：1794 ms
```

两者所消耗的时间差异 3 倍，随着请求次数越多，差异越大。

**总结下来，采用异步请求所消耗的时间比同步请求低很多**。

基于以上结论，回到上文中介绍的`OkHttpClientBuilder`类，提供了两个方法。

一个是同步请求的编程方案

```java
/**
 * 同步执行请求，公共方法
 * @param request
 * @return
 */
public static OkHttpClientResult syncRequest(Request request){
    try (Response response = okHttpClient.newCall(request).execute()){
        return buildResponseResult(request, response);
    } catch (Exception e) {
        LOGGER.error("request error，request:" +  request, e);
        return new OkHttpClientResult(false, 500, "request error");
    }
}
```

另一个是异步请求，同步阻塞等待返回结果的编程方案。

```java
/**
 * 异步执行请求，同步阻塞编程等待返回结果
 * 此方式在多线程环境下请求处理依然能保持高性能，根据不同的场景显式对ConnectionPool进行调优处理
 * @param request
 * @return
 */
public static OkHttpClientResult syncResponse(Request request){
    if(LOGGER.isDebugEnabled()){
        LOGGER.debug("request start，request:{}", request);
    }
    // 使用异步编程，在指定时间内阻塞获取 OKHttp 异步执行结果
    CompletableFuture<Response> completableFuture = new CompletableFuture();
    // 发起异步请求调用
    Call call = okHttpClient.newCall(request);
    call.enqueue(new Callback(){

        @Override
        public void onFailure(Call call, IOException e) {
            completableFuture.completeExceptionally(e);
        }

        @Override
        public void onResponse(Call call, Response response) throws IOException {
            completableFuture.complete(response);
        }
    });
    // 这里的异步执行结果等待时间，取决于get同步获取时间的设定，而不是全局请求超时配置
    try (Response response = completableFuture.get(DEFAULT_WAIT_TIMEOUT, TimeUnit.MILLISECONDS);) {
        return buildResponseResult(request, response);
    } catch (TimeoutException e){
        call.cancel();
        LOGGER.error("request timeout，request:" +  request, e);
        return new OkHttpClientResult(false, 500, "request timeout");
    } catch (Exception e){
        LOGGER.error("request error，request:" +  request, e);
        return new OkHttpClientResult(false, 500, "request error");
    }
}
```

此方案其实本质是采用 OkHttp 异步请求的方式来编程，**只是为了满足业务上同步返回请求结果**，加入了`CompletableFuture`异步编程类，通过同步阻塞的方式来获取响应结果，以满足高性能的网络请求需要。

为了眼见为实，同步请求和异步请求同步阻塞等待结果，看看不同的请求模式下，请求所耗时的时间情况。

以循环发起多次请求为例，统计结果如下：

|                          | 循环请求200次 | 循环请求800次 |
| ------------------------ | ------------- | ------------- |
| 同步请求                 | 6176 ms       | 24276 ms      |
| 异步请求同步阻塞等待结果 | 6150 ms       | 24598ms       |

以同一时刻，发起多次请求为例，统计结果如下：

|                          | 同一时刻发起200次请求 | 同—时刻发起800次请录 |
| ------------------------ | --------------------- | -------------------- |
| 同步请求                 | 1997ms                | 6412ms               |
| 异步请求同步阻塞等待结果 | 1223ms                | 2308ms               |

从数据的结论上看，如上面的分析一样，在循环请求场景下，两者几乎无差异，但是在多线程请求场景下，两者差异很明显。

采用**异步请求同步阻塞等待结果**这种编程方式，能有效的降低接口请求所消耗的时间。

为什么在多线程环境下，**异步请求同步阻塞等待结果**这种方式能显著的提升效率呢，其实答案也很简单，因为 OkHttp 在进行异步请求的时候，使用了线程池来进行执行任务，能有效的管理需要执行的任务。

而采用同步编程的方式，执行的时候是直接发起同步调用的，无线程池管理，这就可能会出现一个问题，当瞬间出现大量的线程发起请求的时候，可能会导致 cpu 突然利用率飙升，资源会严重挤压占用，反而不利于任务的有效执行。

最后有一个地方特别需要注意，如果项目中使用了自定义的线程池来异步的执行任务，**一定要向JVM注册一个关闭钩子**，当 JVM 监听到服务关闭时，可以通过代码检查逻辑，等待线程池中的任务执行完毕之后，再关停服务，以防止数据丢失。

## Java封装OkHttp3工具类

### 准备工作

Maven项目在pom文件中引入jar包

```xml
<dependency>
    <groupId>com.squareup.okhttp3</groupId>
    <artifactId>okhttp</artifactId>
    <version>3.10.0</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.60</version>
</dependency>
```

引入json是因为工具类中有些地方用到了，现在通信都流行使用json传输，也少不了要这个jar包

### 工具类代码

```java
import com.alibaba.fastjson.JSON;
import okhttp3.*;

import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSocketFactory;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.io.IOException;
import java.net.URLEncoder;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class OkHttpUtils {
    private static volatile OkHttpClient okHttpClient = null;
    private static volatile Semaphore semaphore = null;
    private Map<String, String> headerMap;
    private Map<String, String> paramMap;
    private String url;
    private Request.Builder request;

    /**
     * 初始化okHttpClient，并且允许https访问
     */
    private OkHttpUtils() {
        if (okHttpClient == null) {
            synchronized (OkHttpUtils.class) {
                if (okHttpClient == null) {
                    TrustManager[] trustManagers = buildTrustManagers();
                    okHttpClient = new OkHttpClient.Builder()
                            .connectTimeout(15, TimeUnit.SECONDS)
                            .writeTimeout(20, TimeUnit.SECONDS)
                            .readTimeout(20, TimeUnit.SECONDS)
                            .sslSocketFactory(createSSLSocketFactory(trustManagers), (X509TrustManager) trustManagers[0])
                            .hostnameVerifier((hostName, session) -> true)
                            .retryOnConnectionFailure(true)
                            .build();
                    addHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36");
                }
            }
        }
    }

    /**
     * 用于异步请求时，控制访问线程数，返回结果
     *
     * @return
     */
    private static Semaphore getSemaphoreInstance() {
        //只能1个线程同时访问
        synchronized (OkHttpUtils.class) {
            if (semaphore == null) {
                semaphore = new Semaphore(0);
            }
        }
        return semaphore;
    }

    /**
     * 创建OkHttpUtils
     *
     * @return
     */
    public static OkHttpUtils builder() {
        return new OkHttpUtils();
    }

    /**
     * 添加url
     *
     * @param url
     * @return
     */
    public OkHttpUtils url(String url) {
        this.url = url;
        return this;
    }

    /**
     * 添加参数
     * 
     * @param key   参数名
     * @param value 参数值
     * @return
     */
    public OkHttpUtils addParam(String key, String value) {
        if (paramMap == null) {
            paramMap = new LinkedHashMap<>(16);
        }
        paramMap.put(key, value);
        return this;
    }

    /**
     * 添加请求头
     *
     * @param key   参数名
     * @param value 参数值
     * @return
     */
    public OkHttpUtils addHeader(String key, String value) {
        if (headerMap == null) {
            headerMap = new LinkedHashMap<>(16);
        }
        headerMap.put(key, value);
        return this;
    }

    /**
     * 初始化get方法
     *
     * @return
     */
    public OkHttpUtils get() {
        request = new Request.Builder().get();
        StringBuilder urlBuilder = new StringBuilder(url);
        if (paramMap != null) {
            urlBuilder.append("?");
            try {
                for (Map.Entry<String, String> entry : paramMap.entrySet()) {
                    urlBuilder.append(URLEncoder.encode(entry.getKey(), "utf-8")).
                            append("=").
                            append(URLEncoder.encode(entry.getValue(), "utf-8")).
                            append("&");
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
            urlBuilder.deleteCharAt(urlBuilder.length() - 1);
        }
        request.url(urlBuilder.toString());
        return this;
    }

    /**
     * 初始化post方法
     *
     * @param isJsonPost true等于json的方式提交数据，类似postman里post方法的raw
     *                   false等于普通的表单提交
     * @return
     */
    public OkHttpUtils post(boolean isJsonPost) {
        RequestBody requestBody;
        if (isJsonPost) {
            String json = "";
            if (paramMap != null) {
                json = JSON.toJSONString(paramMap);
            } 
            requestBody = RequestBody.create(MediaType.parse("application/json; charset=utf-8"), json);
        } else {
            FormBody.Builder formBody = new FormBody.Builder();
            if (paramMap != null) {
                paramMap.forEach(formBody::add);
            }
            requestBody = formBody.build();
        }
        request = new Request.Builder().post(requestBody).url(url);
        return this;
    }

    /**
     * 同步请求
     *
     * @return
     */
    public String sync() {
        setHeader(request);
        try {
            Response response = okHttpClient.newCall(request.build()).execute();
            assert response.body() != null;
            return response.body().string();
        } catch (IOException e) {
            e.printStackTrace();
            return "请求失败：" + e.getMessage();
        }
    }

    /**
     * 异步请求，有返回值
     */
    public String async() {
        StringBuilder buffer = new StringBuilder("");
        setHeader(request);
        okHttpClient.newCall(request.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                buffer.append("请求出错：").append(e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                assert response.body() != null;
                buffer.append(response.body().string());
                getSemaphoreInstance().release();
            }
        });
        try {
            getSemaphoreInstance().acquire();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return buffer.toString();
    }

    /**
     * 异步请求，带有接口回调
     *
     * @param callBack
     */
    public void async(ICallBack callBack) {
        setHeader(request);
        okHttpClient.newCall(request.build()).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                callBack.onFailure(call, e.getMessage());
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                assert response.body() != null;
                callBack.onSuccessful(call, response.body().string());
            }
        });
    }

    /**
     * 为request添加请求头
     *
     * @param request
     */
    private void setHeader(Request.Builder request) {
        if (headerMap != null) {
            try {
                for (Map.Entry<String, String> entry : headerMap.entrySet()) {
                    request.addHeader(entry.getKey(), entry.getValue());
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }


    /**
     * 生成安全套接字工厂，用于https请求的证书跳过
     *
     * @return
     */
    private static SSLSocketFactory createSSLSocketFactory(TrustManager[] trustAllCerts) {
        SSLSocketFactory ssfFactory = null;
        try {
            SSLContext sc = SSLContext.getInstance("SSL");
            sc.init(null, trustAllCerts, new SecureRandom());
            ssfFactory = sc.getSocketFactory();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ssfFactory;
    }

    private static TrustManager[] buildTrustManagers() {
        return new TrustManager[]{
                new X509TrustManager() {
                    @Override
                    public void checkClientTrusted(X509Certificate[] chain, String authType) {
                    }

                    @Override
                    public void checkServerTrusted(X509Certificate[] chain, String authType) {
                    }

                    @Override
                    public X509Certificate[] getAcceptedIssuers() {
                        return new X509Certificate[]{};
                    }
                }
        };
    }

    /**
     * 自定义一个接口回调
     */
    public interface ICallBack {

        void onSuccessful(Call call, String data);

        void onFailure(Call call, String errorMsg);

    }
}
```

### 使用教程

```java
public static void main(String[] args) {
    // get请求，方法顺序按照这种方式，切记选择post/get一定要放在倒数第二，同步或者异步倒数第一，才会正确执行
    OkHttpUtils.builder().url("请求地址，http/https都可以")
            // 有参数的话添加参数，可多个
            .addParam("参数名", "参数值")
            .addParam("参数名", "参数值")
            // 也可以添加多个
            .addHeader("Content-Type", "application/json; charset=utf-8")
            .get()
            // 可选择是同步请求还是异步请求
            //.async();
            .sync();

    // post请求，分为两种，一种是普通表单提交，一种是json提交
    OkHttpUtils.builder().url("请求地址，http/https都可以")
            // 有参数的话添加参数，可多个
            .addParam("参数名", "参数值")
            .addParam("参数名", "参数值")
            // 也可以添加多个
            .addHeader("Content-Type", "application/json; charset=utf-8")
            // 如果是true的话，会类似于postman中post提交方式的raw，用json的方式提交，不是表单
            // 如果是false的话传统的表单提交
            .post(true)
            .sync();
    
    // 选择异步有两个方法，一个是带回调接口，一个是直接返回结果
    OkHttpUtils.builder().url("")
            .post(false)
            .async();

    OkHttpUtils.builder().url("").post(false).async(new OkHttpUtils.ICallBack() {
        @Override
        public void onSuccessful(Call call, String data) {
            // 请求成功后的处理
        }

        @Override
        public void onFailure(Call call, String errorMsg) {
            // 请求失败后的处理
        }
    });
}
```



















