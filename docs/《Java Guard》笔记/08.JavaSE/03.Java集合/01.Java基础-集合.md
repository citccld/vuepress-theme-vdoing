## List复制：浅拷贝与深拷贝方法及区别

### List浅拷贝

![image-20230807220342033](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072203886.png)

众所周知，list本质上是数组，而数组的是以地址的形式进行存储。

如上图将list A浅拷贝给list B，由于进行的是浅拷贝，所以直接将A的内容复制给了B，java中相同内容的数组指向同一地址，即进行浅拷贝后A与B指向同一地址。造成的后果就是，改变B的同时也会改变A，因为改变B就是改变B所指向地址的内容，由于A也指向同一地址，所以A与B一起改变。

### 几种浅拷贝

#### 1、遍历循环复制

```java
List<Person> destList=new ArrayList<Person>(srcList.size());  
for(Person p : srcList){  
    destList.add(p);  
}
```

#### 2、使用List实现类的构造方法

```java
List<Person> destList=new ArrayList<Person>(srcList);
```

#### 3、使用`list.addAll()`方法

```java
List<Person> destList=new ArrayList<Person>();  
destList.addAll(srcList);
```

#### 4、使用`System.arraycopy()`方法

```java
Person[] srcPersons=srcList.toArray(new Person[0]);  
Person[] destPersons=new Person[srcPersons.length];  
System.arraycopy(srcPersons, 0, destPersons, 0, srcPersons.length);
```

测试及结果

```java
printList(destList); //打印未改变B之前的A 
srcList.get(0).setAge(100);//改变B  
printList(destList); //打印改变B后的A
```

打印结果

```plain
123-->20  
ABC-->21  
abc-->22  
123-->100  
ABC-->21  
abc-->22  
```

### List深拷贝

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072224335.jpeg" alt="img" style="zoom: 50%;" />

如图，深拷贝就是将A复制给B的同时，给B创建新的地址，再将地址A的内容传递到地址B。ListA与ListB内容一致，但是由于所指向的地址不同，所以改变相互不受影响。

### 深拷贝的方法

#### 1.使用序列化方法

```java
public static <T> List<T> deepCopy(List<T> src) throws IOException, ClassNotFoundException {  
    ByteArrayOutputStream byteOut = new ByteArrayOutputStream();  
    ObjectOutputStream out = new ObjectOutputStream(byteOut);  
    out.writeObject(src);  

    ByteArrayInputStream byteIn = new ByteArrayInputStream(byteOut.toByteArray());  
    ObjectInputStream in = new ObjectInputStream(byteIn);  
    @SuppressWarnings("unchecked")  
    List<T> dest = (List<T>) in.readObject();  
    return dest;  
}  

List<Person> destList=deepCopy(srcList);  //调用该方法
```

#### 2.`clone`方法

```java
public class A implements Cloneable {   
    public String name[];   

    public A(){   
        name=new String[2];   
    }   

    public Object clone() {   
        A o = null;   
        try {   
            o = (A) super.clone();   
        } catch (CloneNotSupportedException e) {   
            e.printStackTrace();   
        }   
        return o;   
    }   
}  
for(int i=0;i<n;i+=){
    copy.add((A)src.get(i).clone());
}
```

Java对对象和基本的数据类型的处理是不一样的。在Java中用对象的作为入口参数的传递则缺省为”引用传递”，也就是说仅仅传递了对象的一个”引用”，这个”引用”的概念同C语言中的指针引用是一样的。当函数体内部对输入变量改变时，实质上就是在对这个对象的直接操作。

除了在函数传值的时候是”引用传递”，在任何用”＝”向对象变量赋值的时候都是”引用传递”。

测试及结果

```jaa
printList(destList); //打印未改变B之前的A 
srcList.get(0).setAge(100);//改变B  
printList(destList); //打印改变B后的AprintList(destList); //打印未改变B之前的A 
srcList.get(0).setAge(100);//改变B  
printList(destList); //打印改变B后的A
```

```java
123-->20  
ABC-->21  
abc-->22  
123-->20  
ABC-->21  
abc-->22  
```

在浅复制的情况下，源数据被修改破坏之后，使用相同引用指向该数据的目标集合中的对应元素也就发生了相同的变化。因此，在需求要求必须深复制的情况下，要是使用上面提到的方法，请确保List中的T类对象是不易被外部修改和破坏的。

## List去除重复数据的五种方式

### 1、使用`LinkedHashSet`删除`arraylist`中的重复数据

`LinkedHashSet`是在一个ArrayList删除重复数据的最佳方法。`LinkedHashSet`在内部完成两件事：

- 删除重复数据
- 保持添加到其中的数据的顺序

Java示例使用`LinkedHashSet`删除`arraylist`中的重复项。在给定的示例中，`numbersList`是包含整数的`arraylist`，其中一些是重复的数字。

例如1,3和5.将列表添加到`LinkedHashSet`，然后将内容返回到列表中。结果`arraylist`没有重复的整数。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashSet;

public class ArrayListExample{
    public static void main(String[] args)
    {
        ArrayList<Integer> numbersList = new ArrayList<>(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));
        System.out.println(numbersList);
        LinkedHashSet<Integer> hashSet = new LinkedHashSet<>(numbersList);
        ArrayList<Integer> listWithoutDuplicates = new ArrayList<>(hashSet);
        System.out.println(listWithoutDuplicates);
    }
}
```

输出结果

```plain
[1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8]
 
[1, 2, 3, 4, 5, 6, 7, 8]
```

### 2、使用Java8新特性`stream`进行List去重

要从`arraylist`中删除重复项，也可以使用java 8 stream api。使用`steam`的`distinct()`方法返回一个由不同数据组成的流，通过对象的`equals()`方法进行比较。

收集所有区域数据List使用`Collectors.toList()`。

Java程序，用于在不使用Set的情况下从java中的`arraylist`中删除重复项。

```java
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class ArrayListExample{
    public static void main(String[] args){
        ArrayList<Integer> numbersList = new ArrayList<>(Arrays.asList(1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8));
        System.out.println(numbersList);
        List<Integer> listWithoutDuplicates = numbersList.stream().distinct().collect(Collectors.toList());
        System.out.println(listWithoutDuplicates);
    }
}
```

输出结果

```plain
[1, 1, 2, 3, 3, 3, 4, 5, 6, 6, 6, 7, 8]
 
[1, 2, 3, 4, 5, 6, 7, 8]
```

### 3、利用`HashSet`不能添加重复数据的特性

由于`HashSet`不能保证添加顺序，所以只能作为判断条件保证顺序：

```java
private static void removeDuplicate(List<String> list) {
    HashSet<String> set = new HashSet<String>(list.size());
    List<String> result = new ArrayList<String>(list.size());
    for (String str : list) {
        if (set.add(str)) {
            result.add(str);
        }
    }
    list.clear();
    list.addAll(result);
}
```

### 4、利用`List`的`contains`方法循环遍历

重新排序，只添加一次数据,避免重复：

```java
private static void removeDuplicate(List<String> list) {
    List<String> result = new ArrayList<String>(list.size());
    for (String str : list) {
        if (!result.contains(str)) {
            result.add(str);
        }
    }
    list.clear();
    list.addAll(result);
}
```

### 5、双重`for`循环去重（不推荐在List元素都一样的情况下使用）

```java
for (int i = 0; i < list.size(); i++) { 
    for (int j = 0; j < list.size(); j++) { 
        if(i!=j&&list.get(i).equals(list.get(j))) { 
            list.remove(list.get(j)); 
        } 
    }
}
```

## List 去重的 6 种方法

### 前置知识

正式开始之前，先来搞懂两组概念：无序集合和有序集合 & 无序和有序。因为接下来的方法实现中，会反复提及这两组概念，所以有必要在正式开始之前，先把它们搞清楚。

#### 无序集合

无序集合是指，数据读取的顺序和数据插入的顺序是不一致的。

例如，插入集合的顺序是：1、5、3、7，而集合的读取顺序竟然是：1、3、5、7。

#### 有序集合

有序集合的概念和无序集合的概念正好相反，它是指集合的读取顺序和插入顺序是一致的。

例如，插入数据的顺序是：1、5、3、7，那么读取的顺序也是：1、5、3、7。

#### 有序和无序

通过上面的无序集合和有序集合，可以得出有序和无序的概念。有序指的是数据的排列顺序和读取顺序符合预期就叫做有序。而无序指的是数据的排列顺序和读取顺序不符合预期就叫做无序。

PS：如果对于有序和无序的概念不是很清楚也没关系，通过下面的事例，可以进一步的理解它们的含义。

### 方法1：contains判断去重(有序)

要进行数据去重，首先想到的是新建一个集合，然后循环原来的集合，每次循环判断原集合中的循环项，如果当前循环的数据，没有在新集合中存在就插入，已经存在了就舍弃，这样当循环执行完，就得到了一个没有重复元素的集合了，实现代码如下：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method(list);
    }

    /**
     * 自定义去重
     * @param list
     */
    public static void method(List<Integer> list) {
        // 新集合
        List<Integer> newList = new ArrayList<>(list.size());
        list.forEach(i -> {
            if (!newList.contains(i)) { // 如果新集合中不存在则插入
                newList.add(i);
            }
        });
        System.out.println("去重集合:" + newList);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072232262.webp)此方法的优点的：理解起来比较简单，并且最终得到的集合也是有序的，这里的有序指的是新集合的排列顺序和原集合的顺序是一致的；但缺点是实现代码有点多，不够简洁优雅。

### 方法2：迭代器去重(无序)

自定义 List 去重，除了上面的新建集合之外，也可以使用迭代器循环判断每一项数据，如果当前循环的数据，在集合中存在两份或两份以上，就将当前的元素删除掉，这样循环完之后，也可以得到一个没有重复数据的集合，实现代码如下：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method_1(list);
    }

    /**
     * 使用迭代器去重
     * @param list
     */
    public static void method_1(List<Integer> list) {
        Iterator<Integer> iterator = list.iterator();
        while (iterator.hasNext()) {
            // 获取循环的值
            Integer item = iterator.next();
            // 如果存在两个相同的值
            if (list.indexOf(item) != list.lastIndexOf(item)) {
                // 移除最后那个相同的值
                iterator.remove();
            }
        }
        System.out.println("去重集合:" + list);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072233020.webp)此方法的实现比上一种方法的实现代码要少一些，并且不需要新建集合，但此方法得到的新集合是无序的，也就是新集合的排列顺序和原集合不一致，因此也不是最优的解决方案。

### 方法3：HashSet去重(无序)

知道 HashSet 天生具备“去重”的特性，那只需要将 List 集合转换成 HashSet 集合就可以了，实现代码如下：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method_2(list);
    }

    /**
     * 使用 HashSet 去重
     * @param list
     */
    public static void method_2(List<Integer> list) {
        HashSet<Integer> set = new HashSet<>(list);
        System.out.println("去重集合:" + set);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072233428.webp)此方法的实现代码较为简洁，但缺点是 HashSet 会自动排序，这样新集合的数据排序就和原集合不一致了，如果对集合的顺序有要求，那么此方法也不能满足当前需求。

### 方法4：LinkedHashSet去重(有序)

既然 HashSet 会自动排序不能满足需求，那就使用 LinkedHashSet，它既能去重又能保证集合的顺序，实现代码如下：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method_3(list);
    }

    /**
     * 使用 LinkedHashSet 去重
     * @param list
     */
    public static void method_3(List<Integer> list) {
        LinkedHashSet<Integer> set = new LinkedHashSet<>(list);
        System.out.println("去重集合:" + set);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072233224.webp)从上述代码和执行结果可以看出，LinkedHashSet 是到目前为止，实现比较简单，且最终生成的新集合与原集合顺序保持一致的实现方法，是可以考虑使用的一种去重方法。

### 方法5：TreeSet去重(无序)

除了以上的 Set 集合之外，还可以使用 TreeSet 集合来实现去重功能，实现代码如下：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method_4(list);
    }

    /**
     * 使用 TreeSet 去重(无序)
     * @param list
     */
    public static void method_4(List<Integer> list) {
        TreeSet<Integer> set = new TreeSet<>(list);
        System.out.println("去重集合:" + set);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072233535.webp)比较遗憾的是，TreeSet 虽然实现起来也比较简单，但它有着和 HashSet 一样的问题，会自动排序，因此也不能满足需求。

### 方法6：Stream去重(有序)

JDK 8 带来了一个非常实用的方法 Stream，使用它可以实现很多功能，比如下面的去重功能：

```java
public class ListDistinctExample {
    public static void main(String[] args) {
        List<Integer> list = new ArrayList<Integer>() {{
            add(1);
            add(3);
            add(5);
            add(2);
            add(1);
            add(3);
            add(7);
            add(2);
        }};
        System.out.println("原集合:" + list);
        method_5(list);
    }

    /**
     * 使用 Stream 去重
     * @param list
     */
    public static void method_5(List<Integer> list) {
        list = list.stream().distinct().collect(Collectors.toList());
        System.out.println("去重集合:" + list);
    }
}
```

以上程序执行的结果，如下所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072233142.webp)Stream 实现去重功能和其他方法不同的是，它不用新创建集合，使用自身接收一个去重的结果就可以了，并且实现代码也很简洁，并且去重后的集合顺序也和原集合的顺序保持一致，是最优先考虑的去重方法。

### 总结

这里介绍了 6 种集合去重的方法，其中实现最简洁，且去重之后的顺序能和原集合保持一致的实现方法，只有两种：LinkedHashSet 去重和 Stream 去重，而后一种去重方法无需借助新集合，是优先考虑的去重方法。

### 去除 List 中的重复元素

#### List 去重方案

**假设有以下数据：**

```java
/**
 * 3 个张三，2 个李强
 */
public List<String> initList = Arrays.asList(
    "张三", 
    "李四", 
    "张三", 
    "周一", 
    "刘四", 
    "李强", 
    "李白", 
    "张三", 
    "李强", 
    "王五"
);
```

#### 1、for 循环添加去重

```java
/**
 * for 循环添加去重
 */
@Test
public void remove1() {
    List<String> list = new ArrayList(initList);
    List<String> list2 = new ArrayList<>();
    for (String element : list) {
        if (!list2.contains(element)) {
            list2.add(element);
        }
    }
    System.out.println(list2);
}
```

这个是最基本的实现了，创建一个空的 List，添加前判断一下存在不存在，不存在才添加，这样就保证了元素不重复。

输出结果：

```text
[张三, 李四, 周一, 刘四, 李强, 李白, 王五]
```

#### 2、for 双循环去重

```java
/**
 * for 双循环去重
 */
@Test
public void remove2() {
    List<String> list = new ArrayList(initList);
    for (int i = 0; i < list.size() - 1; i++) {
        for (int j = list.size() - 1; j > i; j--) {
            if (list.get(j).equals(list.get(i))) {
                list.remove(j);
            }
        }
    }
    System.out.println(list);
}
```

利用双循环，判断是否有相等的，再进行移除。

输出结果：

```text
[张三, 李四, 周一, 刘四, 李强, 李白, 王五]
```

#### 3、for 循环重复坐标去重

```java
/**
 * for 循环重复坐标去重
 */
@Test
public void remove3() {
    List<String> list = new ArrayList(initList);
    List<String> list2 = new ArrayList(initList);
    for (String element : list2) {
        if (list.indexOf(element) != list.lastIndexOf(element)) {
            list.remove(list.lastIndexOf(element));
        }
    }
    System.out.println(list);
}
```

这种方式很新颖吧？

复制一个 list2，再循环 List2，判断 list 中的元素的首尾出现的坐标位置是否一致，如果一致，则说明没有重复的，否则重复，再删除重复的位置的元素。

输出结果：

```text
[张三, 李四, 周一, 刘四, 李强, 李白, 王五]
```

#### 4、Set 去重

```java
/**
 * Set 去重
 */
@Test
public void remove4() {
    List<String> list = new ArrayList(initList);
    List<String> list2 = new ArrayList(new HashSet(list));
    System.out.println(list2);
}
```

这招也太简单了吧，一行代码搞定！

Set 是不包含重复元素的，把 List 先装进 HashSet，然后再装回来，这样就保证了元素的不重复。

输出结果：

```text
[李强, 李四, 张三, 周一, 李白, 王五, 刘四]
```

结果虽然正确，但元素顺序和原始 List 不一致，如果要保证顺序性，可以把 HashSet 换成 `LinkedHashSet`：

```java
/**
 * Set 去重
 */
@Test
public void remove4() {
    List<String> list = new ArrayList(initList);
    List<String> list2 = new ArrayList(new LinkedHashSet(list));
    System.out.println(list2);
}
```

输出结果：

```text
[张三, 李四, 周一, 刘四, 李强, 李白, 王五]
```

这下顺序对了吧，`LinkedHashSet` 可以保证元素的顺序性！

#### 5、Stream 去重

```java
/**
 * Stream 去重
 */
@Test
public void remove5() {
    List<String> list = new ArrayList(initList);
    list = list.stream().distinct().collect(Collectors.toList());
    System.out.println(list);
}
```

利用 Stream 的 `distinct` 方法去重，这个方法也十分简单，一行代码搞定！

输出结果：

```text
[张三, 李四, 周一, 刘四, 李强, 李白, 王五]
```

#### 总结

本文总结了 5 种去除 List 重复元素的方法：

- for 循环添加去重
- for 双循环去重
- for 循环重复坐标去重
- Set 去重
- Stream 去重

最后两种方案最简单，都是一行代码就能搞定的，推荐使用！

### List 根据对象的属性去重

#### 一、去除List中重复的String

```java
public List<String> removeStringListDupli(List<String> stringList) {
    Set<String> set = new LinkedHashSet<>();
    set.addAll(stringList);

    stringList.clear();

    stringList.addAll(set);
    return stringList;
}
```

或使用Java8的写法：

```java
List<String> unique = list.stream().distinct().collect(Collectors.toList());
```

#### 二、List中对象去重

比如现在有一个 Person类:

```java
public class Person {
	private Long id;
	
	private String name;
	
	public Person(Long id, String name) {
		this.id = id;
		this.name = name;
	}
	
	public Long getId() {
		return id;
	}
	
	public void setId(Long id) {
		this.id = id;
	}
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	@Override
	public String toString() {
		return "Person{" +
			"id=" + id +
			", name='" + name + '\'' +
			'}';
	}
}
```

重写Person对象的`equals()`方法和`hashCode()`方法:

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;

    Person person = (Person) o;

    if (!id.equals(person.id)) return false;
    return name.equals(person.name);

}

@Override
public int hashCode() {
    int result = id.hashCode();
    result = 31 * result + name.hashCode();
    return result;
}
```

下面对象去重的代码：

```java
Person p1 = new Person(1l, "jack");
Person p2 = new Person(3l, "jack chou");
Person p3 = new Person(2l, "tom");
Person p4 = new Person(4l, "hanson");
Person p5 = new Person(5l, "胶布虫");

List<Person> persons = Arrays.asList(p1, p2, p3, p4, p5, p5, p1, p2, p2);

List<Person> personList = new ArrayList<>();
// 去重
persons.stream().forEach(
	p -> {
		if (!personList.contains(p)) {
			personList.add(p);
		}
	}
);
System.out.println(personList);
```

List 的`contains()`方法底层实现使用对象的equals方法去比较的，其实重写`equals()`就好，但重写了equals最好将hashCode也重写了。

#### 三、根据对象的属性去重

下面要根据Person对象的id去重，那该怎么做呢？

写一个方法吧:

```java
public static List<Person> removeDupliById(List<Person> persons) {
    Set<Person> personSet = new TreeSet<>((o1, o2) -> o1.getId().compareTo(o2.getId()));
    personSet.addAll(persons);

    return new ArrayList<>(personSet);
}
```

通过`Comparator`比较器，比较对象属性，相同就返回0，达到过滤的目的。

再来看比较炫酷的Java8写法:

```java
import static java.util.Comparator.comparingLong;
import static java.util.stream.Collectors.collectingAndThen;
import static java.util.stream.Collectors.toCollection;

// 根据id去重
 List<Person> unique = persons.stream().collect(
            collectingAndThen(
                    toCollection(() -> new TreeSet<>(comparingLong(Person::getId))), ArrayList::new)
    );
```

还有一种写法:

```text
public static <T> Predicate<T> distinctByKey(Function<? super T, Object> keyExtractor) {
    Map<Object, Boolean> map = new ConcurrentHashMap<>();
    return t -> map.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
}

// remove duplicate
    persons.stream().filter(distinctByKey(p -> p.getId())).forEach(p -> System.out.println(p));

```

## Java数组转List的三种方式及对比

### 一、最常见方式（未必最佳）

通过 `Arrays.asList(strArray)` 方式,将数组转换List后，不能对List增删，只能查改，否则抛异常。

关键代码：`List list = Arrays.asList(strArray);`

```java
private void testArrayCastToListError() {
    String[] strArray = new String[2];
    List list = Arrays.asList(strArray);
    //对转换后的list插入一条数据
    list.add("1");
    System.out.println(list);
}
```

执行结果：

```java
Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.AbstractList.add(AbstractList.java:148)
 at java.util.AbstractList.add(AbstractList.java:108)
 at com.darwin.junit.Calculator.testArrayCastToList(Calculator.java:19)
 at com.darwin.junit.Calculator.main(Calculator.java:44)
```

程序在list.add("1")处，抛出异常：UnsupportedOperationException。

原因解析：

`Arrays.asList(strArray)`返回值是`java.util.Arrays`类中一个私有静态内部类`java.util.Arrays.ArrayList`，它并非`java.util.ArrayList`类。`java.util.Arrays.ArrayList`类具有 set()，get()，contains()等方法，但是不具有添加`add()`或删除`remove()`方法,所以调用`add()`方法会报错。

使用场景：`Arrays.asList(strArray)`方式仅能用在将数组转换为List后，不需要增删其中的值，仅作为数据源读取使用。

### 二、数组转为List后，支持增删改查的方式

通过ArrayList的构造器，将`Arrays.asList(strArray)`的返回值由`java.util.Arrays.ArrayList`转为`java.util.ArrayList`。

关键代码：`ArrayList<String> list = new ArrayList<String>(Arrays.asList(strArray)) ;`

```java
private void testArrayCastToListRight() {
    String[] strArray = new String[2];
    ArrayList<String> list = new ArrayList<String>(Arrays.asList(strArray)) ;
    list.add("1");
    System.out.println(list);
}
```

执行结果：成功追加一个元素“1”。

```java
[null, null, 1]
```

使用场景：需要在将数组转换为List后，对List进行增删改查操作，在List的数据量不大的情况下，可以使用。

### 三、通过集合工具类`Collections.addAll()`方法(最高效)

通过`Collections.addAll(arrayList, strArray)`方式转换，根据数组的长度创建一个长度相同的List，然后通过`Collections.addAll()`方法，将数组中的元素转为二进制，然后添加到List中，这是最高效的方法。

关键代码：

```java
ArrayList< String> arrayList = new ArrayList<String>(strArray.length);
Collections.addAll(arrayList, strArray);
```

测试：

```java
private void testArrayCastToListEfficient(){
    String[] strArray = new String[2];
    ArrayList< String> arrayList = new ArrayList<String>(strArray.length);
    Collections.addAll(arrayList, strArray);
    arrayList.add("1");
    System.out.println(arrayList);
}
```

执行结果：同样成功追加一个元素“1”。

```java
[null, null, 1]
```

使用场景：需要在将数组转换为List后，对List进行增删改查操作，在List的数据量巨大的情况下，优先使用，可以提高操作速度。

注：附上`Collections.addAll()`方法源码：

```java
public static <T> boolean addAll(Collection<? super T> c, T... elements) {
    boolean result = false;
    for (T element : elements)
        result |= c.add(element);//result和c.add(element)按位或运算,然后赋值给result
    return result;
}
```

### 四、数组类型如果是整型数组，转为List时，会报错？

答案： 在`JDK1.8`环境中测试，这三种转换方式是没有问题的。对于`Integer[]`整型数组转List的方法和测试结果如下：

1. 方式一：不支持增删

```java
Integer[] intArray1 = new Integer[2];
List<Integer> list1 = Arrays.asList(intArray1);
System.out.println(list1);
```

运行结果：

```java
[null, null]
```

1. 方式二：支持增删

```java
Integer[] intArray2 = new Integer[2];
List<Integer> list2 = new ArrayList<Integer>(Arrays.asList(intArray2)) ;
list2.add(2);
System.out.println(list2);
```

运行结果：

```java
[null, null, 2]
```

1. 方式三：支持增删，且数据量大最高效

```java
Integer[] intArray3 = new Integer[2];
List<Integer> list3 = new ArrayList<Integer>(intArray3.length);
Collections.addAll(list3, intArray3);
list3.add(3);
System.out.println(list3);
```

运行结果：

```java
[null, null, 3]
```

综上，整型`Integer[]`数组转`List<Integer>`的正确方式应该是这样的。

易错点：可能出现的错误可能是这样转换的：

```java
int[] intArray1 = new int[2];
List<Integer> list1 = Arrays.asList(intArray1);//此处报错！！！
```

报错原因：等号两边类型不一致，编译不通过。

那么在声明数组时，用`int[]` 还是`Integer[]`，哪种声明方式才能正确的转为`List`呢？
答案： 只能用`Integer[]`转`List<Integer>`，即只能用基本数据类型的包装类型，才能直接转为`List`。

原因分析如下：

来看`List`在Java源码中的定义：

```java
public interface List<E> extends Collection<E> {省略…}
```

再来看`Arrays.asList()`的在Java源码定义：

```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```

- 从上述源码中可以看出，`List`声明时，需要传递一个泛型`<E>`作为形参，`asList()`参数类型也是泛型中的通配类型`<T>`。Java中所有的泛型必须是引用类型。
- 什么是引用类型？`Integer`是引用类型， `int`是基本数据类型，不是引用类型。这就是为什么java中没有`List<int>`，而只有`List<Integer>`。
- 举一反三：其他8种基本数据类型`byte、short、int、long、float、double、char`也都不是引用类型，所以8种基本数据类型都不能作为List的形参。但`String、数组、class、interface`是引用类型，都可以作为List的形参，所以存在`List<Runnable>`接口类型的集合、`List<int[]>`数组类型的集合、`List<String>`类的集合。但不存在`list<byte>`、`list<short>` 等基本类型的集合。

有了上述基础知识后，再来看为什么下面两行代码第二行能编译通过，第三行却编译报错？

```java
int[] intArray1 = new int[1]; 
Arrays.asList(intArray1);//编译不报错
List<Integer> list1 = Arrays.asList(intArray1);//编译报错
```

答案：

- 第二行代码，`Arrays.asList()`方法的入参是个引用类型的`int[]`,那么返回值类型一定是`List<int[]>` ,其完整代码是：`List<int[]> intsArray = Arrays.asList(intArray1);`，所以编译通过，没问题。
- 第三行报错，因为等号两边的类型不一致，左边：`List<Integer>`,右边`List<int[]>`，所以编译时就报错。

### 总结

现在应该明白，为什么`int[]`不能直接转换为`List<Integer>`，而`Integer[]`就可以转换为`List<Integer>`了吧。因为`List`中的泛型必须是引用类型，`int`是基本数据类型，不是引用类型，但`int`的包装类型`Integer`是`class`类型，属于引用类型，所以`Integer`可以作为`List`形参，`List<Integer>`在java中是可以存在的，但不存在`List<int>`类型。

## Java中List排序的3种方法

在某些特殊的场景下，需要在 Java 程序中对 List 集合进行排序操作。比如从第三方接口中获取所有用户的列表，但列表默认是以用户编号从小到大进行排序的，而系统需要按照用户的年龄从大到小进行排序，这个时候，就需要对 List 集合进行自定义排序操作了。

List 排序的常见方法有以下 3 种：

1. 使用 Comparable 进行排序；
2. 使用 Comparator 进行排序；
3. 如果是 JDK 8 以上的环境，也可以使用 Stream 流进行排序。

下面分别来看各种排序方法的具体实现。

### 1、使用 Comparable 排序

按照本文设计的场景，需要创建一个包含了用户列表的 List 集合，并按用户的年龄从大到小进行排序，具体实现代码如下：

```java
public class ListSortExample {
    public static void main(String[] args) {
        // 创建并初始化 List
        List<Person> list = new ArrayList<Person>() {{
            add(new Person(1, 30, "北京"));
            add(new Person(2, 20, "西安"));
            add(new Person(3, 40, "上海"));
        }};
        // 使用 Comparable 自定的规则进行排序
        Collections.sort(list);
        // 打印 list 集合
        list.forEach(p -> {
            System.out.println(p);
        });
    }
}

//  以下 set/get/toString 使用的是 lombok 的注解
@Getter
@Setter
@ToString
class Person implements Comparable<Person> {
    private int id;
    private int age;
    private String name;

    public Person(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }

    @Override
    public int compareTo(Person p) {
        return p.getAge() - this.getAge();
    }
}
```

以上代码的执行结果，如下图所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072242913.png)本方法的核心代码如下：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072242900.png)

### 2、使用 `Comparator` 排序

`Comparable` 是类内部的比较方法，而 `Comparator` 是排序类外部的比较器。使用 `Comparator` 比较器，无需修改原 Person 类，只需要扩充一个 Person 类的比较器就行了，`Comparator` 的实现方法有以下两种：

- 新建 `Comparator` 比较器；
- 使用 `Comparator` 匿名类比较器。

其中，第二种实现方法要更简洁一些，通过下面的具体代码，来观察一下二者的区别。

#### 2.1 新建 Comparator 比较器

```java
public class ListSortExample2 {
    public static void main(String[] args) {
        // 创建并初始化 List
        List<Person> list = new ArrayList<Person>() {{
            add(new Person(1, 30, "北京"));
            add(new Person(2, 20, "西安"));
            add(new Person(3, 40, "上海"));
        }};
        // 使用 Comparator 比较器排序
        Collections.sort(list, new PersonComparator());
        // 打印 list 集合
        list.forEach(p -> {
            System.out.println(p);
        });
    }
}
/**
 * 新建 Person 比较器
 */
class PersonComparator implements Comparator<Person> {
    @Override
    public int compare(Person p1, Person p2) {
        return p2.getAge() - p1.getAge();
    }
}
@Getter
@Setter
@ToString
class Person {
    private int id;
    private int age;
    private String name;

    public Person(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }
}
```

以上代码的执行结果，如下图所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072242579.png)本方法的核心实现代码如下：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072242496.png)

#### 2.2 匿名类比较器

比较器 Comparator 可以使用更简洁的匿名类的方式，来实现排序功能，具体实现代码如下：

```java
public class ListSortExample2 {
    public static void main(String[] args) {
        // 创建并初始化 List
        List<Person> list = new ArrayList<Person>() {{
            add(new Person(1, 30, "北京"));
            add(new Person(2, 20, "西安"));
            add(new Person(3, 40, "上海"));
        }};
        // 使用匿名比较器排序
        Collections.sort(list, new Comparator<Person>() {
            @Override
            public int compare(Person p1, Person p2) {
                return p2.getAge() - p1.getAge();
            }
        });
        // 打印 list 集合
        list.forEach(p -> {
            System.out.println(p);
        });
    }
}
@Getter
@Setter
@ToString
class Person {
    private int id;
    private int age;
    private String name;
    public Person(int id, int age, String name) {
        this.id = id;
        this.age = age;
        this.name = name;
    }
}
```

以上代码的执行结果，如下图所示：![img](assets/1651919987476-458b10aa-5a9e-496c-996f-5e99f9409e1f.png)

### 3、使用 Stream 流排序

在 JDK 8 之后可以使用更加简单的方法 Stream 流来实现排序功能，它的实现只需要一行代码，具体实现如下：

```java
public class ListSortExample3 {
	public static void main(String[] args) {
		// 创建并初始化 List
		List<Person> list = new ArrayList<Person>() {{
			add(new Person(1, 30, "北京"));
			add(new Person(2, 20, "西安"));
			add(new Person(3, 40, "上海"));
		}};
		// 使用 Stream 排序
		list = list.stream().sorted(Comparator.comparing(Person::getAge).reversed())
			.collect(Collectors.toList());
		// 打印 list 集合
		list.forEach(p -> {
			System.out.println(p);
		});
	}
	@Getter
	@Setter
	@ToString
	static class Person {
		private int id;
		private int age;
		private String name;
		public Person(int id, int age, String name) {
			this.id = id;
			this.age = age;
			this.name = name;
		}
	}
}
```

其中 `reversed()` 表示倒序的意思，如果不使用此方法则是正序。

以上代码的执行结果，如下图所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072243069.png)

#### 扩展：排序字段为 null

使用 Stream 进行排序时，如果排序的字段出现 null 值就会导致异常发生，具体示例如下：

```java
public class ListSortExample4 {
    public static void main(String[] args) {
        // 创建并初始化 List
        List<Person> list = new ArrayList<Person>() {{
            add(new Person(30, "北京"));
            add(new Person(10, "西安"));
            add(new Person(40, "上海"));
            add(new Person(null, "上海")); // 年龄为 null 值
        }};
        // 按照[年龄]正序,但年龄中有一个 null 值
        list = list.stream().sorted(Comparator.comparing(Person::getAge))
                .collect(Collectors.toList());
        // 打印 list 集合
        list.forEach(p -> {
            System.out.println(p);
        });
    }
}
@Getter
@Setter
@ToString
class Person {
    private Integer age;
    private String name;

    public Person(Integer age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

以上代码的执行结果，如下图所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072243491.png)想要解决上述问题，需要给 Comparator.comparing 传递第二个参数：Comparator.nullsXXX，如下代码所示：

```java
public class ListSortExample4 {
    public static void main(String[] args) {
        // 创建并初始化 List
        List<Person> list = new ArrayList<Person>() {{
            add(new Person(30, "北京"));
            add(new Person(10, "西安"));
            add(new Person(40, "上海"));
            add(new Person(null, "上海"));
        }};
        // 按照[年龄]正序,但年龄中有一个 null 值
        list = list.stream().sorted(Comparator.comparing(Person::getAge,
                Comparator.nullsFirst(Integer::compareTo)))
                .collect(Collectors.toList());
        // 打印 list 集合
        list.forEach(p -> {
            System.out.println(p);
        });
    }
}
@Getter
@Setter
@ToString
class Person {
    private Integer age;
    private String name;

    public Person(Integer age, String name) {
        this.age = age;
        this.name = name;
    }
}
```

`Comparator.nullsFirst` 表示将排序字段中的 null 值放到集合最前面，如果想要将 null 值放到集合最后面可以使用 `Comparator.nullsLast`。

以上代码的执行结果，如下图所示：![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072243532.png)

### 总结

这里介绍了 3 种 List 排序的方法，前两种方法常用于 JDK 8 之前的版本，其中比较器 Comparator 有两种实现的写法，而在 JDK 8 之后的版本，就可以使用 `Comparator.comparing` 实现排序了，如果排序字段中可能出现 null 值，要使用 `Comparator.nullsXXX` 进行排序处理（否则会报错）。

## 使用 Lambda 表达式实现超强的排序功能

在系统开发过程中，对数据排序是很常见的场景。一般来说，可以采用两种方式：

1. 借助存储系统（SQL、NoSQL、NewSQL 都支持）的排序功能，查询的结果即是排好序的结果
2. 查询结果为无序数据，在内存中排序。

今天要说的是第二种排序方式，在内存中实现数据排序。

首先定义一个基础类，后面将根据这个基础类演示如何在内存中排序。

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Student {
    private String name;
    private int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Student student = (Student) o;
        return age == student.age && Objects.equals(name, student.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

### 基于`Comparator`排序

在 Java8 之前，都是通过实现`Comparator`接口完成排序，比如：

```java
new Comparator<Student>() {
    @Override
    public int compare(Student h1, Student h2) {
        return h1.getName().compareTo(h2.getName());
    }
};
```

这里展示的是匿名内部类的定义，如果是通用的对比逻辑，可以直接定义一个实现类。使用起来也比较简单，如下就是应用：

```java
@Test
void baseSortedOrigin() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    Collections.sort(students, new Comparator<Student>() {
        @Override
        public int compare(Student h1, Student h2) {
            return h1.getName().compareTo(h2.getName());
        }
    });
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

这里使用了 Junit5 实现单元测试，用来验证逻辑非常适合。

因为定义的`Comparator`是使用name字段排序，在 Java 中，String类型的排序是通过单字符的 ASCII 码顺序判断的，J排在T的前面，所以Jerry排在第一个。

### 使用 Lambda 表达式替换`Comparator`匿名内部类

使用过 Java8 的 Lamdba 的应该知道，匿名内部类可以简化为 Lambda 表达式为：

```java
Collections.sort(students, (Student h1, Student h2) -> h1.getName().compareTo(h2.getName()));
```

在 Java8 中，`List`类中增加了`sort`方法，所以`Collections.sort`可以直接替换为：

```java
students.sort((Student h1, Student h2) -> h1.getName().compareTo(h2.getName()));
```

根据 Java8 中 Lambda 的类型推断，可以将指定的Student类型简写：

```java
students.sort((h1, h2) -> h1.getName().compareTo(h2.getName()));
```

至此，整段排序逻辑可以简化为：

```java
@Test
void baseSortedLambdaWithInferring() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    students.sort((h1, h2) -> h1.getName().compareTo(h2.getName()));
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

### 通过静态方法抽取公共的 Lambda 表达式

可以在Student中定义一个静态方法：

```java
public static int compareByNameThenAge(Student s1, Student s2) {
    if (s1.name.equals(s2.name)) {
        return Integer.compare(s1.age, s2.age);
    } else {
        return s1.name.compareTo(s2.name);
    }
}
```

这个方法需要返回一个`int`类型参数，在 Java8 中，可以在 Lambda 中使用该方法：

```java
@Test
void sortedUsingStaticMethod() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    students.sort(Student::compareByNameThenAge);
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

### 借助`Comparator`的`comparing`方法

在 Java8 中，`Comparator`类新增了`comparing`方法，可以将传递的`Function`参数作为比较元素，比如：

```java
@Test
void sortedUsingComparator() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    students.sort(Comparator.comparing(Student::getName));
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

### 多条件排序

在静态方法一节中展示了多条件排序，还可以在`Comparator`匿名内部类中实现多条件逻辑：

```java
@Test
void sortedMultiCondition() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12),
            new Student("Jerry", 13)
    );
    students.sort((s1, s2) -> {
        if (s1.getName().equals(s2.getName())) {
            return Integer.compare(s1.getAge(), s2.getAge());
        } else {
            return s1.getName().compareTo(s2.getName());
        }
    });
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

从逻辑来看，多条件排序就是先判断第一级条件，如果相等，再判断第二级条件，依次类推。在 Java8 中可以使用`comparing`和一系列`thenComparing`表示多级条件判断，上面的逻辑可以简化为：

```java
@Test
void sortedMultiConditionUsingComparator() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12),
            new Student("Jerry", 13)
    );
    students.sort(Comparator.comparing(Student::getName).thenComparing(Student::getAge));
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

这里的`thenComparing`方法是可以有多个的，用于表示多级条件判断，这也是函数式编程的方便之处。

### 在Stream中进行排序

Java8 中，不但引入了 Lambda 表达式，还引入了一个全新的流式 API：Stream API，其中也有`sorted`方法用于流式计算时排序元素，可以传入`Comparator`实现排序逻辑：

```java
@Test
void streamSorted() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final Comparator<Student> comparator = (h1, h2) -> h1.getName().compareTo(h2.getName());
    final List<Student> sortedStudents = students.stream()
            .sorted(comparator)
            .collect(Collectors.toList());
    Assertions.assertEquals(sortedStudents.get(0), new Student("Jerry", 12));
}
```

同样的，可以通过 Lambda 简化书写：

```java
@Test
void streamSortedUsingComparator() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final Comparator<Student> comparator = Comparator.comparing(Student::getName);
    final List<Student> sortedStudents = students.stream()
            .sorted(comparator)
            .collect(Collectors.toList());
    Assertions.assertEquals(sortedStudents.get(0), new Student("Jerry", 12));
}
```

### 倒序排列

#### 调转排序判断

排序就是根据`compareTo`方法返回的值判断顺序，如果想要倒序排列，只要将返回值取返即可：

```java
@Test
void sortedReverseUsingComparator2() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final Comparator<Student> comparator = (h1, h2) -> h2.getName().compareTo(h1.getName());
    students.sort(comparator);
    Assertions.assertEquals(students.get(0), new Student("Tom", 10));
}
```

可以看到，正序排列的时候，是`h1.getName().compareTo(h2.getName())`，这里直接倒转过来，使用的是`h2.getName().compareTo(h1.getName())`，也就达到了取反的效果。在 Java 的`Collections`中定义了一个`java.util.Collections.ReverseComparator`内部私有类，就是通过这种方式实现元素反转。

**借助**`**Comparator**`**的**`**reversed**`**方法倒序**

在 Java8 中新增了`reversed`方法实现倒序排列，用起来也是很简单：

```java
@Test
void sortedReverseUsingComparator() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final Comparator<Student> comparator = (h1, h2) -> h1.getName().compareTo(h2.getName());
    students.sort(comparator.reversed());
    Assertions.assertEquals(students.get(0), new Student("Tom", 10));
}
```

#### 在`Comparator.comparing`中定义排序反转

`comparing`方法还有一个重载方法，`java.util.Comparator#comparing(java.util.function.Function<? super T,? extends U>, java.util.Comparator<? super U>)`，第二个参数就可以传入`Comparator.reverseOrder()`，可以实现倒序：

```java
@Test
void sortedUsingComparatorReverse() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    students.sort(Comparator.comparing(Student::getName, Comparator.reverseOrder()));
    Assertions.assertEquals(students.get(0), new Student("Jerry", 12));
}
```

#### 在Stream中定义排序反转

在`Stream`中的操作与直接列表排序类似，可以反转`Comparator`定义，也可以使用`Comparator.reverseOrder()`反转。实现如下：

```java
@Test
void streamReverseSorted() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final Comparator<Student> comparator = (h1, h2) -> h2.getName().compareTo(h1.getName());
    final List<Student> sortedStudents = students.stream()
            .sorted(comparator)
            .collect(Collectors.toList());
    Assertions.assertEquals(sortedStudents.get(0), new Student("Tom", 10));
}

@Test
void streamReverseSortedUsingComparator() {
    final List<Student> students = Lists.newArrayList(
            new Student("Tom", 10),
            new Student("Jerry", 12)
    );
    final List<Student> sortedStudents = students.stream()
            .sorted(Comparator.comparing(Student::getName, Comparator.reverseOrder()))
            .collect(Collectors.toList());
    Assertions.assertEquals(sortedStudents.get(0), new Student("Tom", 10));
}
```

### null 值的判断

前面的例子中都是有值元素排序，能够覆盖大部分场景，但有时候还是会碰到元素中存在null的情况：

1. 列表中的元素是 null
2. 列表中的元素参与排序条件的字段是 null

如果还是使用前面的那些实现会碰到`NullPointException`异常，即 NPE，简单演示一下：

```java
@Test
void sortedNullGotNPE() {
    final List<Student> students = Lists.newArrayList(
            null,
            new Student("Snoopy", 12),
            null
    );
    Assertions.assertThrows(NullPointerException.class,
            () -> students.sort(Comparator.comparing(Student::getName)));
}
```

所以，需要考虑这些场景。

#### 元素是 null 的笨拙实现

最先想到的就是判空：

```java
@Test
void sortedNullNoNPE() {
    final List<Student> students = Lists.newArrayList(
            null,
            new Student("Snoopy", 12),
            null
    );
    students.sort((s1, s2) -> {
        if (s1 == null) {
            return s2 == null ? 0 : 1;
        } else if (s2 == null) {
            return -1;
        }
        return s1.getName().compareTo(s2.getName());
    });

    Assertions.assertNotNull(students.get(0));
    Assertions.assertNull(students.get(1));
    Assertions.assertNull(students.get(2));
}
```

可以将判空的逻辑抽取出一个`Comparator`，通过组合方式实现：

```java
class NullComparator<T> implements Comparator<T> {
    private final Comparator<T> real;

    NullComparator(Comparator<? super T> real) {
        this.real = (Comparator<T>) real;
    }

    @Override
    public int compare(T a, T b) {
        if (a == null) {
            return (b == null) ? 0 : 1;
        } else if (b == null) {
            return -1;
        } else {
            return (real == null) ? 0 : real.compare(a, b);
        }
    }
}
```

在 Java8 中已经准备了这个实现。

#### 使用`Comparator.nullsLast`和`Comparator.nullsFirst`

使用`Comparator.nullsLast`实现null在结尾：

```java
@Test
void sortedNullLast() {
    final List<Student> students = Lists.newArrayList(
            null,
            new Student("Snoopy", 12),
            null
    );
    students.sort(Comparator.nullsLast(Comparator.comparing(Student::getName)));
    Assertions.assertNotNull(students.get(0));
    Assertions.assertNull(students.get(1));
    Assertions.assertNull(students.get(2));
}
```

使用`Comparator.nullsFirst`实现`null`在开头：

```java
@Test
void sortedNullFirst() {
    final List<Student> students = Lists.newArrayList(
            null,
            new Student("Snoopy", 12),
            null
    );
    students.sort(Comparator.nullsFirst(Comparator.comparing(Student::getName)));
    Assertions.assertNull(students.get(0));
    Assertions.assertNull(students.get(1));
    Assertions.assertNotNull(students.get(2));
}
```

是不是很简单，接下来看下如何实现排序条件的字段是 null 的逻辑。

#### 排序条件的字段是 null

这个就是借助`Comparator`的组合了，就像是套娃实现了，需要使用两次`Comparator.nullsLast`，这里列出实现：

```java
@Test
void sortedNullFieldLast() {
    final List<Student> students = Lists.newArrayList(
            new Student(null, 10),
            new Student("Snoopy", 12),
            null
    );
    final Comparator<Student> nullsLast = Comparator.nullsLast(
            Comparator.nullsLast( // 1
                    Comparator.comparing(
                            Student::getName,
                            Comparator.nullsLast( // 2
                                    Comparator.naturalOrder() // 3
                            )
                    )
            )
    );
    students.sort(nullsLast);
    Assertions.assertEquals(students.get(0), new Student("Snoopy", 12));
    Assertions.assertEquals(students.get(1), new Student(null, 10));
    Assertions.assertNull(students.get(2));
}
```

代码逻辑如下：

1. 代码 1 是第一层 null-safe 逻辑，用于判断元素是否为 null；
2. 代码 2 是第二层 null-safe 逻辑，用于判断元素的条件字段是否为 null；
3. 代码 3 是条件`Comparator`，这里使用了`Comparator.naturalOrder()`，是因为使用了String排序，也可以写为`String::compareTo`。如果是复杂判断，可以定义一个更加复杂的`Comparator`，组合模式就是这么好用，一层不够再套一层。

## ArrayList

### 构造函数

ArrayList 有三个构造函数，默认不带参数的构造函数就是初始化一个空数组。

```java
//一个空数组
private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};

//实际存储元素的数组
transient Object[] elementData; 

public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

带一个 int 类型的容量参数的构造函数，可以指定 ArrayList 的容量大小。

```java
//空数组
private static final Object[] EMPTY_ELEMENTDATA = {};

public ArrayList(int initialCapacity) {
    if (initialCapacity > 0) {
        //容量大于 0 就构建一个 Object 的数组
        this.elementData = new Object[initialCapacity];
    } else if (initialCapacity == 0) {
        //容量等于 0 就是一个空数组
        this.elementData = EMPTY_ELEMENTDATA;
    } else {
        //容量小于 0 抛出异常
        throw new IllegalArgumentException("Illegal Capacity: "+
                                            initialCapacity);
    }
}
```

带一个集合的构造函数，将集合转换成 `Object[]` 类型后拷贝到 `elementData` 中。

```java
public ArrayList(Collection<? extends E> c) {
    //集合转为数组
    Object[] a = c.toArray();
    if ((size = a.length) != 0) {
        //集合是不是 ArrayList 类型
        if (c.getClass() == ArrayList.class) {
            elementData = a;
        } else {
            //将集合元素拷贝成 Object[] 到 elementData
            elementData = Arrays.copyOf(a, size, Object[].class);
        }
    } else {
        //空元素
        elementData = EMPTY_ELEMENTDATA;
    }
}
```

### 常用函数

#### `add()`

先从 ArrayList 最常用的方法 `add()` 开始讲起，`add()` 方法就是将元素添加到 `elementData` 的末尾。平均时间复杂度为 O(1)。

```java
//ArrayList.add()
public boolean add(E e) {
    //检查数组是否存放的下
    ensureCapacityInternal(size + 1); 
    //添加到末尾
    elementData[size++] = e;
    return true;
}

//ArrayList.ensureCapacityInternal()
private void ensureCapacityInternal(int minCapacity) {
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));
}

//ArrayList.calculateCapacity()
private static int calculateCapacity(Object[] elementData, int minCapacity) {
    //检查时不是默认时的空数组，是默认时的空数组，初始化的容量就是 10
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {
        return Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    return minCapacity;
}

//ArrayList.ensureExplicitCapacity()
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

//最大容量
private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;

//ArrayList.grow()
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    //新长度时原来长度的 1.5 倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    //新长度小于实际容量，就用实际容量
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    //新长度太大了，就用最大的容量
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    //copy 成一个新数组
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

1. 扩容的大小为原长度+1/2的原长度
2. 如果扩容长度比传入的最小容量小，则使用最小容量，如果扩容长度超过设定的最大容量，则实际用最大容量
3. 初始化默认长度为10，当添加到11个长度时，容量为15

#### `add(int index, E element)`

将元素插入到指定的位置，主要的操作是将指定位置之后的元素往后移动一个位置，空出 index 位置。平均时间复杂度为 O(n)。

```java
//ArrayList.add(int index, E element)
public void add(int index, E element) {
    //index的越界检查
    rangeCheckForAdd(index);
    //扩容
    ensureCapacityInternal(size + 1); 
    //将 index 之后的所有元素 copy 到往后挪动一位
    System.arraycopy(elementData, index, elementData, index + 1,
                        size - index);

    //将 index 位置放入新元素
    elementData[index] = element;
    //数量 + 1
    size++;
}
```

#### `get()`

`get()` 应该是第二个常用的函数，可以返回随机位置的元素。需要注意的是越界时，超过容量返回的是 `IndexOutOfBoundsException` 异常，index 太小返回的是 `ArrayIndexOutOfBoundsException` 异常。平均时间复杂度为 O(1)。

```java
//ArrayList.get()
public E get(int index) {
    //index 越界检查
    rangeCheck(index);
    //返回指定位置的元素
    return elementData(index);
}

//ArrayList.rangeCheck()
private void rangeCheck(int index) {
    if (index >= size)
        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
}
//ArrayList.elementData()
E elementData(int index) {
    return (E) elementData[index];
}
```

#### `remove()`

删除指定位置的元素，并返回删除的元素。平均时间复杂度为 O(n)。

```java
//ArrayList.remove()
public E remove(int index) {
    //越界检查
    rangeCheck(index);

    modCount++;
    //取出元素
    E oldValue = elementData(index);
    //拷贝数组，将 index 之后的元素往前移动一个位置
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
    //最后一个元素置 null
    elementData[--size] = null; 

    return oldValue;
}
```

#### `remove(Object o)`

删除指定的元素，需要循环数组删除第一个指定的元素。平均时间复杂度为 O(n)。

```java
//ArrayList.remove(Object o)
public boolean remove(Object o) {
    if (o == null) {
        //循环整个数组，找出第一个需要删除的元素
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        //循环整个数组，找出第一个需要删除的元素
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}

//ArrayList.fastRemove
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                            numMoved);
    elementData[--size] = null; 
}
```

### 总结

![2021-09-04-13-14-17-090662.png](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072245399.png)

1. ArrayList 内部用一个数组存储元素，容量不够时会扩容原来的一半。
2. ArrayList 实现了 `RandomAccess`，支持随机访问。
3. ArrayList 实现了 `Cloneable`，支持被拷贝克隆。
4. ArrayList 删除指定元素和指定位置上的元素的效率不高，需要遍历数组。

## List中remove()方法的陷阱

Java的List在删除元素时，一般会用`list.remove(o)`/`remove(i)`方法。在使用时，容易触碰陷阱，得到意想不到的结果。总结以往经验，记录下来分享一下。

首先初始化List，代码如下：

```java
package com.cicc.am.test;

import java.util.ArrayList;
import java.util.List;

public class ListTest {

    public static void main(String[] args) {
        List<Integer> list=new ArrayList<Integer>();
        list.add(1);
        list.add(2);
        list.add(3);
        list.add(3);
        list.add(4);
        System.out.println(list);
    }
}
```

输出结果为[1, 2, 3, 3, 4]

### 1、普通for循环遍历List删除指定元素--错误！！！

```java
for(int i=0;i<list.size();i++){
   if(list.get(i)==3) list.remove(i);
}
System.out.println(list);
```

输出结果：[1, 2, 3, 4]

为什么元素3只删除了一个？本以为这代码再简单不过，可还是掉入了陷阱里，上面的代码这样写的话，元素3是过滤不完的。只要list中有相邻2个相同的元素，就过滤不完。

List调用`remove(index)`方法后，会移除index位置上的元素，index之后的元素就全部依次左移，即索引依次-1要保证能操作所有的数据，需要把index-1，否则原来索引为index+1的元素就无法遍历到(因为原来索引为index+1的数据，在执行移除操作后，索引变成index了，如果没有index-1的操作，就不会遍历到该元素，而是遍历该元素的下一个元素)。

如果这样，删除元素后同步调整索引或者倒序遍历删除元素，是否可行呢？

### 2、for循环遍历List删除元素时，让索引同步调整--正确！

```java
for(int i=0;i<list.size();i++){
    if(list.get(i)==3) list.remove(i--);
}
System.out.println(list);
```

输出结果：[1, 2, 4]

### 3、倒序遍历List删除元素--正确！

```java
for(int i=list.size()-1;i>=0;i--){
    if(list.get(i)==3){
        list.remove(i);
    }
}
System.out.println(list);
```

输出结果：[1, 2, 4]

### 4、foreach遍历List删除元素--错误！！！

```java
for(Integer i:list){
    if(i==3) list.remove(i);
}
System.out.println(list);
```

抛出异常：`java.util.ConcurrentModificationException`

foreach 写法实际上是对的 `Iterable`、`hasNext`、`next`方法的简写。因此从`List.iterator()`源码着手分析，跟踪`iterator()`方法，该方法返回了 Itr 迭代器对象。

```java
public Iterator<E> iterator() {
    return new Itr();
}
```

Itr 类定义如下：

```java
private class Itr implements Iterator<E> {
    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }
}
```

通过代码可以发现 Itr 是 `ArrayList` 中定义的一个私有内部类，在 `next`、`remove`方法中都会调用`checkForComodification` 方法，该方法的 作用是判断 `modCount != expectedModCount`是否相等，如果不相等则抛出`ConcurrentModificationException`异常。

每次正常执行 remove 方法后，都会对执行`expectedModCount = modCount`赋值，保证两个值相等，那么问题基本上已经清晰了，在 foreach 循环中执行 `list.remove(item);`，对 list 对象的 `modCount` 值进行了修改，而 list 对象的迭代器的 `expectedModCount` 值未进行修改，因此抛出了`ConcurrentModificationException`异常。

### 5、迭代删除List元素--正确！

java中所有的集合对象类型都实现了Iterator接口，遍历时都可以进行迭代：

```java
Iterator<Integer> it=list.iterator();
 while(it.hasNext()){
  if(it.next()==3){
   it.remove();
  }
        }
System.out.println(list);
```

输出结果：[1, 2, 4]

`Iterator.remove()` 方法会在删除当前迭代对象的同时，会保留原来元素的索引。所以用迭代删除元素是最保险的方法，建议大家使用List过程

中需要删除元素时，使用这种方式。学习资料：Java进阶视频资源

### 6、迭代遍历，用`list.remove(i)`方法删除元素--错误！！！

```java
Iterator<Integer> it=list.iterator();
 while(it.hasNext()){
  Integer value=it.next();
   if(value==3){
   list.remove(value);
  }
 }
System.out.println(list);
```

抛出异常：`java.util.ConcurrentModificationException`，原理同上述方法4.

### 7、List删除元素时，注意`Integer`类型和`int`类型的区别.

上述Integer的list，直接删除元素2，代码如下：

```java
list.remove(2);
System.out.println(list);
```

输出结果：[1, 2, 3, 4]

可以看出，List删除元素时传入数字时，默认按索引删除。如果需要删除Integer对象，调用`remove(object)`方法，需要传入Integer类型，代码如下：

```java
list.remove(new Integer(2));
System.out.println(list);
```

输出结果：[1, 3, 3, 4]

### 总结：

1、用for循环遍历List删除元素时，需要注意索引会左移的问题。

2、List删除元素时，为避免陷阱，建议使用迭代器`iterator`的`remove`方式。

3、List删除元素时，默认按索引删除，而不是对象删除。

## 还在自己写迭代器进行remove？快来看看新方法

都知道 List 中是不允许在循环的过程中去进行移除元素的，为什么呢？一般的新人可能会遇到这个问题，比如说会从 List 的遍历的过程中去进行 remove 数据，但是干过几年的开发的有经验的工作人员，是肯定不会这么干的，很简单，会报错。

### List 进行 remove

可以来看一段代码：

```java
public static void main(String[] args) {
    List<String> list= new ArrayList<>();
    list.add("1");
    list.add("2");
    list.add("3");

    for (String s: list) {
        if (s.equals("1")) {
            list.remove(s);
        }
    }

    System.out.println(list);
}
```

上面这段代码，一般都是初入开发行业的小伙伴可能会这么写，但是当运行的时候，就会发现会报一个错误。

```plain
Exception in thread "main" java.util.ConcurrentModificationException
 at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:909)
 at java.util.ArrayList$Itr.next(ArrayList.java:859)
 at com.example.fastdfs.Test.main(Test.java:22)
```

但是把代码改成删除元素 2 的时候，发现又成功了！！！

是真的成功了，看代码和运行结果：

```java
public static void main(String[] args) {
    List<String> list= new ArrayList<>();
    list.add("1");
    list.add("2");
    list.add("3");

    for (String s: list) {
        if (s.equals("2")) {
            list.remove(s);
        }
    }

    System.out.println(list);
}
```

运行结果如下：

![img](assets/1669595432079-d3badeba-fea1-4dbf-a3c3-0169f6d0df42.png)

为什么会出现这种情况，删除第一个元素不行，删除第二个元素好用，删除第三个元素又不行了，到底是什么原因导致的呢？

这时候就得去看看他的源码编译出来是什么样子的。源码如下：

```java
public static void main(String[] args) {
    List<String> list = new ArrayList();
    list.add("1");
    list.add("2");
    list.add("3");
    Iterator var2 = list.iterator();

    while(var2.hasNext()) {
        String s = (String)var2.next();
        if (s.equals("3")) {
            list.remove(s);
        }
    }

    System.out.println(list);
}
```

也就是说，foreach 的循环内部，就是采用的`iteratior`形式，使用的核心方法是`hasnext()`和`next()`。

既然都使用迭代器了，为啥还是不行呢？来看看迭代器的源码，然后分析一下为啥不行。

其实可以从报错都能看出点端倪，报错信息是ArrayList.java:909  而这个方法内部则是这样的：

```java
final void checkForComodification() {
    if (modCount != expectedModCount)
        throw new ConcurrentModificationException();
}
```

源代码在执行 remove 方法的时候后，也是调用的 list 当中的`remove` 方法，源代码中，就是这段：

```java
public boolean remove(Object o) {
    if (o == null) {
    for (int index = 0; index < size; index++)
        if (elementData[index] == null) {
            fastRemove(index);
            return true;
        }
    } else {
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    return false;
}
```

中间调用的 `fastRemove` 方法中，中间就看到了：

```java
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}
```

这里`modCount++`了

而当再一次循环的时候，调用的是list内部类itr的`next`方法，

在调用的list的`remove`的时候，`modCount++`了，而`expectedModCount`是等于最开始`modCount`值。

这时候二者的值不相等的时候，就出现异常了。

归根结底，虽然这个地方使用的是迭代器的遍历，但是remove 的方法可不是迭代器的方法呀。

那么使用迭代器遍历然后移除是什么样子的呢？

```java
public static void main(String[] args) {
    List<String> list= new ArrayList<>();
    list.add("1");
    list.add("2");
    list.add("3");

    Iterator<String> iterator = list.iterator();
    while (iterator.hasNext()){
        String next = iterator.next();
        if ("3".equals(next)){
            iterator.remove();
        }
    }

    System.out.println(list);
}
```

这么写是不是有点多，那么应该如何快速的写完这段代码呢？

其实一行代码就能很快解决这个事情，先来看代码怎么写的：

```java
list.removeIf(vo-> "3".equals(vo));
```

也不用管返回值了，只要是能满足这个条件的 ，那么就会从集合中给移除掉。

看结果：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072248561.png)

这么一看，是不是发现非常简单方便，而且还快捷，而且如果要是对于代码量来说的话，那肯定是非常的少的，但凡满足条件的，肯定可以。

### removeIf 的进阶玩法

为什么称之为进阶玩法，实际上也并不是完整的进阶玩法，比如说如果有一个功能是这样的，要求做一个导入的功能，然后导入的数据只有一个车牌号是唯一值，之前导入的数据，不做处理，新增的文件中，可能会包含所有的数据，要求数据库中已经存在的数据，不处理，然后导入数据库中不存在的数据。

如果字段少的话，那么实现思路可能会有几种。

第一种：

mybatis 的 SelectKey 标签，判断是否存在，如果存在就不进行新增。

第二种：

导入之前，查询数据库数据，比对数据，然后直接进行remove，最后不存在的数据导入

这两种方法实际上都能实现，但是他们的适用情况就不太一样了，如果字段非常多呢？

自己写sql 的话，那么代价实在是有点大，如果使用的还是 Mybatis-plus 的话，那么肯定第一种方式好像就没办法使用了，只能使用第二种了。

那么 removeIf 应该怎么来写呢？

```java
//创建第一个UserList
List<User> userList = new ArrayList<>();
User user = new User();
user.setId(UUID.randomUUID().toString());
user.setName("张三");
user.setAge(20);
user.setDept("开发部");
userList.add(user);

User user1 = new User();
user1.setId(UUID.randomUUID().toString());
user1.setName("李四");
user1.setAge(22);
user1.setDept("测试部");
userList.add(user1);

User user2 = new User();
user2.setId(UUID.randomUUID().toString());
user2.setName("王五");
user2.setAge(27);
user2.setDept("财务部");
userList.add(user2);

//创建第二个UserList

List<User> userEnd= new ArrayList<>();
User user3= new User();
user3.setId(UUID.randomUUID().toString());
user3.setName("张三");
user3.setAge(20);
user3.setDept("开发部");
userEnd.add(user3);

User user4= new User();
user4.setId(UUID.randomUUID().toString());
user4.setName("李四");
user4.setAge(22);
user4.setDept("测试部");
userEnd.add(user4);
```

如果这时候要把第一个userList 中的数据导入数据库，而 userEnd 则是数据库中的数据，这时候，要根据姓名来区分的话，是不是应该之导入王五才对，这时候得筛选出王五的数据来，然后做导入，这个时候 removeIf 就派上用场了。

```java
userList.removeIf(us1-> userEnd.stream().anyMatch(u ->us1.getName().equals(u.getName())));

System.out.println(Arrays.toString(userList.toArray()));
```

最后来看看结果：

```text
[User(id=029b0b0f-ad42-4c15-8341-a3bb401be6d6, name=王五, age=27, dept=财务部)]
```

是不是已经做到了呢？

## List的10个坑

### 前言

主要来说一说List操作在实际使用中有哪些坑，以及面对这些坑的时候要怎么解决。

### `Arrays.asList`转换基本类型数组的坑

在实际的业务开发中，通常会进行数组转List的操作，通常会使用`Arrays.asList`来进行转换

但是在转换基本类型的数组的时候，却出现转换的结果和想象的不一致。

上代码

```java
int[] arr = {1, 2, 3}; 
List list = Arrays.asList(arr); 
System.out.println(list.size()); 
// 1
```

实际上，想要转成的List应该是有三个对象而现在只有一个

```java
public static List asList(T... a) { 
    return new ArrayList<>(a); 
}
```

可以观察到 `asList`方法 接收的是一个泛型T类型的参数，T继承Object对象

所以通过断点可以看到把 int数组 整体作为一个对象,返回了一个 `List<int[]>`

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072249265.jpeg)

**「那该如何解决呢？」**

方案一：Java8以上，利用`Arrays.stream(arr).boxed()`将装箱为`Integer`数组

```java
List collect = Arrays.stream(arr).boxed().collect(Collectors.toList()); System.out.println(collect.size()); 
System.out.println(collect.get(0).getClass()); 
// 3 
// class java.lang.Integer
```

方案二：声明数组的时候，声明类型改为包装类型

```java
Integer[] integerArr = {1, 2, 3}; 
List integerList = Arrays.asList(integerArr); 
System.out.println(integerList.size()); System.out.println(integerList.get(0).getClass()); 
// 3 
// class java.lang.Integer
```

### `Arrays.asList`返回的List不支持增删操作

将数组对象转成List数据结构之后，竟然不能进行增删操作了

```java
private static void asListAdd(){
    String[] arr = {"1", "2", "3"};
    List<String> strings = new ArrayList<>(Arrays.asList(arr));
    arr[2] = "4";
    System.out.println(strings.toString());
    Iterator<String> iterator = strings.iterator();
    while (iterator.hasNext()){
        if ("4".equals(iterator.next())){
            iterator.remove();
        }
    }
    strings.forEach(val ->{
        strings.remove("4");
        strings.add("3");
    });


    System.out.println(Arrays.asList(arr).toString());
}
[1, 2, 4] 
Exception in thread "main" java.lang.UnsupportedOperationException at java.util.AbstractList.remove(AbstractList.java:161) at java.util.AbstractList$Itr.remove(AbstractList.java:374) at java.util.AbstractCollection.remove(AbstractCollection.java:293) at JavaBase.List.AsListTest.lambda$asListAdd$0(AsListTest.java:47) at java.util.Arrays$ArrayList.forEach(Arrays.java:3880) at JavaBase.List.AsListTest.asListAdd(AsListTest.java:46) at JavaBase.List.AsListTest.main(AsListTest.java:20)
```

初始化一个字符串数组，将字符串数组转换为 List，在遍历List的时候进行移除和新增的操作

抛出异常信息UnsupportedOperationException。

根据异常信息java.lang.UnsupportedOperationException，可以看到他是从`AbstractList`里面出来的，进入源码一看究竟

在什么时候调用到了这个 `AbstractList` 呢？

其实 `Arrays.asList(arr)` 返回的 `ArrayList` 不是 `java.util.ArrayList`，而是 Arrays的内部类

```java
private static class ArrayList<E> extends AbstractList<E>
        implements RandomAccess, java.io.Serializable{
    private static final long serialVersionUID = -2764017481108945198L;
    private final E[] a;
    ArrayList(E[] array) {
        a = Objects.requireNonNull(array);
    }

    @Override
    public E get(int index) {}

    @Override
    public E set(int index, E element) {...}

...
}
public abstract class AbstractList<E> extends AbstractCollection<E> implements List<E> {
    public boolean add(E e) {
        add(size(), e);
        return true;
    }
    public void add(int index, E element) {
        throw new UnsupportedOperationException();
    }

    public E remove(int index) {
        throw new UnsupportedOperationException();
    }

}
```

他是没有实现 AbstractList 中的 `add()` 和 `remove()` 方法,这里就很清晰了为什么不支持新增和删除，因为根本没有实现。

### 对原始数组的修改会影响到获得的那个List

一不小心修改了父List，却影响到了子List，在业务代码中，这会导致产生的数据发生变化，严重的话会造成影响较大的生产问题。

第二个坑的源码中，完成字符串数组转换为List之后，

将字符串数组的第三个对象的值修改为4，但是很奇怪在打印List的时候，发现List也发生了变化。

```java
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}

ArrayList(E[] array) {
    a = Objects.requireNonNull(array);
}
```

`asList`中创建了 `ArrayList`，但是他直接引用了原本的数组对象

所以只要原本的数组对象一发生变化，List也跟着变化

所以在使用到引用的时候，需要特别的注意。

解决方案：重新new一个新的 `ArrayList` 来装返回的 List

```java
List strings = new ArrayList<>(Arrays.asList(arr));
```

### `java.util.ArrayList`如果不正确操作也不支持增删操作

在第二个坑的时候，说到了 `Arrays.asList` 返回的 List 不支持增删操作，

是因为他的自己实现了一个内部类 `ArrayList`，这个内部类继承了 `AbstractList` 没有实现 `add()` 和 `remove()` 方法导致操作失败。

但是第三个坑的时候，利用 java.util.ArrayList 包装了返回的 List，进行增删操作还是会失败，那是为什么呢？

删除方法逻辑：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072249611.jpeg)

在foreach中操作增删，因为因为 `modCount` 会被修改，与第一步保存的数组修改次数不一致，抛出异常 `ConcurrentModificationException`

在正确操作是什么？总结了四种方式

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072249346.jpeg)

正确操作

### ArrayList中的 `subList` 强转 `ArrayList` 导致异常

阿里《Java开发手册》上提过

[强制] ArrayList的`sublist`结果不可強转成ArrayList,否则会抛出ClassCastException

异常，即java.util.RandomAccesSubList cannot be cast to java. util.ArrayList.

说明: subList 返回的是`ArrayList `的内部类`SubList`，并不是`ArrayList`，而是

`ArrayList`的一个视图，対于`SubList`子列表的所有操作最终会反映到原列表上。

```java
private static void subListTest(){

    List<String> names = new ArrayList<String>() {{

    add("one");

    add("two");

    add("three");

}};
    ArrayList strings = (ArrayList) names.subList(0, 1);
    System.out.println(strings.toString());
}
Exception in thread "main" java.lang.ClassCastException: java.util.ArrayList$SubList cannot be cast to java.util.ArrayList
```

猜一下问题是有八九就是出现在subList这个方法上了

```java
private class SubList extends AbstractList<E> implements RandomAccess {

    private final AbstractList<E> parent;
    private final int parentOffset;
    private final int offset;
    int size;
    SubList(AbstractList<E> parent,

    int offset, int fromIndex, int toIndex) {
        this.parent = parent;
        this.parentOffset = fromIndex;
        this.offset = offset + fromIndex;
        this.size = toIndex - fromIndex;
        this.modCount = ArrayList.this.modCount;
    }
}
```

其实 SubList 是一个继承 AbstractList 的内部类，在 SubList 的构建函数中的将 List 中的部分属性直接赋予给自己

SubList 没有创建一个新的 List，而是直接引用了原来的 `List(this.parent = parent)`，指定了元素的范围

所以 subList 方法不能直接转成 `ArrayList`，他只是`ArrayList`的内部类，没有其他的关系

因为是引用的关系，所以在这里也需要特别的注意，如果对原来的List进行修改，会对产生的 subList结果产生影响。

```java
List<String> names = new ArrayList<String>() {{
    add("one");
    add("two");
    add("three");
}};

List strings = names.subList(0, 1);

strings.add(0, "ongChange");

System.out.println(strings.toString());

System.out.println(names.toString());
[ongChange, one]

[ongChange, one, two, three]
```

对`subList`产生的List做出结构型修改，操作会反应到原来的List上，`ongChange`也添加到了names中

如果修改原来的List则会抛出异常`ConcurrentModificationException`

```java
List<String> names = new ArrayList<String>() {{

    add("one");
    add("two");
    add("three");

}};

List strings = names.subList(0, 1);

names.add("four");

System.out.println(strings.toString());

System.out.println(names.toString());
Exception in thread "main" java.util.ConcurrentModificationException
```

原因：subList的时候记录`this.modCount`为3

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072249222.jpeg)

原来的List插入了一个新元素，导致`this.modCount`不第一次保存的不一致则抛出异常

解决方案：在操作`SubList`的时候，new一个新的`ArrayList`来接收创建`subList`结果的拷贝

```java
List strings = new ArrayList(names.subList(0, 1));
```

### ArrayList中的`subList`切片造成OOM

在业务开发中的时候，他们经常通过subList来获取所需要的那部分数据

在上面的例子中，知道了`subList`所产生的List，其实是对原来List对象的引用

这个产生的List只是原来List对象的视图，也就是说虽然值切片获取了一小段数据，但是原来的List对象却得不到回收，这个原来的List对象可能是一个很大的对象

为了方便测试，将vm调整一下 `-Xms20m -Xmx40m`

```java
private static void subListOomTest(){

    IntStream.range(0, 1000).forEach(i ->{
        List<Integer> collect = IntStream.range(0, 100000).boxed().collect(Collectors.toList());
            data.add(collect.subList(0, 1));

        });

    }
}
Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
```

出现OOM的原因，循环1000次创建了1000个具有10万个元素的List

因为始终被`collect.subList(0, 1)`强引用，得不到回收

解决方式：

1. 在`subList`方法返回SubList，重新使用`new ArrayList`，来构建一个独立的`ArrayList`

```java
List list = new ArrayList<>(collect.subList(0, 1));
```

1. 利用Java8的Stream中的`skip`和`limit`来达到切片的目的

```java
List list = collect.stream().skip(0).limit(1).collect(Collectors.toList());
```

在这里可以看到，只要用一个新的容器来装结果，就可以切断与原始List的关系

### `LinkedList`的插入速度不一定比`ArrayList`快

学习数据结构的时候，就已经得出了结论

- 对于数组，随机元素访问的时间复杂度是0(1)， 元素插入操作是O(n);
- 对于链表，随机元素访问的时间复杂度是O(n), 元素插入操作是0(1).

元素插入对于链表来说应该是他的优势

但是他就一定比数组快? 执行插入1000w次的操作

```java
private static void test(){
    StopWatch stopWatch = new StopWatch();
    int elementCount = 100000;
    stopWatch.start("ArrayList add");
    List<Integer> arrayList = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(ArrayList::new));
    // ArrayList插入数据
    IntStream.rangeClosed(0, elementCount).forEach(i ->arrayList.add(ThreadLocalRandom.current().nextInt(elementCount), 1));
    stopWatch.stop();

    stopWatch.start("linkedList add");
    List<Integer> linkedList = IntStream.rangeClosed(1, elementCount).boxed().collect(Collectors.toCollection(LinkedList::new));
    // ArrayList插入数据
    IntStream.rangeClosed(0, elementCount).forEach(i -> linkedList.add(ThreadLocalRandom.current().nextInt(elementCount), 1));
    stopWatch.stop();
    System.out.println(stopWatch.prettyPrint());
}
StopWatch '': running time = 44507882 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
043836412  098%  elementCount 100 ArrayList add
000671470  002%  elementCount 100 linkedList add

StopWatch '': running time = 196325261 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
053848980  027%  elementCount 10000 ArrayList add
142476281  073%  elementCount 10000 linkedList add

StopWatch '': running time = 26384216979 ns
---------------------------------------------
ns         %     Task name
---------------------------------------------
978501580  004%  elementCount 100000 ArrayList add
25405715399  096%  elementCount 100000 linkedList add
```

看到在执行插入1万、10完次操作的时候，`LinkedList`的插入操作时间是 `ArrayList`的两倍以上

那问题主要就是出现在linkedList的 `add()`方法上

```java
public void add(int index, E element) {

    checkPositionIndex(index);

    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}
    
/**
* Returns the (non-null) Node at the specified element index.
    */
Node<E> node(int index) {

    // assert isElementIndex(index);

    if(index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

linkedList的 `add()`方法主要逻辑

1. 通过遍历找到那个节点的Node
2. 执行插入操作

`ArrayList`的 `add()`方法

```java
public void add(int index, E element) {
    rangeCheckForAdd(index);

    ensureCapacityInternal(size + 1);  // Increments modCount!!
    System.arraycopy(elementData, index, elementData, index + 1,
                     size - index);
    elementData[index] = element;
    size++;
}
```

1. 计算最小容量
2. 最小容量大于数组对象，则进行扩容
3. 进行数组复制,根据插入的index将数组向后移动一位
4. 最后在空位上插入新值

根据试验的测试，得出了在实际的随机插入中，`LinkedList`并没有比ArrayList的速度快

所以在实际的使用中，如果涉及到头尾对象的操作，可以使用LinkedList数据结构来进行增删的操作，发挥`LinkedList`的优势

最好再进行实际的性能测试评估，来得到最合适的数据结构。

### `CopyOnWriteArrayList`内存占用过多

`CopyOnWrite`，顾名思义就是写的时候会将共享变量新复制一份出来，这样做的好处是读操作完全无锁。

`CopyOnWriteArrayList`的`add()`方法

```java
public boolean add(E e) {
    // 获取独占锁
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        // 获取array
        Object[] elements = getArray();
        // 复制array到新数组，添加元素到新数组
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        // 替换数组
        setArray(newElements);
        return true;
    } finally {
        // 释放锁
        lock.unlock();
    }
}
```

`CopyOnWriteArrayList` 内部维护了一个数组，成员变量 array 就指向这个内部数组，所有的读操作都是基于新的array对象进行的。

因为上了独占锁，所以如果多个线程调用add()方法只有一个线程会获得到该锁，其他线程被阻塞，知道锁被释放， 由于加了锁，所以整个操作的过程是原子性操作

`CopyOnWriteArrayList` 会将 新的array复制一份，然后在新复制处理的数组上执行增加元素的操作，执行完之后再将复制的结果指向这个新的数组。

由于每次写入的时候都会对数组对象进行复制，复制过程不仅会占用双倍内存，还需要消耗 CPU 等资源，所以当列表中的元素比较少的时候，这对内存和 GC 并没有多大影响，但是当列表保存了大量元素的时候，

对 `CopyOnWriteArrayList` 每一次修改，都会重新创建一个大对象，并且原来的大对象也需要回收，这都可能会触发 GC，如果超过老年代的大小则容易触发Full GC，引起应用程序长时间停顿。

### `CopyOnWriteArrayList`是弱一致性的

```java
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}

static final class COWIterator<E> implements ListIterator<E> {
    /** Snapshot of the array */
    private final Object[] snapshot;
    /** Index of element to be returned by subsequent call to next.  */
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor < snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor > 0;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];
    }
```

调用`iterator`方法获取迭代器返回一个`COWIterator`对象

`COWIterator`的构造器里主要是 保存了当前的list对象的内容和遍历list时数据的下标。

snapshot是list的快照信息，因为`CopyOnWriteArrayList`的读写策略中都会使用`getArray()`来获取一个快照信息，生成一个新的数组。

所以在使用该迭代器元素时，其他线程对该lsit操作是不可见的，因为操作的是两个不同的数组所以造成弱一致性。

```java
private static void CopyOnWriteArrayListTest(){
    CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList();
    list.add("test1");
    list.add("test2");
    list.add("test3");
    list.add("test4");
    
    Thread thread = new Thread(() -> {
        System.out.println(">>>> start");
        list.add(1, "replaceTest");
        list.remove(2);
    });
    
    // 在启动线程前获取迭代器
    Iterator<String> iterator = list.iterator();

    thread.start();

    try {
        // 等待线程执行完毕
        thread.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }

    while (iterator.hasNext()){
        System.out.println(iterator.next());
    }
}
>>>> start
test1
test2
test3
test4
```

上面的demo中在启动线程前获取到了原来list的迭代器，

在之后启动新建一个线程，在线程里面修改了第一个元素的值，移除了第二个元素

在执行完子线程之后，遍历了迭代器的元素，发现子线程里面操作的一个都没有生效，这里提现了迭代器弱一致性。

### `CopyOnWriteArrayList`的迭代器不支持增删改

```java
private static void CopyOnWriteArrayListTest(){
    CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
    list.add("test1");
    list.add("test2");
    list.add("test3");
    list.add("test4");

    Iterator<String> iterator = list.iterator();

    while (iterator.hasNext()){
        if ("test1".equals(iterator.next())){
            iterator.remove();
        }
    }

    System.out.println(list.toString());
}
Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.concurrent.CopyOnWriteArrayList$COWIterator.remove(CopyOnWriteArrayList.java:1178)
```

`CopyOnWriteArrayList `迭代器是只读的，不支持增删操作

`CopyOnWriteArrayList`迭代器中的 `remove()`和 `add()`方法，没有支持增删而是直接抛出了异常

因为迭代器遍历的仅仅是一个快照，而对快照进行增删改是没有意义的。

```java
/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code remove}
 *         is not supported by this iterator.
 */
public void remove() {
    throw new UnsupportedOperationException();
}

/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code set}
 *         is not supported by this iterator.
 */
public void set(E e) {
    throw new UnsupportedOperationException();
}

/**
 * Not supported. Always throws UnsupportedOperationException.
 * @throws UnsupportedOperationException always; {@code add}
 *         is not supported by this iterator.
 */
public void add(E e) {
    throw new UnsupportedOperationException();
}
```

### 总结

由于篇幅的限制，只对一些在业务开发中常见的关键点进行梳理和介绍

在实际的工作中，不单单是要清除不同类型容器的特性，还要选择适合的容器才能做到事半功倍。

主要介绍了`Arrays.asList`转换过程中的一些坑，以及因为操作不当造成的OOM和异常，

到最后介绍了线程安全类`CopyOnWriteArrayList`的一些坑，让我们认识到在丰富的API下藏着许多的陷阱。

在使用的过程中，需要更加充分的考虑避免这些隐患的发生。

最后一张思维导图来回顾一下~

![DM_20220919102257_006.JPG](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072248918.jpeg)
