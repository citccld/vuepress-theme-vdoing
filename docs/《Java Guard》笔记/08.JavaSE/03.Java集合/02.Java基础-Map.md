### Map集合遍历的方式

随着 JDK 1.8 Streams API 的发布，使得 HashMap 拥有了更多的遍历的方式：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072252542.webp)

### HashMap 遍历

HashMap **遍历从大的方向来说，可分为以下 4 类**：

1. 迭代器（Iterator）方式遍历；
2. For Each 方式遍历；
3. Lambda 表达式遍历（JDK 1.8+）;
4. Streams API 遍历（JDK 1.8+）。

但每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：

1. 使用迭代器（Iterator）EntrySet 的方式进行遍历；
2. 使用迭代器（Iterator）KeySet 的方式进行遍历；
3. 使用 For Each EntrySet 的方式进行遍历；
4. 使用 For Each KeySet 的方式进行遍历；
5. 使用 Lambda 表达式的方式进行遍历；
6. 使用 Streams API 单线程的方式进行遍历；
7. 使用 Streams API 多线程的方式进行遍历。

#### 1、迭代器 EntrySet

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> entry = iterator.next();
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 2、迭代器 KeySet

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        Iterator<Integer> iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            Integer key = iterator.next();
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 3、ForEach EntrySet

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 4、ForEach KeySet

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        for (Integer key : map.keySet()) {
            System.out.println(key);
            System.out.println(map.get(key));
        }
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 5、Lambda

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        map.forEach((key, value) -> {
            System.out.println(key);
            System.out.println(value);
        });
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 6、Streams API 单线程

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Java8");
        // 遍历
        map.entrySet().stream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
    }
}
```

以上程序的执行结果为：

> 1
>
> Java
>
> 2
>
> JDK
>
> 3
>
> Spring Framework
>
> 4
>
> MyBatis framework
>
> 5
>
> Java8

#### 7、Streams API 多线程

```java
public class HashMapTest {
    public static void main(String[] args) {
        // 创建并赋值 HashMap
        Map<Integer, String> map = new HashMap();
        map.put(1, "Java");
        map.put(2, "JDK");
        map.put(3, "Spring Framework");
        map.put(4, "MyBatis framework");
        map.put(5, "Jav8");
        // 遍历
        map.entrySet().parallelStream().forEach((entry) -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
        });
    }
}
```

以上程序的执行结果为：

> 4
>
> MyBatis framework
>
> 5
>
> Java
>
> 1
>
> Java8
>
> 2
>
> JDK
>
> 3
>
> Spring Framework

### 性能测试

使用 Oracle 官方提供的性能测试工具 JMH（Java Microbenchmark Harness，JAVA 微基准测试套件）来测试一下这 7 种循环的性能。

首先要引入 JMH 框架，在 `pom.xml` 文件中添加如下配置：

```xml
<!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-core -->
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-core</artifactId>
    <version>1.23</version>
</dependency>
<!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess -->
<dependency>
    <groupId>org.openjdk.jmh</groupId>
    <artifactId>jmh-generator-annprocess</artifactId>
    <version>1.23</version>
    <scope>provided</scope>
</dependency>
```

然后编写测试代码，如下所示：

```java
@BenchmarkMode(Mode.AverageTime) // 测试完成时间
@OutputTimeUnit(TimeUnit.NANOSECONDS)
@Warmup(iterations = 2, time = 1, timeUnit = TimeUnit.SECONDS) // 预热 2 轮，每次 1s
@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS) // 测试 5 轮，每次 1s
@Fork(1) // fork 1 个线程
@State(Scope.Thread) // 每个测试线程一个实例
public class HashMapCycleTest {
    static Map<Integer, String> map = new HashMap() {{
        // 添加数据
        for (int i = 0; i < 100; i++) {
            put(i, "val:" + i);
        }
    }};
    public static void main(String[] args) throws RunnerException {
        // 启动基准测试
        Options opt = new OptionsBuilder()
                .include(HashMapCycle.class.getSimpleName()) // 要导入的测试类
                .output("/Users/admin/Desktop/jmh-map.log") // 输出测试结果的文件
                .build();
        new Runner(opt).run(); // 执行测试
    }
    @Benchmark
    public void entrySet() {
        // 遍历
        Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, String> entry = iterator.next();
            Integer k = entry.getKey();
            String v = entry.getValue();
        }
    }
    @Benchmark
    public void forEachEntrySet() {
        // 遍历
        for (Map.Entry<Integer, String> entry : map.entrySet()) {
            Integer k = entry.getKey();
            String v = entry.getValue();
        }
    }
    @Benchmark
    public void keySet() {
        // 遍历
        Iterator<Integer> iterator = map.keySet().iterator();
        while (iterator.hasNext()) {
            Integer k = iterator.next();
            String v = map.get(k);
        }
    }
    @Benchmark
    public void forEachKeySet() {
        // 遍历
        for (Integer key : map.keySet()) {
            Integer k = key;
            String v = map.get(k);
        }
    }
    @Benchmark
    public void lambda() {
        // 遍历
        map.forEach((key, value) -> {
            Integer k = key;
            String v = value;
        });
    }
    @Benchmark
    public void streamApi() {
        // 单线程遍历
        map.entrySet().stream().forEach((entry) -> {
            Integer k = entry.getKey();
            String v = entry.getValue();
        });
    }
    public void parallelStreamApi() {
        // 多线程遍历
        map.entrySet().parallelStream().forEach((entry) -> {
            Integer k = entry.getKey();
            String v = entry.getValue();
        });
    }
}
```

所有被添加了 `@Benchmark` 注解的方法都会被测试，因为 parallelStream 为多线程版本性能一定是最好的，所以就不参与测试了，其他 6 个方法的测试结果如下：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072253375.webp)

其中 Units 为 ns/op 意思是执行完成时间（单位为纳秒），而 Score 列为平均执行时间， `±` 符号表示误差。从以上结果可以看出，两个 `entrySet` 的性能相近，并且执行速度最快，接下来是 `stream` ，然后是两个 `keySet`，性能最差的是 `KeySet` 。

注：以上结果基于测试环境：JDK 1.8 / Mac mini (2018) / Idea 2020.1

#### 结论

**从以上结果可以看出** `**entrySet**` **的性能比** `**keySet**` **的性能高出了一倍之多，因此应该尽量使用** `**entrySet**`  **来实现 Map 集合的遍历**。

### 字节码分析

要理解以上的测试结果，需要把所有遍历代码通过 `javac` 编译成字节码来看具体的原因。

编译后，使用 Idea 打开字节码，内容如下：

```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//
package com.example;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
public class HashMapTest {
    static Map<Integer, String> map = new HashMap() {
        {
            for(int var1 = 0; var1 < 2; ++var1) {
                this.put(var1, "val:" + var1);
            }
        }
    };
    public HashMapTest() {
    }
    public static void main(String[] var0) {
        entrySet();
        keySet();
        forEachEntrySet();
        forEachKeySet();
        lambda();
        streamApi();
        parallelStreamApi();
    }
    public static void entrySet() {
        Iterator var0 = map.entrySet().iterator();
        while(var0.hasNext()) {
            Entry var1 = (Entry)var0.next();
            System.out.println(var1.getKey());
            System.out.println((String)var1.getValue());
        }
    }
    public static void keySet() {
        Iterator var0 = map.keySet().iterator();
        while(var0.hasNext()) {
            Integer var1 = (Integer)var0.next();
            System.out.println(var1);
            System.out.println((String)map.get(var1));
        }
    }
    public static void forEachEntrySet() {
        Iterator var0 = map.entrySet().iterator();
        while(var0.hasNext()) {
            Entry var1 = (Entry)var0.next();
            System.out.println(var1.getKey());
            System.out.println((String)var1.getValue());
        }
    }
    public static void forEachKeySet() {
        Iterator var0 = map.keySet().iterator();
        while(var0.hasNext()) {
            Integer var1 = (Integer)var0.next();
            System.out.println(var1);
            System.out.println((String)map.get(var1));
        }
    }
    public static void lambda() {
        map.forEach((var0, var1) -> {
            System.out.println(var0);
            System.out.println(var1);
        });
    }
    public static void streamApi() {
        map.entrySet().stream().forEach((var0) -> {
            System.out.println(var0.getKey());
            System.out.println((String)var0.getValue());
        });
    }
    public static void parallelStreamApi() {
        map.entrySet().parallelStream().forEach((var0) -> {
            System.out.println(var0.getKey());
            System.out.println((String)var0.getValue());
        });
    }
}
```

从结果可以看出，除了 Lambda 和 Streams API 之外，通过迭代器循环和 `for` 循环的遍历的 `EntrySet` 最终生成的代码是一样的，他们都是在循环中创建了一个遍历对象 `Entry` ，代码如下：

```java
public static void entrySet() {
    Iterator var0 = map.entrySet().iterator();
    while(var0.hasNext()) {
        Entry var1 = (Entry)var0.next();
        System.out.println(var1.getKey());
        System.out.println((String)var1.getValue());
    }
}
public static void forEachEntrySet() {
    Iterator var0 = map.entrySet().iterator();
    while(var0.hasNext()) {
        Entry var1 = (Entry)var0.next();
        System.out.println(var1.getKey());
        System.out.println((String)var1.getValue());
    }
}
```

而 `KeySet` 的代码也是类似的，如下所示：

```java
public static void keySet() {
    Iterator var0 = map.keySet().iterator();
    while(var0.hasNext()) {
        Integer var1 = (Integer)var0.next();
        System.out.println(var1);
        System.out.println((String)map.get(var1));
    }
} 
public static void forEachKeySet() {
    Iterator var0 = map.keySet().iterator();
    while(var0.hasNext()) {
        Integer var1 = (Integer)var0.next();
        System.out.println(var1);
        System.out.println((String)map.get(var1));
    }
}
```

所以在使用迭代器或是 `for` 循环 `EntrySet` 时，他们的性能都是相同的，因为他们最终生成的字节码基本都是一样的；同理 `KeySet` 的两种遍历方式也是类似的。

### 性能分析

`EntrySet` 之所以比 `KeySet` 的性能高是因为，`KeySet` 在循环时使用了 `map.get(key)`，而 `map.get(key)` 相当于又遍历了一遍 Map 集合去查询 `key` 所对应的值。为什么要用“又”这个词？因为**在使用迭代器或者 for 循环时，其实已经遍历了一遍 Map 集合了，因此再使用** `**map.get(key)**` **查询时，相当于遍历了两遍**。

而 `EntrySet` 只遍历了一遍 Map 集合，之后通过代码“`Entry<Integer, String> entry = iterator.next()`”把对象的 `key` 和 `value` 值都放入到了 `Entry` 对象中，因此再获取 `key` 和 `value` 值时就无需再遍历 Map 集合，只需要从 `Entry` 对象中取值就可以了。

所以，`**EntrySet**` **的性能比** `**KeySet**` **的性能高出了一倍，因为** `**KeySet**` **相当于循环了两遍 Map 集合，而** `**EntrySet**` **只循环了一遍**。

### 安全性测试

接下来从「安全」的角度入手，来分析那种遍历方式更安全。

把以上遍历划分为四类进行测试：迭代器方式、For 循环方式、Lambda 方式和 Stream 方式，测试代码如下。

#### 1、迭代器方式

```java
Iterator<Map.Entry<Integer, String>> iterator = map.entrySet().iterator();
while (iterator.hasNext()) {
    Map.Entry<Integer, String> entry = iterator.next();
    if (entry.getKey() == 1) {
        // 删除
        System.out.println("del:" + entry.getKey());
        iterator.remove();
    } else {
        System.out.println("show:" + entry.getKey());
    }
}
```

以上程序的执行结果：

> show:0
>
> del:1
>
> show:2

测试结果：**迭代器中循环删除数据安全**。

#### 2、For 循环方式

```java
for (Map.Entry<Integer, String> entry : map.entrySet()) {
    if (entry.getKey() == 1) {
        // 删除
        System.out.println("del:" + entry.getKey());
        map.remove(entry.getKey());
    } else {
        System.out.println("show:" + entry.getKey());
    }
}
```

以上程序的执行结果：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072254214.webp)

测试结果：**For 循环中删除数据非安全**。

#### 3、Lambda 方式

```java
map.forEach((key, value) -> {
    if (key == 1) {
        System.out.println("del:" + key);
        map.remove(key);
    } else {
        System.out.println("show:" + key);
    }
});
```

以上程序的执行结果：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072254510.webp)测试结果：**Lambda 循环中删除数据非安全**。

**Lambda 删除的正确方式**：

```java
// 根据 map 中的 key 去判断删除
map.keySet().removeIf(key -> key == 1);
map.forEach((key, value) -> {
    System.out.println("show:" + key);
});
```

以上程序的执行结果：

> show:0
>
> show:2

从上面的代码可以看出，可以先使用 `Lambda` 的 `removeIf` 删除多余的数据，再进行循环是一种正确操作集合的方式。

#### 4、Stream 方式

```java
map.entrySet().stream().forEach((entry) -> {
    if (entry.getKey() == 1) {
        System.out.println("del:" + entry.getKey());
        map.remove(entry.getKey());
    } else {
        System.out.println("show:" + entry.getKey());
    }
});
```

以上程序的执行结果：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072254711.webp)

测试结果：**Stream 循环中删除数据非安全**。

**Stream 循环的正确方式**：

```java
map.entrySet().stream().filter(m -> 1 != m.getKey()).forEach((entry) -> {
    if (entry.getKey() == 1) {
        System.out.println("del:" + entry.getKey());
    } else {
        System.out.println("show:" + entry.getKey());
    }
});
```

以上程序的执行结果：

> show:0
>
> show:2

从上面的代码可以看出，可以使用 `Stream` 中的 `filter` 过滤掉无用的数据，再进行遍历也是一种安全的操作集合的方式。

#### 小结

不能在遍历中使用集合 `map.remove()` 来删除数据，这是非安全的操作方式，但是可以使用迭代器的 `iterator.remove()` 的方法来删除数据，这是安全的删除集合的方式。同样的也可以使用 Lambda 中的 `removeIf` 来提前删除数据，或者是使用 Stream 中的 `filter` 过滤掉要删除的数据进行循环，这样都是安全的，还可以在 `for` 循环前删除数据在遍历也是线程安全的。

### 总结

了解了HashMap 4 种遍历方式：迭代器、for、lambda、stream，以及具体的 7 种遍历方法，综合性能和安全性来看，**应该尽量使用迭代器（Iterator）来遍历** `**EntrySet**` **的遍历方式来操作 Map 集合**，这样就会既安全又高效了。

## 删除 HashMap 中的元素

### HashMap 删除元素方案

**假设有以下数据：**

```java
public Map<String, String> initMap = new HashMap<>() {{
    put("user1", "张三");
    put("user2", "李四");
    put("user3", "张三");
    put("user4", "李四");
    put("user5", "王五");
    put("user6", "赵六");
    put("user7", "李四");
    put("user8", "王五");
}};
```

一般删除 HashMap 集合中的元素，如果知道具体的 Key，并且需要根据 Key 删除元素，使用 remove 方法就可以了。但是如何根据 Value 删除 HashMap 集合中的元素呢？这才是必须掌握的技巧！

#### 1、使用 for 循环删除

```java
/**
 * 使用 for 循环删除
 */
@Test
public void remove1() {
    Set<Map.Entry<String, String>> entries = new CopyOnWriteArraySet<>(initMap.entrySet());
    for (Map.Entry<String, String> entry : entries) {
        if ("张三".equals(entry.getValue())) {
            initMap.remove(entry.getKey());
        }
    }
    System.out.println(initMap);
}
```

输出结果：

```plain
{user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}
```

使用 HashMap 中实现的 entrySet 方法获取元素的集合，然后再进行循环遍历，先根据 Value 值判断要删除的元素，然后再根据 Key 删除元素。

在之前的文章中知道，增强的 for 循环底层使用的迭代器 Iterator，而 HashMap 是 fail-fast 类型的错误机制，所以遍历时删除元素会出现 java.util.ConcurrentModificationException 并发修改异常。

所以，这里使用了线程安全的 CopyOnWriteArraySet 封装了一层，避免出现并发修改异常，java.util.concurrent 包中的并发集合类都被设计为 fail-safe（安全失败）类型的，比如 CopyOnWrite* 、ConcerrentHashMap 集合，遍历过程中结构发生变更是安全的，不会抛出以上异常。

**需要注意的是：**

虽然  CopyOnWriteArraySet 并发性能很好，但每次删除时都会复制一份同等集合，所以要考虑数据过多可能导致的内存消耗问题。具体使用和实现原理可以点击该 CopyOnWriteArraySet  关键字链接看之前的文章，这里不再撰述。

#### 2、使用 forEach 循环删除

```java
/**
 * 使用 forEach 循环删除
 */
@Test
public void remove2() {
    ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>(initMap);
    map.forEach((k, v) -> {
        if ("张三".equals(v)) {
            map.remove(k);
        }
    });
    System.out.println(map);
}
```

输出结果：

```plain
{user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}
```

使用 HashMap 自带的 forEach 循环删除指定值的元素，这里为什么使用线程安全的 ConcurrentHashMap 集合包装了一层，同样是为了避免并发修改异常。ConcurrentHashMap 在各版本中都使用了最优的锁设计方案，它的并发性能也是非常优异的。

#### 3、使用 Iterator 迭代器删除

```java
/**
 * 使用 Iterator 迭代器删除
 */
@Test
public void remove3() {
    Iterator<Map.Entry<String, String>> iterator = initMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> entry = iterator.next();
        if ("张三".equals(entry.getValue())) {
            iterator.remove();
        }
    }
    System.out.println(initMap);
}
```

输出结果：

```plain
{user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}
```

这种方式即正常使用迭代器遍历删除，它不会发生并发修改异常。

**需要注意的是：**这种方法虽然不会发生并发修改异常，但 HashMap 并不是线程安全的，在迭代删除元素时，另一个线程可能会删除 HashMap 中的数据， 这时使用迭代器删除同样会导致并发修改异常。

所以，要保证线程安全的删除，在创建迭代器之前，可以先用线程安全的 ConcurrentHashMap 集合包装一层。或者使用  synchronized 关键字锁住整个 Map。

如果没有多线程修改环境，可以不用考虑。

#### 4、使用 removeIf 删除

```java
/**
 * 使用 removeIf 删除
 */
@Test
public void remove4() {
    initMap.entrySet().removeIf(entry -> "张三".equals(entry.getValue()));
    System.out.println(initMap);
}
```

输出结果：

```plain
{user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}
```

使用 entrySet 的 removeIf 删除，它底层使用的是迭代器：

```java
default boolean removeIf(Predicate<? super E> filter) {
    Objects.requireNonNull(filter);
    boolean removed = false;
    final Iterator<E> each = iterator();
    while (each.hasNext()) {
        if (filter.test(each.next())) {
            each.remove();
            removed = true;
        }
    }
    return removed;
}
```

所以，它和方法 3 是一样的，只不过把条件写成了 Predicate 函数式接口而已。

**需要注意的是：**removeIf 虽然更方便了，但它仍然不是线程安全的，多线程场景参考方案同方法 3。

#### 5、使用 Stream 删除

```java
/**
 * 使用 Stream 删除
 */
@Test
public void remove5() {
    Map<String, String> map = initMap.entrySet().stream()
    .filter(entry -> !"张三".equals(entry.getValue()))
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    System.out.println(map);
}
```

输出结果：

```plain
{user2=李四, user7=李四, user8=王五, user5=王五, user6=赵六, user4=李四}
```

利用 Stream 的 filter 方法进行过滤，这个方法也十分简单，一行代码搞定。

### 总结

本文总结了 5 种删除 HashMap 元素的方法：

- 使用 for 循环删除
- 使用 forEach 循环删除
- 使用 Iterator 迭代器删除
- 使用 removeIf 删除
- 使用 Stream 删除

实际开发过程中，可能会使用不同的遍历方式，所以重点要考虑多线程场景，**如果只是简单的删除元素，使用 removeIf 和 Stream 过滤是最省事的。**



## 3 种删除 HashMap 中重复元素的实现思路

### 为什么不是根据 Key 去重？

大家都知道，HashMap 的 key 是不会重复的，如果有重复就会用新值覆盖旧值。

向一个 HashMap 中插入元素时，HashMap 会根据这个 key 的 `equals` 和 `hashCode` 方法进行判断，如果两个 key 的值用 `equals` 方法比较相同，且 key 的 hashCode 值也相同，那么 HashMap 将认为这是同一个 key，后续插入相同 key 的键值对会将旧值替换为新值。

**需要注意的是：**

Java 中的基本数据类型和 String 等内置类，它们已经正确实现了 equals 和 hashCode 方法，可以直接用作 HashMap 的 key，而不会导致重复的 key 出现。

如果使用自定义类的对象作为 HashMap 的 key，需要保证这个类正确实现了 equals 和 hashCode 方法，否则可能会出现插入 "**重复 key**" 的情况，正常情况下，这是不符合规范和逻辑的。

### HashMap 删除重复元素方案

以下 HashMap 初始测试数据：

```java
public Map<String, String> initMap = new HashMap<>() {{
    put("user1", "张三");
    put("user2", "李四");
    put("user3", "张三");
    put("user4", "李四");
    put("user5", "王五");
    put("user6", "赵六");
    put("user7", "李四");
    put("user8", "王五");
}};
```

#### 1、新创建 Map 添加不重复元素

```java
/**
 * 新创建 Map 添加不重复元素
 */
@Test
public void removeDuplicated1() {
    Map<String, String> map = new HashMap<>();
    initMap.forEach((k, v) -> {
        if (!map.containsValue(v)) {
            map.put(k, v);
        }
    });
    System.out.println(map);
}
```

这种方法很原始，通过创建一个新 HashMap，添加元素前进行判断，如果元素在新 HashMap 中不存在才进行添加。

#### 2、添加 Set 再删除重复元素

```java
/**
 * 添加 Set 再删除重复元素
 */
@Test
public void removeDuplicated2() {
    Set<String> set = new HashSet<>();
    Iterator<Map.Entry<String, String>> iterator = initMap.entrySet().iterator();
    while (iterator.hasNext()) {
        Map.Entry<String, String> entry = iterator.next();
        if (!set.add(entry.getValue())) {
            iterator.remove();
        }
    }
    System.out.println(initMap);
}
```

这种方法和第一种方法大同小异，通过创建一个 HashSet，然后遍历 HashMap，因为 HashSet 是不允许重复元素的，所以，如果 HashSet 能添加元素说明元素没有重复，否则说明元素重复了，然后删除即可。

#### 3、使用 Stream 删除重复元素

```java
/**
 * 使用 Stream 删除重复元素
 */
@Test
public void removeDuplicated3() {
    Map<String, String> resultMap = initMap.entrySet().stream().collect(
            Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey, (key1, key2) -> key1)
    ).entrySet().stream().collect(
            Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey, (key1, key2) -> key1)
    );
    System.out.println(resultMap);
}
```

利用 Stream 的 collect 方法重新进行收集，这个方法也十分简单，一行代码搞定，为了可读性，文中代码进行了换行。

`Collectors.toMap` 方法返回的是一个Collector，它可以将元素累积到 Map 中，Map 的键和值将提供的映射函数应用到输入元素的结果，如果映射的键包含重复项，则值映射函数会使用提供的 merge 函数进行结果合并。

`**Collectors.toMap**` **方法可以对 Key 进行去重合并，这也是为什么进行了两次 collect 收集的原因：**

**第一次收集：**

把 Value 作为 Key，Key 作为 Value，这样就能使用 Value 进行去重了，输出结果：

```plain
{李四=user2, 张三=user1, 王五=user8, 赵六=user6}
```

虽然能去重了，但是 HashMap 中的 Key 和 Value 值却颠倒了，所以需要第二次收集。

**第二次收集：**

现在的 Key 是之前的 Value，所以需要再相互换过来，输出结果：

```plain
{user1=张三, user2=李四, user8=王五, user6=赵六}
```

这个方法比较绕，虽然能一行代码搞定，但代码很冗余，不是很优雅，**最重要的是这两次的收集过程会创建两次新 Map，相对比较耗内存。**

### 总结

这里总结了 3 种删除 HashMap 重复元素的方法：

- 新创建 Map 添加不重复元素
- **添加 Set 再删除重复元素（推荐）**
- 使用 Stream 删除重复元素

实际开发过程中，可能会使用不同的遍历方式，使用哪种删除方案可以根据不同的遍历方式进行选择，**但推荐使用 Set 方案，可以直接删除 Map 中的重复元素，不会创建新的 HashMap。**

## Java 中九种 Map 的遍历方式

日常工作中 Map 绝对是 Java 程序员高频使用的一种数据结构，那 Map 都有哪些遍历方式呢？

### 通过 entrySet 来遍历

#### 1、通过 for 和 `map.entrySet()` 来遍历

第一种方式是采用 for 和 `Map.Entry` 的形式来遍历，通过遍历 `map.entrySet()` 获取每个 entry 的 key 和 value，代码如下。这种方式一般也是使用的比较多的一种方式，没有什么花里胡哨的用法，就是很朴素的获取 map 的 key 和 value。

```java
public static void testMap1(Map<Integer, Integer> map) {
    long sum = 0;
    for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
        sum += entry.getKey() + entry.getValue();
    }
    System.out.println(sum);
}
```

看过 HashMap 源码的同学应该会发现，这个遍历方式在源码中也有使用，如下图所示，

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072256876.jpeg)

`putMapEntries` 方法在调用 `putAll` 方法的时候会用到。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072256342.jpeg)

#### 2、通过 for， Iterator 和 `map.entrySet()` 来遍历

第一个方法是直接通过 for 和 `entrySet()` 来遍历的，这次使用 `entrySet()` 的迭代器来遍历，代码如下。

```java
public static void testMap2(Map<Integer, Integer> map) {
    long sum = 0;
    for (Iterator<Map.Entry<Integer, Integer>> entries = map.entrySet().iterator(); entries.hasNext(); ) {
        Map.Entry<Integer, Integer> entry = entries.next();
        sum += entry.getKey() + entry.getValue();
    }
    System.out.println(sum);
}
```

#### 3、通过 while，Iterator  和 `map.entrySet()` 来遍历

上面的迭代器是使用 for 来遍历，那自然可以想到还可以用 while 来进行遍历，所以代码如下所示。

```java
public static void testMap3(Map<Integer, Integer> map) {
    Iterator<Map.Entry<Integer, Integer>> it = map.entrySet().iterator();
    long sum = 0;
    while (it.hasNext()) {
        Map.Entry<Integer, Integer> entry = it.next();
        sum += entry.getKey() + entry.getValue();
    }
    System.out.println(sum);
}
```

这种方法跟上面的方法类似，只不过循环从 for 换成了 while，日常在开发的时候，很多场景都可以将 for 和 while 进行替换。2 和 3 都使用迭代器 Iterator，通过迭代器的 `next()`，方法来获取下一个对象，依次判断是否有 next。

### 通过 keySet 来遍历

上面的这三种方式虽然代码的写法不同，但是都是通过遍历 `map.entrySet()` 来获取结果的，殊途同归。接下来看另外的一组。

#### 4、通过 for 和 `map.keySet()` 来遍历

前面的遍历是通过 `map.entrySet()` 来遍历，这里通过 `map.keySet()` 来遍历，顾名思义前者是保存 entry 的集合，后者是保存 key 的集合，遍历的代码如下，因为是 key 的集合，所以如果想要获取 key 对应的 value 的话，还需要通过 `map.get(key)` 来获取。

```java
public static void testMap4(Map<Integer, Integer> map) {
    long sum = 0;
    for (Integer key : map.keySet()) {
        sum += key + map.get(key);
    }
    System.out.println(sum);
}
```

#### 5、通过 for，Iterator 和 `map.keySet()` 来遍历

```java
public static void testMap5(Map<Integer, Integer> map) {
    long sum = 0;
    for (Iterator<Integer> key = map.keySet().iterator(); key.hasNext(); ) {
        Integer k = key.next();
        sum += k + map.get(k);
    }
    System.out.println(sum);
}
```

#### 6、通过 while，Iterator 和 `map.keySet()` 来遍历

```java
public static void testMap6(Map<Integer, Integer> map) {
    Iterator<Integer> it = map.keySet().iterator();
    long sum = 0;
    while (it.hasNext()) {
        Integer key = it.next();
        sum += key + map.get(key);
    }
    System.out.println(sum);
}
```

可以看到这种方式相对于 `map.entrySet()` 方式，多了一步 get 的操作，这种场景比较适合只需要 key 的场景，如果也需要使用 value 的场景不建议使用 `map.keySet()` 来进行遍历，因为会多一步 `map.get()` 的操作。

### Java 8 的遍历方式

注意下面的几个遍历方法都是是 JDK 1.8 引入的，如果使用的 JDK 版本不是 1.8 以及之后的版本的话，是不支持的。

#### 7、通过 `map.forEach()` 来遍历

JDK 中的 forEach 方法，使用率也挺高的。

```java
public static void testMap7(Map<Integer, Integer> map) {
    final long[] sum = {0};
    map.forEach((key, value) -> {
        sum[0] += key + value;
    });
    System.out.println(sum[0]);
}
```

该方法被定义在 `java.util.Map#forEach` 中，并且是通过 `default` 关键字来标识的，如下图所示。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072257805.jpeg)

#### 8、Stream 遍历

```java
public static void testMap8(Map<Integer, Integer> map) {
    long sum = map.entrySet().stream().mapToLong(e -> e.getKey() + e.getValue()).sum();
    System.out.println(sum);
}
```

#### 9、ParallelStream 遍历

```java
public static void testMap9(Map<Integer, Integer> map) {
    long sum = map.entrySet().parallelStream().mapToLong(e -> e.getKey() + e.getValue()).sum();
    System.out.println(sum);
}
```

这两种遍历方式都是 JDK 8 的 Stream 遍历方式，stream 是普通的遍历，parallelStream 是并行流遍历，在某些场景会提升性能，但是也不一定。

### 测试代码

上面的遍历方式有了，那么在日常开发中到底该使用哪一种呢？每一种的性能是怎么样的呢？为此这里通过下面的代码，来测试一下每种方式的执行时间。

```java
public static void main(String[] args) {
    int outSize = 1;
    int mapSize = 200;
    Map<Integer, Integer> map = new HashMap<>(mapSize);
    for (int i = 0; i < mapSize; i++) {
        map.put(i, i);
    }
    System.out.println("---------------start------------------");
    long totalTime = 0;
    for (int size = outSize; size > 0; size--) {
        long startTime = System.currentTimeMillis();
        testMap1(map);
        totalTime += System.currentTimeMillis() - startTime;
    }
    System.out.println("testMap1 avg time is :" + (totalTime / outSize));
    // 省略其他方法，代码跟上面一致
}
```

为了避免一些干扰，这里通过外层的 for 来进行多次计算，然后求平均值，当参数分别是 outSize = 1，mapSize = 200 的时候，测试的结果如下

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072257654.jpeg)

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072257276.jpeg)

当随着增大 mapSize 的时候，会发现，后面几个方法的性能是逐渐上升的。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072257384.jpeg)

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072257940.jpeg)

### 总结

从上面的例子来看，当集合数量很少的时候，基本上普通的遍历就可以搞定，不需要使用 JDK 8 的高级 API 来进行遍历，当集合数量较大的时候，就可以考虑采用 JDK 8 的 forEach 或者 Stream 来进行遍历，这样的话效率更高。在普通的遍历方法中 `entrySet()` 的方法要比使用 `keySet()` 的方法好。

# Map 集合在Java8中新增的一些方法

在 Jdk 8 中 Map 接口提供了一些新的便利的方法。Jdk 8 中引进的 Map 方法有：`getOrDefault(Object, V)`，`putIfAbsent(K, V)`，`remove(Object, Object)`，`replace(K, V)`，`andreplace(K, V, V)`。

## Map 范例

### `Map.getOrDefault(Object key, V defaultValue)`

Map 的新方法 `getOrDefault(Object key, V defaultValue)` 允许调用者在代码语句中规定获得在 map 中符合提供的键的值，否则在没有找到提供的键的匹配项的时候返回一个 “默认值”。

```java
default V getOrDefault(Object key, V defaultValue) {
    V v;
    return (((v = get(key)) != null) || containsKey(key))
        ? v
        : defaultValue;
}
```

### `Map.putIfAbsent(K key, V value)`

Map 的新方法 `putIfAbsent(K key, V value)` 允许调用者在代码语句中规定添加在 map 中符合提供的键的值，若 map 中有对应 K 映射的 V 且不为 null 则直接返回，否则执行 put。

```java
default V putIfAbsent(K key, V value) {
    V v = get(key);
    if (v == null) {
        v = put(key, value);
    }

    return v;
}
```

### `Map.computeIfAbsent(K key, Function< ? super K, ? extends V> mappingFunction)`

`Map.computeIfAbsent` 方法原型 `V computeIfAbsent(K key, Function< ? super K, ? extends V> mappingFunction)`，如果指定的 key 不存在或相关的 value 为 null 时，设置 key 与关联一个计算出的非 null 值，计算出的值为 null 的话什么也不做(不会去删除相应的 key)。如果 key 存在并且对应 value 不为 null 的话什么也不做。同样，方法的返回值也是最终的 `map.get(key)`。

```java
default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
    Objects.requireNonNull(mappingFunction);
    V v;
    if ((v = get(key)) == null) {
        V newValue;
        if ((newValue = mappingFunction.apply(key)) != null) {
            put(key, newValue);
            return newValue;
        }
    }

    return v;
}
```

### `Map.computeIfPresent(K key, BiFunction< ? super K, ? super V, ? extends V> remappingFunction)`

`Map.computeIfPresent` 方法原型 `V computeIfPresent(K key, BiFunction< ? super K, ? super V, ? extends V> remappingFunction)`，如果指定的 key 存在并且相关联的 value 不为 null 时，根据旧的 key 和 value 计算 newValue 替换旧值，newValue 为 null 则从 map 中删除该 key；key 不存在或相应的值为 null 时则什么也不做，方法的返回值为最终的 `map.get(key)`。

```java
default V computeIfPresent(K key,
        BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    V oldValue;
    if ((oldValue = get(key)) != null) {
        V newValue = remappingFunction.apply(key, oldValue);
        if (newValue != null) {
            put(key, newValue);
            return newValue;
        } else {
            remove(key);
            return null;
        }
    } else {
        return null;
    }
}
```

### `Map.remove(Object key, Object value)`

Map 的新方法 `remove(Object key, Object value)` 超越了长期有效的 `Map.remove(Object key)`方法，只有在提供的键和值都匹配的时候才会删除该 map 项（之前的有效版本只是查找 “键” 的匹配来删除）。

```java
default boolean remove(Object key, Object value) {
    Object curValue = get(key);
    if (!Objects.equals(curValue, value) ||
        (curValue == null && !containsKey(key))) {
        return false;
    }
    remove(key);
    return true;
}
```

### `Map.replace(K key, V value)` / `Map.replace(K key, V oldValue, V newValue)`

`Map.replace(K key, V value)` 方法只有在指定的键已经存在并且有与之相关的映射值时才会将指定的键映射到指定的值（新值）。

```java
default V replace(K key, V value) {
    V curValue;
    if (((curValue = get(key)) != null) || containsKey(key)) {
        curValue = put(key, value);
    }
    return curValue;
}
```

`Map.replace(K key, V oldValue, V newValue)` 方法接受一个额外的（第三个）参数，只有在指定的键和值都匹配的情况下才会替换。

```java
default boolean replace(K key, V oldValue, V newValue) {
    Object curValue = get(key);
    if (!Objects.equals(curValue, oldValue) ||
        (curValue == null && !containsKey(key))) {
        return false;
    }
    put(key, newValue);
    return true;
}
```

### `Map.merge(K key, V value, BiFunction< ? super V, ? super V, ? extends V> remappingFunction)`

`Map.merge(K key, V value, BiFunction< ? super V, ? super V, ? extends V> remappingFunction)` 方法，如果指定的 key 不存在，或相应的值为 null 时，则设置 value 为相关联的值。否则根据 key 对应的旧值和 value 计算出新的值 newValue，newValue 为 null 时，删除该 key，否则设置 key 对应的值为 newValue。方法的返回值也是最终的 `map.get(key)` 值。

```java
default V merge(K key, V value,
        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    Objects.requireNonNull(value);
    V oldValue = get(key);
    V newValue = (oldValue == null) ? value :
               remappingFunction.apply(oldValue, value);
    if(newValue == null) {
        remove(key);
    } else {
        put(key, newValue);
    }
    return newValue;
}
```

### `Map.forEach(BiConsumer< ? super K, ? super V> action)`

```java
Map.forEach(BiConsumer< ? super K, ? super V> action) 方法用于遍历 map。
// JDK8 之前的实现方式 方式一 这是最常见的并且在大多数情况下也是最可取的遍历方式
for (Map.Entry<String, String> entry : statesAndCapitals.entrySet()) {
    System.out.println("Key =" + entry.getKey() + ", Value =" + entry.getValue());
}

// JDK8 之前的实现方式 方法二 在 for-each 循环中遍历 keys 或 values
// 遍历 map 中的键
for (String key : statesAndCapitals.keySet()) {
    System.out.println("Key =" + key);
}
// 遍历 map 中的值
for (String value : statesAndCapitals.values()) {
    System.out.println("Value =" + value);
}


// JDK8 之前的实现方式 方法三使用 Iterator 遍历
Iterator<Map.Entry<String, String>> entries = statesAndCapitals.entrySet().iterator();
while (entries.hasNext()) {
    Map.Entry<String, String> entry = entries.next();
    System.out.println("Key =" + entry.getKey() + ", Value =" + entry.getValue());
}

// JDK8 之前的实现方式 通过键找值遍历（效率低）
for (String key : statesAndCapitals.keySet()) {
    String value = statesAndCapitals.get(key);
    System.out.println("Key =" + key + ", Value =" + value);
}

// JDK8 的实现方式
statesAndCapitals.forEach((s, s2) -> System.out.println("Key =" + s + ", Value =" + s2));
```

### `Map.sorted`

Map.sorted 方法用于排序 map。

```java
/**
 * 1. 第一层括弧实际是定义了一个匿名内部类 (Anonymous Inner Class)
 * 2. 第二层括弧实际上是一个实例初始化块 (instance initializer block), 这个块在内部匿名类构造时被执行, 这个块之所以被叫做 “实例初始化块” 是因为它们被定义在了一个类的实例范围内
 * 3. 如果 value 为 java 对象, 则需要实现 Comparable 接口, 重写 compareTo 方法
 */
Map<String, Integer> map = new HashMap<String, Integer>() {
    {
        put("A", 3);
        put("B", 5);
        put("C", 1);
        put("D", 1);
        put("E", 9);
    }
};
System.out.println(map);


// 1. 根据 value 对 map 进行 ASC 排序
Map<String, Integer> sortedMap = new LinkedHashMap<>();
map.entrySet()
    .stream()
    .sorted(Map.Entry.comparingByValue())
    .forEachOrdered(x -> sortedMap.put(x.getKey(), x.getValue()));
System.out.println(sortedMap);

// 2. 根据 value 对 map 进行 DESC 排序
Map<String, Integer> sortedMap2 = new LinkedHashMap<>();
map.entrySet()
    .stream()
    // DESC .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
    .sorted(Collections.reverseOrder(Map.Entry.comparingByValue()))
    .forEachOrdered(x -> sortedMap2.put(x.getKey(), x.getValue()));
System.out.println(sortedMap2);

// 3.Collectors.toMap 直接返回排好序的 map
Map<String, Integer> sortedMap3;
sortedMap3 = map.entrySet()
    .stream()
    .sorted(Map.Entry.<String, Integer>comparingByValue().reversed())
    // .collect(Collectors.toMap(x -> x.getKey(), x -> x.getValue(), (x1, x2) -> x2, LinkedHashMap::new));
    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue, (x1, x2) -> x2, LinkedHashMap::new));
System.out.println(sortedMap3);
```

# Map -> HashMap

## 一、 Map

### 1.1 Map 接口

在 Java 中。Map 提供了键——值的映射关系。映射不能包含重复的键，并且每个键只能映射到一个值。

以 Map 键——值映射为基础，java.util 提供了 HashMap（最常用）、 TreeMap、Hashtble、LinkedHashMap 等数据结构。

衍生的几种 Map 的主要特点：

- HashMap：最常用的数据结构。键和值之间通过 Hash函数 来实现映射关系。当进行遍历的 key 是无序的
- TreeMap：使用红黑树构建的数据结构，因为红黑树的原理，可以很自然的对 key 进行排序，所以 TreeMap 的 key 遍历时是默认按照自然顺序（升序）排列的。
- LinkedHashMap：保存了插入的顺序。遍历得到的记录是按照插入顺序的。

### 1.2 Hash 散列函数

Hash （散列函数）是把任意长度的输入通过散列算法变换成固定长度的输出。Hash 函数的返回值也称为 哈希值 哈希码 摘要或哈希。Hash作用如下图所示：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072259833.jpeg" alt="img" style="zoom:50%;" />

Hash 函数可以通过选取适当的函数，可以在时间和空间上取得较好平衡。

解决 Hash 的两种方式：拉链法和线性探测法

### 1.3 键值关系的实现

```java
interface Entry<K,V>
```

在 HashMap 中基于链表的实现

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
```

用树的方式实现：

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;    // needed to unlink next upon deletion
    boolean red;
    TreeNode(int hash, K key, V val, Node<K,V> next) {
        super(hash, key, val, next);
    }
```

### 1.4 Map 约定的 API

#### 1.4.1 Map 中约定的基础 API

基础的增删改查：

```java
int size();  // 返回大小
boolean isEmpty(); // 是否为空
boolean containsKey(Object key); // 是否包含某个键
boolean containsValue(Object value); // 是否包含某个值
V get(Object key); // 获取某个键对应的值
V put(K key, V value); // 存入的数据
V remove(Object key); // 移除某个键
void putAll(Map<? extends K, ? extends V> m); //将将另一个集插入该集合中
void clear();  // 清除
Set<K> keySet(); //获取 Map的所有的键返回为 Set集合
Collection<V> values(); //将所有的值返回为 Collection 集合
Set<Map.Entry<K, V>> entrySet(); // 将键值对映射为 Map.Entry，内部类 Entry 实现了映射关系的实现。并且返回所有键值映射为 Set 集合。
boolean equals(Object o);
int hashCode(); // 返回 Hash 值
default boolean replace(K key, V oldValue, V newValue); // 替代操作
default V replace(K key, V value);
```

#### 1.4.2 Map 约定的较为高级的 API

```java
default V getOrDefault(Object key, V defaultValue); //当获取失败时，用 defaultValue 替代。

default void forEach(BiConsumer<? super K, ? super V> action)  // 可用 lambda 表达式进行更快捷的遍历

default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function);

default V putIfAbsent(K key, V value);

default V computeIfAbsent(K key,
            Function<? super K, ? extends V> mappingFunction);

default V computeIfPresent(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction);

default V compute(K key,
            BiFunction<? super K, ? super V, ? extends V> remappingFunction)

default V merge(K key, V value,
            BiFunction<? super V, ? super V, ? extends V> remappingFunction)
```

#### 1.4.3 Map 高级 API 的使用

- `getOrDefault()` 当这个通过 key获取值，对应的 key 或者值不存在时返回默认值，避免在使用过程中 null 出现，避免程序异常。
- `ForEach()` 传入 `BiConsumer` 函数式接口，表达的含义其实和 `Consumer` 一样，都拥有 `accept` 方法，只是 `BiConsumer` 多了一个 `andThen()` 方法，接收一个`BiConsumer`接口，先执行本接口的，再执行传入的参数的 `accept` 方法。

```java
Map<String, String> map = new HashMap<>();
map.put("a", "1");
map.put("b", "2");
map.put("c", "3");
map.put("d", "4");
map.forEach((k, v) -> {
    System.out.println(k+"-"+v);
});
```

### 1.5 从 Map 走向 HashMap

HashMap 是 Map的一个实现类，也是 Map 最常用的实现类。

####  1.5.1 HashMap 的继承关系

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable
```

在 HashMap 的实现过程中，解决 Hash冲突的方法是拉链法。因此从原理来说 HashMap 的实现就是 数组 + 链表（数组保存链表的入口）。

当链表过长，为了优化查询速率，HashMap 将链表转化为红黑树（数组保存树的根节点），使得查询速率为 log(n)，而不是链表的 O(n)。

## 二、HashMap

```java
/*
 * @author  Doug Lea
 * @author  Josh Bloch
 * @author  Arthur van Hoff
 * @author  Neal Gafter
 * @see     Object#hashCode()
 * @see     Collection
 * @see     Map
 * @see     TreeMap
 * @see     Hashtable
 * @since   1.2
 */
```

首先 HashMap 由 Doug Lea 和 Josh Bloch 两位大师的参与。同时 Java 的 Collections 集合体系，并发框架 Doug Lea 也做出了不少贡献。

### 2.1 基本原理

对于一个插入操作，首先将键通过 Hash 函数转化为数组的下标。若该数组为空，直接创建节点放入数组中。若该数组下标存在节点，即 Hash 冲突，使用拉链法，生成一个链表插入。图片

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308072300662.png" alt="img" style="zoom: 80%;" />

如果存在 Hash 冲突，使用拉链法插入，可以在这个链表的头部插入，也可以在链表的尾部插入，所以在 JDK 1.7 中使用了头部插入的方法，JDK 1.8 后续的版本中使用尾插法。

JDK 1.7 使用头部插入的可能依据是最近插入的数据是最常用的，但是头插法带来的问题之一，在多线程会链表的复制会出现死循环。所以 JDK 1.8 之后采用的尾部插入的方法。

在 HashMap 中，前面说到的 数组+链表 的数组的定义

```java
transient Node<K,V>[] table;
```

链表的定义：

```java
static class Node<K,V> implements Map.Entry<K,V>
```

#### 2.1.2 提供的构造函数

```java
public HashMap() { // 空参
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}
public HashMap(int initialCapacity) { //带有初始大小的，一般情况下，需要规划好 HashMap 使用的大小，因为对于一次扩容操作，代价是非常的大的
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
public HashMap(int initialCapacity, float loadFactor); // 可以自定义负载因子  
public HashMap(int initialCapacity, float loadFactor); // 可以自定义负载因子
```

三个构造函数，都没有完全的初始化 HashMap，当第一次插入数据时，才进行堆内存的分配，这样提高了代码的响应速度。

### 2.2 HashMap 中的 Hash函数定义

```java
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16); // 将 h 高 16 位和低 16 位 进行异或操作。
}
// 采用 异或的原因：两个进行位运算，在与或异或中只有异或到的 0 和 1 的概率是相同的，而&和|都会使得结果偏向0或者1。
```

这里可以看到，Map 的键可以为 null，且 hash 是一个特定的值 0。

Hash 的目的是获取数组 table 的下标。Hash 函数的目标就是将数据均匀的分布在 table 中。

先看看如何通过 hash 值得到对应的数组下标。第一种方法：`hash%table.length()`。但是除法操作在 CPU 中执行比加法、减法、乘法慢的多，效率低下。第二种方法 `table[(table.length - 1) & hash]` 一个与操作一个减法，仍然比除法快。这里的约束条件为  `table.length = 2^N`。

```java
table.length =16;
table.length -1 = 15 1111 1111;
//任何一个数与之与操作，获取到这个数的低 8 位，其他位为 0
```

上面的例子可以获取到对应的下标，而 `(h = key.hashCode()) ^ (h >>> 16)` 让高 16 也参与运算，让数据充分利用，一般情况下 table 的索引不会超过 216，所以高位的信息就直接抛弃了，`^ (h >>> 16)` 在数据量较少的情况下，也可以使用高位的信息。如果 table 的索引超过 216， `hashCode()` 的高 16 为 和 16 个 0 做异或得到的 Hash 也是公平的。

### 2.3 HashMap 的插入操作

上面已经知道如果通过 Hash 获取到 对应的 table 下标，因此将对应的节点加入到链表就完成了一个 Map 的映射，的确 JDK1.7 中的 HashMap 实现就是这样。看一看 JDK 为实现现实的 put 操作。定位到 `put()` 操作。

```java
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

可以看到 put 操作交给了 putVal 来进行通用的实现。

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict);
//onlyIfAbsent  如果当前位置已存在一个值，是否替换，false是替换，true是不替换
//evict  钩子函数的参数，LinkedHashMap 中使用到，HashMap 中无意义。
```

#### 2.3.1 `putVal` 的流程分析

其实 `putVal()` 流程的函数非常的明了。这里挑了几个关键步骤来引导。

是否第一次插入，true 调用 `resize()` 进行调整，其实此时 `resize()` 是进行完整的初始化，之后直接赋值给对应索引的位置。

```java
if ((tab = table) == null || (n = tab.length) == 0) // 第一次 put 操作， tab 没有分配内存，通过 redize() 方法分配内存，开始工作。
    n = (tab = resize()).length;
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
```

如果链表已经转化为树，则使用树的插入。

```java
else if (p instanceof TreeNode)
    e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
```

用遍历的方式遍历每个 Node，如果遇到键相同，或者到达尾节点的next 指针将数据插入，记录节点位置退出循环。若插入后链表长度为 8 则调用 `treeifyBin()` 是否进行树的转化 。

```java
for (int binCount = 0; ; ++binCount) {
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &&
        ((k = e.key) == key || (key != null && key.equals(k))))
        break;
    p = e;
}
```

对键重复的操作：更新后返回旧值，同时还取决于`onlyIfAbsent`，普通操作中一般为 true，可以忽略。

```java
if (e != null) { // existing mapping for key
    V oldValue = e.value;
    if (!onlyIfAbsent || oldValue == null)
        e.value = value;
    afterNodeAccess(e); //钩子函数，进行后续其他操作，HashMap中为空，无任何操作。
    return oldValue;
}
```

后续的数据维护。

#### 2.3.2 modCount 的含义

fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出`ConcurrentModificationException`异常，产生fail-fast事件。一种多线程错误检查的方式，减少异常的发生。

一般情况下，多线程环境使用 `ConcurrentHashMap` 来代替 `HashMap`

### 2.4 `resize()` 函数

HashMap 扩容的特点：默认的table 表的大小事 16，threshold 为 12。负载因子 loadFactor .75，这些都是可以构造是更改。以后扩容都是 2 倍的方式增加。

至于为何是0.75 代码的注释中也写了原因，对 Hash函数构建了泊松分布模型，进行了分析。

#### 2.4.1 HashMap 预定义的一些参数

```java
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16  HashMap 的默认大小。为什么使用 1 <<4
static final int MAXIMUM_CAPACITY = 1 << 30; // 最大容量
static final float DEFAULT_LOAD_FACTOR = 0.75f; // 加载因子，扩容使用

static final int UNTREEIFY_THRESHOLD = 6;//  树结构转化为链表的阈值
static final int TREEIFY_THRESHOLD = 8;  //  链表转化为树结构的阈值
static final int MIN_TREEIFY_CAPACITY = 64; // 链表转变成树之前，还会有一次判断，只有数组长度大于 64 才会发生转换。这是为了避免在哈希表建立初期，多个键值对恰好被放入了同一个链表中而导致不必要的转化。

// 定义的有关变量
int threshold;   // threshold表示当HashMap的size大于threshold时会执行resize操作
```

这些变量都是和 HashMap 的扩容机制有关，将会在下文中用到。

#### 2.4.2 `resize()` 方法解析

```java
Node<K,V>[] oldTab = table;
int oldCap = (oldTab == null) ? 0 : oldTab.length;
int oldThr = threshold;
int newCap, newThr = 0; // 定义了 旧表长度、旧表阈值、新表长度、新表阈值

if (oldCap > 0) {  // 插入过数据，参数不是初始化的
    if (oldCap >= MAXIMUM_CAPACITY) {  // 如果旧的表长度大于 1 << 30;
        threshold = Integer.MAX_VALUE; // threshold 设置 Integer 的最大值。也就是说我们可以插入 Integer.MAX_VALUE 个数据
        return oldTab; // 直接返回旧表的长度，因为表的下标索引无法扩大了。
    }
    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY && //
             oldCap >= DEFAULT_INITIAL_CAPACITY)  //新表的长度为旧表的长度的 2 倍。
        newThr = oldThr << 1; // double threshold 新表的阈值为同时为旧表的两倍
}
else if (oldThr > 0) //   public HashMap(int initialCapacity, float loadFactor)   中的  this.threshold = tableSizeFor(initialCapacity);  给正确的位置
    newCap = oldThr;
else {               // zero initial threshold signifies using defaults ，如果调用了其他两个构造函数，则下面代码初始化。因为他们都没有对其 threshold 设置，默认为 0，
    newCap = DEFAULT_INITIAL_CAPACITY;
    newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
}
if (newThr == 0) { // 修正 threshold，例如上面的   else if (oldThr > 0)  部分就没有设置。
    float ft = (float)newCap * loadFactor;
    newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
              (int)ft : Integer.MAX_VALUE);
}
threshold = newThr;
@SuppressWarnings({"rawtypes","unchecked"})
```

当一些参数设置正确后便开始扩容。

```java
Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
```

当扩容完毕之后，自然就是将原表中的数据搬到新的表中。下面代码完成了该任务。

```java
if (oldTab != null) {
   for (int j = 0; j < oldCap; ++j) {
      ....
   }
}
```

如何正确的，快速的扩容调整每个键值节点对应的下标？第一种方法：遍历节点再使用 `put()` 加入一遍，这种方法实现，但是效率低下。第二种，手动组装好链表，加入到相应的位置。显然第二种比第一种高效，因为第一种 `put()` 还存在其他不属于这种情况的判断，例如重复键的判断等。

所以 JDK 1.8 也使用了第二种方法。可以继续使用`e.hash & (newCap - 1)`找到对应的下标位置，对于旧的链表，执行`e.hash & (newCap - 1)` 操作，只能产生两个不同的索引。一个保持原来的索引不变，另一个变为 原来索引 + oldCap(因为 newCap 的加入产生导致索引的位数多了 1 位，即就是最左边的一个，且该位此时结果为 1，所以相当于 原来索引 + oldCap)。所以可以使用 `if ((e.hash & oldCap) == 0)` 来确定出索引是否来变化。

因此这样就可以将原来的链表拆分为两个新的链表，然后加入到对应的位置。为了高效，手动的组装好链表再存储到相应的下标位置上。

```java
oldCap  = 16
newCap  = 32
hash       : 0001 1011
oldCap-1   : 0000 1111
结果为     :  0000 1011  对应的索引的 11
-------------------------
e.hash & oldCap 则定于 1,则需要进行调整索引
oldCap  = 16
hash       : 0001 1011
newCap-1   : 0001 1111
结果为     :  0001 1011
相当于 1011 + 1 0000 原来索引 + oldCap
for (int j = 0; j < oldCap; ++j)  // 处理每个链表
```

特殊条件处理

```java
Node<K,V> e;
if ((e = oldTab[j]) != null) {
    oldTab[j] = null;
    if (e.next == null)  // 该 链表只有一个节点，那么直接复制到对应的位置，下标由 e.hash & (newCap - 1) 确定
        newTab[e.hash & (newCap - 1)] = e;
    else if (e instanceof TreeNode) // 若是 树，该给树的处理程序
        ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
```

普通情况处理：

```java
else { // preserve order
    Node<K,V> loHead = null, loTail = null;  // 构建原来索引位置 的链表，需要的指针
    Node<K,V> hiHead = null, hiTail = null; // 构建 原来索引 + oldCap 位置 的链表需要的指针
    Node<K,V> next;
    do {
        next = e.next;
        if ((e.hash & oldCap) == 0) {
            if (loTail == null)
                loHead = e;
            else
                loTail.next = e;
            loTail = e;
        }
        else {
            if (hiTail == null)
                hiHead = e;
            else
                hiTail.next = e;
            hiTail = e;
        }
    } while ((e = next) != null); // 将原来的链表划分两个链表
    if (loTail != null) { // 将链表写入到相应的位置
        loTail.next = null;
        newTab[j] = loHead;
    }
    if (hiTail != null) {
        hiTail.next = null;
        newTab[j + oldCap] = hiHead;
    }
}
```

到此 `resize()` 方法的逻辑完成了。总的来说 `resize()` 完成了 HashMap 完整的初始化，分配内存和后续的扩容维护工作。

### 2.5 `remove` 解析

```java
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```

将 `remove` 删除工作交给内部函数 `removeNode()` 来实现。

```java
final Node<K,V> removeNode(int hash, Object key, Object value,
                           boolean matchValue, boolean movable) {
    Node<K,V>[] tab; Node<K,V> p; int n, index;
    if ((tab = table) != null && (n = tab.length) > 0 &&
        (p = tab[index = (n - 1) & hash]) != null) {  // 获取索引，
        Node<K,V> node = null, e; K k; V v;
        if (p.hash == hash &&
            ((k = p.key) == key || (key != null && key.equals(k)))) // 判断索引处的值是不是想要的结果
            node = p;
        else if ((e = p.next) != null) { // 交给树的查找算法
            if (p instanceof TreeNode)
                node = ((TreeNode<K,V>)p).getTreeNode(hash, key);
            else {
                do { // 遍历查找
                    if (e.hash == hash &&
                        ((k = e.key) == key ||
                         (key != null && key.equals(k)))) {
                        node = e;
                        break;
                    }
                    p = e;
                } while ((e = e.next) != null);
            }
        }
        if (node != null && (!matchValue || (v = node.value) == value ||
                             (value != null && value.equals(v)))) {
            if (node instanceof TreeNode)  //树的删除
                ((TreeNode<K,V>)node).removeTreeNode(this, tab, movable);
            else if (node == p) // 修复链表，链表的删除操作
                tab[index] = node.next;
            else
                p.next = node.next;
            ++modCount;
            --size;
            afterNodeRemoval(node);
            return node;
        }
    }
    return null;
}
```

## 三、 HashMap 从链表到红黑树的转变

如果链表的长度（冲突的节点数）已经达到8个，此时会调用 `treeifyBin()` ，`treeifyBin()` 首先判断当前hashMap 的 table的长度，如果不足64，只进行resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树。在源码还有这样的一个字段。

```java
static final int UNTREEIFY_THRESHOLD = 6;
// 这样表明了从红黑树转化为链表的阈值为 6，为何同样不是 8 那？
// 如果插入和删除都在 8 附近，将多二者相互转化将浪费大量的时间，对其性能影响。
// 如果是的二者转化的操作不平衡，偏向一方，则可以避免此类影响。
```

### 3.1 红黑树的数据结构

```java
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;    // 删除后需要取消链接，指向前一个节点（原链表中的前一个节点）
    boolean red;
}
```

因为 继承了 `LinkedHashMap.Entry<K,V>` ，所以存储的数据还是在Entry 中：

```java
static class Node<K,V> implements Map.Entry<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next;

    Node(int hash, K key, V value, Node<K,V> next) {
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    }
}
```

### 3.2 承上启下的 `treeifyBin()`

`treeifyBin()` 决定了一个链表何时转化为一个红黑树。`treeifyBin()` 有两种格式：

```java
final void treeifyBin(Node<K,V>[] tab, int hash);
final void treeify(Node<K,V>[] tab);
final void treeifyBin(Node<K,V>[] tab, int hash) { // 简单的 Node 修改为 TreeNode，同时维护了 prev 属性。
    int n, index; Node<K,V> e;
    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
        resize();
    else if ((e = tab[index = (n - 1) & hash]) != null) {
        TreeNode<K,V> hd = null, tl = null;
        do {
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);  // 真正生成红黑树的
    }
}
TreeNode<K,V> replacementTreeNode(Node<K,V> p, Node<K,V> next) {
    return new TreeNode<>(p.hash, p.key, p.value, next);
} // 实现 Node 链表节点到 TreeNode 节点的转化。
```

下面函数真正实现了链表的红黑树的转变。首先构建一个标准查询二叉树，然后在标准查询二叉树然后调整为一个红黑树。而 `balanceInsertion()` 实现了调整。

```java
/**
         * Forms tree of the nodes linked from this node.
         */
final void treeify(Node<K,V>[] tab) {
    TreeNode<K,V> root = null;
    for (TreeNode<K,V> x = this, next; x != null; x = next) {
        next = (TreeNode<K,V>)x.next;
        x.left = x.right = null;
        if (root == null) { // 第一次转化过程，将链表的头节点作为根节点。
            x.parent = null;
            x.red = false;  // 红黑树的定义 根节点必须为黑色
            root = x;
        }
        else {
            K k = x.key;
            int h = x.hash;
            Class<?> kc = null;
            for (TreeNode<K,V> p = root;;) {
                int dir, ph;
                K pk = p.key;
                if ((ph = p.hash) > h)  //// 通过 Hash 的大小来确定插入顺序
                    dir = -1; // dir 大小顺序的标识
                else if (ph < h)
                    dir = 1;
                else if ((kc == null && //当 两个 Hash 的值相同，进行特殊的方法，确定大小。
                          (kc = comparableClassFor(k)) == null) || // Returns x's Class if it is of the form "class C implements Comparable ", else null. 如果 key类的 源码书写格式为 C implement Comparable<C> 那么返回该类类型 C, 如果间接实现也不行。如果是 String 类型，直接返回 String.class
                         (dir = compareComparables(kc, k, pk)) == 0)   //    ((Comparable)k).compareTo(pk)); 强制转换后进行对比，若 dir == 0,则 tieBreakOrder()，继续仲裁
                    dir = tieBreakOrder(k, pk);  // 首先通过二者的类类型进行比较，如果相等的话，使用 (System.identityHashCode(a) <= System.identityHashCode(b) 使用原始的 hashcode，不是重写的在对比。

                TreeNode<K,V> xp = p; // 遍历的，上一个节点
                if ((p = (dir <= 0) ? p.left : p.right) == null) { //通过 dir，将 p 向下查找，直到 p 为 null，找到一个插入时机
                    x.parent = xp;
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    root = balanceInsertion(root, x); //进行二叉树的调整
                    break;
                }
            }
        }
    }
    moveRootToFront(tab, root);
}
```

### 3.3 将一个二叉树转化为红黑树的操作-`balanceInsertion()`

当红黑树中新增节点的时候需要调用`balanceInsertion`方法来保证红黑树的特性。

如果想要了解红黑树的插入过程那么必须对红黑树的性质有一个较为清晰的了解。

红黑树的性质：

- 每个结点或是红色的，或是黑色的
- 根节点是黑色的
- 每个叶结点（NIL）是黑色的
- 如果一个节点是红色的，则它的两个儿子都是黑色的。
- 对于每个结点，从该结点到其叶子结点构成的所有路径上的黑结点个数相同。

```java
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                            TreeNode<K,V> x) {
    x.red = true;  // 插入的子节点必须为 red
    for (TreeNode<K,V> xp, xpp, xppl, xppr;;) { //// x 当前处理节点 xp父节点 xpp祖父节点 xppl祖父左节点 xppr 祖父右节点
        if ((xp = x.parent) == null) { // 如果 当前处理节点为根节点，满足红黑树的性质，结束循环
            x.red = false;
            return x;
        }
        else if (!xp.red || (xpp = xp.parent) == null)
            return root;
        if (xp == (xppl = xpp.left)) {
            if ((xppr = xpp.right) != null && xppr.red) {
                xppr.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                if (x == xp.right) {
                    root = rotateLeft(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateRight(root, xpp);
                    }
                }
            }
        }
        else {
            if (xppl != null && xppl.red) {
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            }
            else {
                if (x == xp.left) {
                    root = rotateRight(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
    }
}
```

TreeNode 红黑树总结

TreeNode 完整的实现了一套红黑树的增删改查的规则。实现参考了《算法导论》

```java
/* ------------------------------------------------------------ */
// Red-black tree methods, all adapted from CLR
```

这里推荐一个红黑树动画演示网站 https://rbtree.phpisfuture.com/ 红黑树是一个不严格的平衡二叉查找树，高度近似 log(N)。

## 四、HashMap 的扩展

Map中 key 有一个性质，就是 key 不能重复，而 Java Set 的含义：集合中不能有重复的元素。HashMap 的实现已经足够的优秀。那么是否可以用 key 的性质来实现 Set ？的确 JDK 中的 HashSet 就是这样做的。

```java
public class HashSet<E>
    extends AbstractSet<E>
    implements Set<E>, Cloneable, java.io.Serializable{
    private transient HashMap<E,Object> map;
      // Dummy value to associate with an Object in the backing Map
    private static final Object PRESENT = new Object();
}
```

PRESENT 就是存进 Map 中的 value，而 key 正是 Set 语义的实现。而且可以判断出 HashSet 中是允许存入 Null 值的。

# Arrays.asList() 隐藏的陷阱

在Java中，经常需要将数组转换为List来方便地进行操作。`Arrays.asList()`方法是一种常见的方式，但是它存在一个不太常见但需要注意的坑。

这里将深入探讨`Arrays.asList()`的使用，揭示其中的陷阱，并提供解决方案。

## `Arrays.asList()`方法介绍

`Arrays.asList()`方法是将数组转换为List的方法，它返回一个List对象，但这个List对象并不是`java.util.ArrayList`对象，而是Arrays内部的`ArrayList`对象。

`Arrays.ArrayList`类继承自`AbstractList`，实现了List接口。它重写了`add()`、`remove()`等修改List结构的方法，并将它们直接抛出UnsupportedOperationException异常，从而禁止了对List结构的修改。

具体来说，`Arrays.asList()`方法返回的是Arrays类中的一个私有静态内部类`ArrayList`，它继承自`AbstractList`类，实现了List接口。

`Arrays.asList()`方法的使用非常简单，只需要将一个数组作为参数传递给该方法即可。例如：

```java
String[] arr = new String[]{"a", "b", "c"};
List<String> list = Arrays.asList(arr);
```

## `Arrays.asList()`方法的坑

尽管`Arrays.asList()`方法很方便，但也存在一些坑，其中最常见的一个是：在使用`Arrays.asList()`方法时，如果对返回的List对象进行修改（例如增加、删除元素），将会抛出"UnsupportedOperationException"异常。

为什么会出现这个异常呢？这是因为`Arrays.asList()`方法返回的List对象，是一个固定大小的List，不能进行结构上的修改，否则会抛出异常。

下面的代码演示了这个问题：

```java
String[] arr = new String[]{"a", "b", "c"};
List<String> list = Arrays.asList(arr);
list.add("d"); // 抛出 UnsupportedOperationException 异常
```

上述代码中，尝试向List对象中添加一个新的元素"d"，结果会抛出"UnsupportedOperationException"异常。

## 解决`Arrays.asList()`方法的坑

要解决`Arrays.asList()`方法的坑，需要将返回的List对象转换为一个可修改的List对象。有几种方法可以实现这个目标：

### 方法一：使用`java.util.ArrayList`类

可以使用`java.util.ArrayList`类，将`Arrays.asList()`方法返回的List对象转换为一个`java.util.ArrayList`对象，示例如下：

```java
String[] arr = new String[]{"a", "b", "c"};
List<String> list = new ArrayList<>(Arrays.asList(arr));
list.add("d"); // 正常运行
```

上述代码中，首先使用`Arrays.asList()`方法将一个数组转换为一个List对象，然后使用ArrayList的构造方法，将这个List对象转换为一个`java.util.ArrayList`对象，最后可以向这个ArrayList对象中添加元素。

### 方法二：使用`Collections`类

也可以使用`Collections`类提供的静态方法，将`Arrays.asList()`方法返回的List对象转换为一个可修改的List对象，示例如下：

```java
String[] arr = new String[]{"a", "b", "c"};
List<String> list = new ArrayList<>(Arrays.asList(arr));
Collections.addAll(list, "d"); // 正常运行
```

通过`Collections.addAll()`方法，可以将数组中的元素逐个添加到一个新的ArrayList对象中，从而实现了可修改性。

## 总结

在使用`Arrays.asList()`方法时，需要注意返回的List对象是一个固定大小的List，不支持结构上的修改操作。为了避免这个陷阱，可以使用java.util.ArrayList或`Collections`类提供的方法将返回的List对象转换为可修改的List。通过了解这个陷阱并采取相应的解决方案，可以安全地将数组转换为List，并避免潜在的异常情况。

不要让`Arrays.asList()`的陷阱坑了你的代码！

在Java中，经常需要将数组转换为List来方便地进行操作。`Arrays.asList()`方法是一种常见的方式，但是它存在一个不太常见但需要注意的坑。本文将深入探讨`Arrays.asList()`的使用，揭示其中的陷阱，并提供解决方案。

# Collections工具类的用法总结

### 1、排序操作

- `reverse(List list)`：反转顺序
- `shuffle(List list)`：洗牌，将顺序打乱
- `sort(List list)`：自然升序
- `sort(List list, Comparator c)`：按照自定义的比较器排序
- `swap(List list, int i, int j)`：将 i 和 j 位置的元素交换位置

来看例子：

```java
List<String> list = new ArrayList<>();
list.add("二");
list.add("三");
list.add("四");
list.add("五");
list.add("六");

System.out.println("原始顺序：" + list);

// 反转
Collections.reverse(list);
System.out.println("反转后：" + list);

// 洗牌
Collections.shuffle(list);
System.out.println("洗牌后：" + list);

// 自然升序
Collections.sort(list);
System.out.println("自然升序后：" + list);

// 交换
Collections.swap(list, 2,4);
System.out.println("交换后：" + list);
```

输出后：

```java
原始顺序：[二, 三, 四, 五, 六]
反转后：[六, 五, 四, 三, 二]
洗牌后：[五, 二, 六, 三, 四]
自然升序后：[三, 二, 五, 六, 四]
交换后：[三, 二, 四, 六, 五]
```

### 2、查找操作

- `binarySearch(List list, Object key)`：二分查找法，前提是 List 已经排序过了
- `max(Collection coll)`：返回最大元素
- `max(Collection coll, Comparator comp)`：根据自定义比较器，返回最大元素
- `min(Collection coll)`：返回最小元素
- `min(Collection coll, Comparator comp)`：根据自定义比较器，返回最小元素
- `fill(List list, Object obj)`：使用指定对象填充
- `frequency(Collection c, Object o)`：返回指定对象出现的次数

来看例子：

```java
System.out.println("最大元素：" + Collections.max(list));
System.out.println("最小元素：" + Collections.min(list));
System.out.println("出现的次数：" + Collections.frequency(list, "二"));

// 没有排序直接调用二分查找，结果是不确定的
System.out.println("排序前的二分查找结果：" + Collections.binarySearch(list, "二"));
Collections.sort(list);
// 排序后，查找结果和预期一致
System.out.println("排序后的二分查找结果：" + Collections.binarySearch(list, "二"));

Collections.fill(list, "八");
System.out.println("填充后的结果：" + list);
```

输出后：

```java
原始顺序：[二, 三, 四, 五, 六]
最大元素：四
最小元素：三
出现的次数：1
排序前的二分查找结果：0
排序后的二分查找结果：1
填充后的结果：[八, 八, 八, 八, 八]
```

### 3、同步控制

HashMap 是线程不安全的，其实 ArrayList 也是线程不安全的，没法在多线程环境下使用，那 Collections 工具类中提供了多个 `synchronizedXxx` 方法，这些方法会返回一个同步的对象，从而解决多线程中访问集合时的安全问题。

![img](assets/1635164159714-3154b2cb-14bc-477e-80cb-d03dcc06595a-1691420544870-33.webp)

使用起来也非常的简单：

```java
SynchronizedList synchronizedList = Collections.synchronizedList(list);
```

看一眼 `SynchronizedList` 的源码就明白了，不过是在方法里面使用 `synchronized` 关键字加了一层锁而已。

```java
static class SynchronizedList<E>
    extends SynchronizedCollection<E>
    implements List<E> {
    private static final long serialVersionUID = -7754090372962971524L;

    final List<E> list;

    SynchronizedList(List<E> list) {
        super(list);
        this.list = list;
    }

    public E get(int index) {
        synchronized (mutex) {return list.get(index);}
    }
    
    public void add(int index, E element) {
        synchronized (mutex) {list.add(index, element);}
    }
    public E remove(int index) {
        synchronized (mutex) {return list.remove(index);}
    }
}
```

那这样的话，其实效率和那些直接在方法上加 `synchronized` 关键字的 `Vector`、`Hashtable` 差不多（JDK 1.0 时期就有了），而这些集合类基本上已经废弃了，几乎不怎么用。

```java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{

    public synchronized E get(int index) {
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);

        return elementData(index);
    }

    public synchronized E remove(int index) {
        modCount++;
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        E oldValue = elementData(index);

        int numMoved = elementCount - index - 1;
        if (numMoved > 0)
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        elementData[--elementCount] = null; // Let gc do its work

        return oldValue;
    }
}
```

正确的做法是使用并发包下的 `CopyOnWriteArrayList`、`ConcurrentHashMap`。这些放到并发编程时再讲。

### 4、不可变集合

- `emptyXxx()`：制造一个空的不可变集合
- `singletonXxx()`：制造一个只有一个元素的不可变集合
- `unmodifiableXxx()`：为指定集合制作一个不可变集合

举个例子：

```java
List emptyList = Collections.emptyList();
emptyList.add("非空");
System.out.println(emptyList);
```

这段代码在执行的时候就抛出错误了。

```java
Exception in thread "main" java.lang.UnsupportedOperationException
 at java.util.AbstractList.add(AbstractList.java:148)
 at java.util.AbstractList.add(AbstractList.java:108)
 at com.itwanger.s64.Demo.main(Demo.java:61)
```

这是因为 `Collections.emptyList()` 会返回一个 Collections 的内部类 `EmptyList`，而 `EmptyList` 并没有重写父类 AbstractList 的 `add(int index, E element)` 方法，所以执行的时候就抛出了不支持该操作的 UnsupportedOperationException 了。

这是从分析 add 方法源码得出的原因。除此之外，`emptyList` 方法是 `final` 的，返回的 EMPTY_LIST 也是 `final` 的，种种迹象表明 emptyList 返回的就是不可变对象，没法进行增伤改查。

```java
public static final <T> List<T> emptyList() {
    return (List<T>) EMPTY_LIST;
}

public static final List EMPTY_LIST = new EmptyList<>();
```

### 5、其他

还有两个方法比较常用：

- `addAll(Collection<? super T> c, T... elements)`，往集合中添加元素
- `disjoint(Collection<?> c1, Collection<?> c2)`，判断两个集合是否没有交集

举个例子：

```java
List<String> allList = new ArrayList<>();
Collections.addAll(allList, "九","十","二");
System.out.println("addAll 后：" + allList);

System.out.println("是否没有交集：" + (Collections.disjoint(list, allList) ? "是" : "否"));
```

输出后：

```java
原始顺序：[二, 三, 四, 五, 六]
addAll 后：[九, 十, 二]
是否没有交集：否
```

整体上，Collections 工具类作为集合框架的大管家，提供了一些非常便利的方法。

# Java 集合使用规范

根据《阿里巴巴 Java 开发手册》总结了关于集合使用常见的注意事项以及其具体原理。

## 集合判空

《阿里巴巴 Java 开发手册》的描述如下：

**判断所有集合内部的元素是否为空，使用** `**isEmpty()**` **方法，而不是** `**size()==0**` **的方式。**

这是因为 `isEmpty()` 方法的可读性更好，并且时间复杂度为 O(1)。

绝大部分使用的集合的 `size()` 方法的时间复杂度也是 O(1)，不过，也有很多复杂度不是 O(1) 的，比如 java.util.concurrent 包下的某些集合（`ConcurrentLinkedQueue` 、`ConcurrentHashMap`...）。

下面是 `ConcurrentHashMap` 的 `size()` 方法和 `isEmpty()` 方法的源码。

```java
public int size() {
    long n = sumCount();
    return ((n < 0L) ? 0 :
            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :
            (int)n);
}
final long sumCount() {
    CounterCell[] as = counterCells; CounterCell a;
    long sum = baseCount;
    if (as != null) {
        for (int i = 0; i < as.length; ++i) {
            if ((a = as[i]) != null)
                sum += a.value;
        }
    }
    return sum;
}
public boolean isEmpty() {
    return sumCount() <= 0L; // ignore transient negative values
}
```

## 集合转 Map

《阿里巴巴 Java 开发手册》的描述如下：

**在使用** `**java.util.stream.Collectors**` **类的** `**toMap()**` **方法转为** **Map** **集合时，一定要注意当 value 为 null 时会抛 NPE 异常。**

```java
class Person {
    private String name;
    private String phoneNumber;
     // getters and setters
}

List<Person> bookList = new ArrayList<>();
bookList.add(new Person("jack","18163138123"));
bookList.add(new Person("martin",null));
// 空指针异常
bookList.stream().collect(Collectors.toMap(Person::getName, Person::getPhoneNumber));
```

下面来解释一下原因。

首先，来看 `java.util.stream.Collectors` 类的 `toMap()` 方法 ，可以看到其内部调用了 `Map` 接口的 `merge()` 方法。

```java
public static <T, K, U, M extends Map<K, U>>
Collector<T, ?, M> toMap(Function<? super T, ? extends K> keyMapper,
                            Function<? super T, ? extends U> valueMapper,
                            BinaryOperator<U> mergeFunction,
                            Supplier<M> mapSupplier) {
    BiConsumer<M, T> accumulator
            = (map, element) -> map.merge(keyMapper.apply(element),
                                          valueMapper.apply(element), mergeFunction);
    return new CollectorImpl<>(mapSupplier, accumulator, mapMerger(mergeFunction), CH_ID);
}
```

`Map` 接口的 `merge()` 方法如下，这个方法是接口中的默认实现。

```java
default V merge(K key, V value,
        BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
    Objects.requireNonNull(remappingFunction);
    Objects.requireNonNull(value);
    V oldValue = get(key);
    V newValue = (oldValue == null) ? value :
               remappingFunction.apply(oldValue, value);
    if(newValue == null) {
        remove(key);
    } else {
        put(key, newValue);
    }
    return newValue;
}
```

`merge()` 方法会先调用 `Objects.requireNonNull()` 方法判断 value 是否为空。

```java
public static <T> T requireNonNull(T obj) {
    if (obj == null)
        throw new NullPointerException();
    return obj;
}
```

## 集合遍历

《阿里巴巴 Java 开发手册》的描述如下：

**不要在 foreach 循环里进行元素的** `**remove**`**/**`**add**` **操作。**`**remove**` **元素请使用** `**Iterator**` **方式，如果并发操作，需要对** `**Iterator**` **对象加锁。**

通过反编译会发现 foreach 语法糖底层其实还是依赖 `Iterator` 。不过， `remove`/`add` 操作直接调用的是集合自己的方法，而不是 `Iterator` 的 `remove`/`add`方法

这就导致 `Iterator` 莫名其妙地发现自己有元素被 `remove`/`add` ，然后，它就会抛出一个 `ConcurrentModificationException` 来提示用户发生了并发修改异常。这就是单线程状态下产生的 **fail-fast 机制**。

**fail-fast 机制** ：多个线程对 fail-fast 集合进行修改的时候，可能会抛出`ConcurrentModificationException`。即使是单线程下也有可能会出现这种情况，上面已经提到过。

Java8 开始，可以使用 `Collection#removeIf()`方法删除满足特定条件的元素,如

```java
List<Integer> list = new ArrayList<>();
for (int i = 1; i <= 10; ++i) {
    list.add(i);
}
list.removeIf(filter -> filter % 2 == 0); /* 删除list中的所有偶数 */
System.out.println(list); /* [1, 3, 5, 7, 9] */
```

除了上面介绍的直接使用 `Iterator` 进行遍历操作之外，还可以：

- 使用普通的 for 循环
- 使用 fail-safe 的集合类。java.util包下面的所有的集合类都是 fail-fast 的，而`java.util.concurrent`包下面的所有的类都是 fail-safe 的。
- ......

## 集合去重

《阿里巴巴 Java 开发手册》的描述如下：

**可以利用** **Set** **元素唯一的特性，可以快速对一个集合进行去重操作，避免使用** **List** **的** `**contains()**` **进行遍历去重或者判断包含操作。**

这里以 `HashSet` 和 `ArrayList` 为例说明。

```java
// Set 去重代码示例
public static <T> Set<T> removeDuplicateBySet(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new HashSet<>();
    }
    return new HashSet<>(data);
}

// List 去重代码示例
public static <T> List<T> removeDuplicateByList(List<T> data) {

    if (CollectionUtils.isEmpty(data)) {
        return new ArrayList<>();

    }
    List<T> result = new ArrayList<>(data.size());
    for (T current : data) {
        if (!result.contains(current)) {
            result.add(current);
        }
    }
    return result;
}
```

两者的核心差别在于 `contains()` 方法的实现。

`HashSet` 的 `contains()` 方法底部依赖的 `HashMap` 的 `containsKey()` 方法，时间复杂度接近于 O（1）（没有出现哈希冲突的时候为 O（1））。

```java
private transient HashMap<E,Object> map;
public boolean contains(Object o) {
    return map.containsKey(o);
}
```

有 N 个元素插入进 Set 中，那时间复杂度就接近是 O (n)。

`ArrayList` 的 `contains()` 方法是通过遍历所有元素的方法来做的，时间复杂度接近是 O(n)。

```java
public boolean contains(Object o) {
    return indexOf(o) >= 0;
}
public int indexOf(Object o) {
    if (o == null) {
        for (int i = 0; i < size; i++)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = 0; i < size; i++)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

List 有 N 个元素，那时间复杂度就接近是 O (n^2)。

## 集合转数组

《阿里巴巴 Java 开发手册》的描述如下：

**使用集合转数组的方法，必须使用集合的** `**toArray(T[] array)**`**，传入的是类型完全一致、长度为 0 的空数组。**

`toArray(T[] array)` 方法的参数是一个泛型数组，如果 `toArray` 方法中没有传递任何参数的话返回的是 `Object`类型数组。

```java
String [] s= new String[]{
    "dog", "lazy", "a", "over", "jumps", "fox", "brown", "quick", "A"
};
List<String> list = Arrays.asList(s);
Collections.reverse(list);
//没有指定类型的话会报错
s=list.toArray(new String[0]);
```

由于 JVM 优化，`new String[0]`作为`Collection.toArray()`方法的参数现在使用更好，`new String[0]`就是起一个模板的作用，指定了返回数组的类型，0 是为了节省空间，因为它只是为了说明返回的类型。详见：https://shipilev.net/blog/2016/arrays-wisdom-ancients/

## 数组转集合

《阿里巴巴 Java 开发手册》的描述如下：

**使用工具类** `**Arrays.asList()**` **把数组转换成集合时，不能使用其修改集合相关的方法， 它的** `**add**`**/**`**remove**`**/**`**clear**` **方法会抛出** **UnsupportedOperationException** **异常。**

在之前的一个项目中就遇到一个类似的坑。

`Arrays.asList()`在平时开发中还是比较常见的，可以使用它将一个数组转换为一个 `List` 集合。

```java
String[] myArray = {"Apple", "Banana", "Orange"};
List<String> myList = Arrays.asList(myArray);
//上面两个语句等价于下面一条语句
List<String> myList = Arrays.asList("Apple","Banana", "Orange");
```

JDK 源码对于这个方法的说明：

```java
/**
  *返回由指定数组支持的固定大小的列表。此方法作为基于数组和基于集合的API之间的桥梁，
  * 与 Collection.toArray()结合使用。返回的List是可序列化并实现RandomAccess接口。
  */
public static <T> List<T> asList(T... a) {
    return new ArrayList<>(a);
}
```

下面来总结一下使用注意事项。

### 1、`Arrays.asList()`是泛型方法，传递的数组必须是对象数组，而不是基本类型。

```java
int[] myArray = {1, 2, 3};
List myList = Arrays.asList(myArray);
System.out.println(myList.size());//1
System.out.println(myList.get(0));//数组地址值
System.out.println(myList.get(1));//报错：ArrayIndexOutOfBoundsException
int[] array = (int[]) myList.get(0);
System.out.println(array[0]);//1
```

当传入一个原生数据类型数组时，`Arrays.asList()` 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时 List 的唯一元素就是这个数组，这也就解释了上面的代码。

使用包装类型数组就可以解决这个问题。

```java
Integer[] myArray = {1, 2, 3};
```

### 2、使用集合的修改方法：`add()`、`remove()`、`clear()`会抛出异常。

```java
List myList = Arrays.asList(1, 2, 3);
myList.add(4);//运行时报错：UnsupportedOperationException
myList.remove(1);//运行时报错：UnsupportedOperationException
myList.clear();//运行时报错：UnsupportedOperationException
```

`Arrays.asList()` 方法返回的并不是 `java.util.ArrayList` ，而是 `java.util.Arrays` 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。

```java
List myList = Arrays.asList(1, 2, 3);
System.out.println(myList.getClass());//class java.util.Arrays$ArrayList
```

下图是 `java.util.Arrays$ArrayList` 的简易源码，可以看到这个类重写的方法有哪些。

```java
private static class ArrayList<E> extends AbstractList<E>
    implements RandomAccess, java.io.Serializable
{
    ...

    @Override
    public E get(int index) {
      ...
    }

    @Override
    public E set(int index, E element) {
      ...
    }

    @Override
    public int indexOf(Object o) {
      ...
    }

    @Override
    public boolean contains(Object o) {
       ...
    }

    @Override
    public void forEach(Consumer<? super E> action) {
      ...
    }

    @Override
    public void replaceAll(UnaryOperator<E> operator) {
      ...
    }

    @Override
    public void sort(Comparator<? super E> c) {
      ...
    }
}
```

再看一下`java.util.AbstractList`的 `add`/`remove`/`clear` 方法就知道为什么会抛出 `UnsupportedOperationException `了。

```java
public E remove(int index) {
    throw new UnsupportedOperationException();
}
public boolean add(E e) {
    add(size(), e);
    return true;
}
public void add(int index, E element) {
    throw new UnsupportedOperationException();
}

public void clear() {
    removeRange(0, size());
}
protected void removeRange(int fromIndex, int toIndex) {
    ListIterator<E> it = listIterator(fromIndex);
    for (int i=0, n=toIndex-fromIndex; i<n; i++) {
        it.next();
        it.remove();
    }
}
```

## 如何正确的将数组转换为 ArrayList ?

### 1、手动实现工具类

```java
//JDK1.5+
static <T> List<T> arrayToList(final T[] array) {
  final List<T> l = new ArrayList<T>(array.length);

  for (final T s : array) {
    l.add(s);
  }
  return l;
}


Integer [] myArray = { 1, 2, 3 };
System.out.println(arrayToList(myArray).getClass());//class java.util.ArrayList
```

### 2、最简便的方法

```java
List list = new ArrayList<>(Arrays.asList("a", "b", "c"));
```

### 3、使用 Java8 的 `Stream`(推荐)

```java
Integer [] myArray = { 1, 2, 3 };
List myList = Arrays.stream(myArray).collect(Collectors.toList());
//基本类型也可以实现转换（依赖boxed的装箱操作）
int [] myArray2 = { 1, 2, 3 };
List myList = Arrays.stream(myArray2).boxed().collect(Collectors.toList());
```

### 4、使用 Guava

对于不可变集合，可以使用`ImmutableList`类及其`of()`与`copyOf()`工厂方法：（参数不能为空）

```java
List<String> il = ImmutableList.of("string", "elements");  // from varargs
List<String> il = ImmutableList.copyOf(aStringArray);      // from array
```

对于可变集合，可以使用`Lists`类及其`newArrayList()`工厂方法：

```java
List<String> l1 = Lists.newArrayList(anotherListOrCollection);    // from collection
List<String> l2 = Lists.newArrayList(aStringArray);               // from array
List<String> l3 = Lists.newArrayList("or", "string", "elements"); // from varargs
```

### 5、使用 Apache Commons Collections

```java
List<String> list = new ArrayList<String>();
CollectionUtils.addAll(list, str);
```

### 6、 使用 Java9 的 `List.of()`方法

```java
Integer[] array = {1, 2, 3};
List<Integer> list = List.of(array);
```

