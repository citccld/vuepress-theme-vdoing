# 第一章：泛型的概述

## 1.1 泛型设计的背景

- 集合容器类在设计阶段/声明阶段不能确定这个容器到底存的是什么类型的对象，所以在 JDK 5 之前只能将元素类型设计为 Object ，JDK 5 之后使用泛型来解决。

- 因为这个时候除了元素的类型不确定，其他的部分是确定的，例如：关于这个元素如何保存，如何管理等是确定的，因此，此时可以将元素的类型设置成一个参数，这个类型参数叫做泛型。比如：`Collection<E>` 、`List<E>` 中的 `<E>` 就是类型参数，即泛型。

注意：自从 JDK1.5 引入泛型的概念之后，对之前核心类库中的 API 就做出了很大的修改，例如：集合框架中的相关类和接口、java.lang.Comparable 接口，java.util.Comparator 接口、Class 类等等，所以很多人误解的认为泛型就是用在集合中，这样的说法是不正确的。

## 1.2 泛型是如何设计的？

- 之前在学习方法的时候，我们知道了形参和实参的概念。那么为什么方法有形参呢？是因为方法体的功能实现中，需要外界（使用者）给它提供数据，这个数据在编写方法体的时候，数据值是不确定的（形参），需要在调用方法的时候才能确定（实参），例如：编写一个方法，可以求两个整数的和。

```java
public class Demo {

    // 求两个整数的和，其中 a 和 b 是形参
	public static void add(int a,int b){
        return a + b;
    }

    public static void main(String[] args){
        
        int result = add(1,2); // 1 和 2 是实参
        System.out.println("result = " + result);
        
    }
}
```

- 受到上面的启发，JDK 1.5 就设计了泛型的概念。当我们在设计某个类的时候，出现了某个成员的类型不确定，需要在使用这个类的时候才能确定，就可以将这个类型作为参数传递。其实可以声明在类、接口或方法中，代表未知的通用的类型（可以对比方法中的形参来理解）。

```java
package java.util;

public class ArrayList<E> extends AbstractList<E>
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable 
{ // E 就是代表未知的类型，又称为类型形参
    
    public boolean add(E e) { // 添加一个元素到集合中
        modCount++;
        add(e, elementData, size);
        return true;
    }

    // 其余略
}
package com.github.day10.generic;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-29 14:03
 */
public class TestGeneric {

    public static void main(String[] args) {
        List<String> list = new ArrayList<>(); // 此时 <E> 就是 <String>

        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");

        System.out.println("list = " + list);
    }
}
```



## 1.3 泛型的概念

- 所谓泛型，就是运行在定义类、接口或方法时通过一个标识表示类中某个属性的类型或者某个方法的返回值以及参数类型。这个参数将在使用的时候确定。

- 从 JDK 5 以后，Java 引入了参数化类型（ Parameterized type ）的概念，允许我们在创建集合的时候指定集合元素的类型，如：`List<String>` ，这表明该 List 只能保存 String 类型的元素。

- JDK 5 改写了集合框架中的全部接口和类，为这些接口和类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参。

- 语法：

```java
<类型>
```

指定一种类型的格式，尖括号里面可以任意书写，按照变量的定义规则即可，一般只写一个字母。  比如：`<E>` 、`<T>` 等。

```java
<类型1,类型2,……>
```

指定多种类型的格式，多种类型之间用逗号隔开。比如：`<K,V>` 等。

## 1.4 为什么要有泛型？

- 泛型解决了如下的问题：

- ① 解决元素存储的安全性问题。

- ② 解决获取数据元素时，需要类型强制转换的问题。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131501154.png)

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131501634.png)

- Java 泛型可以保证如果程序在编译的时候没有发出警告，运行的时候就不会产生 ClassCastException 异常。同时，代码更加简洁、健壮。
- 泛型就是传递类型（只能是引用数据类型）的一种语法。

## 1.5 泛型的相关名词

- 泛型的语法，其实非常简单，就是 `<类型>` ，其中：

- - `<T>` 是类型变量（TypeVariable），而 `<T>` 是代表未知的数据类型，我们可以指定为 `<String>`、`<Integer>` 等等，那么 `<类型>` 的形式我们就称为类型参数。
  - 对比方法中参数的概念，我们可以将 `<T>` 称为类型形参，而 `<String>` 称为类型实参。
  - 诸如 `Comparator<T>` 之类的就称为参数化类型（ParameterizedType）。

- 自从有了泛型以后，Java 的数据类型就更加丰富了。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131501417.png)

- Class ：Class 类的实例表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注解是一种接口。每个数组被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的Java数据类型（byte 、short 、int 、long 、double 、float 、char ）和关键字 void 也表示为 Class 对象。

- GenericArrayType ：泛化的数组类型，即 `T[]` 。

- ParameterizedType ：参数化类型，例如：`Comparator<String>` 。

- TypeVariable ：类型变量，例如：`Comparator<T>` 中的 T 。

- WildcardType ：通配符类型，例如：`Comparator<?>` 等。

# 第二章：自定义泛型结构

## 2.1 概述

- 泛型可以声明在类、接口后面，这样的类或接口称为泛型类或泛型方法，也可以称为参数化的类型。

```java
package java.lang;
import java.util.*;

public interface Comparable<T> {
    
    public int compareTo(T o); // 该方法不是泛型方法
}
```

- 泛型也可以声明在方法的返回值类型前面，这样的方法称为泛型方法。

```java
package java.util;

import jdk.internal.HotSpotIntrinsicCandidate;
import jdk.internal.util.ArraysSupport;

import java.lang.reflect.Array;
import java.util.concurrent.ForkJoinPool;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.DoubleBinaryOperator;
import java.util.function.IntBinaryOperator;
import java.util.function.IntFunction;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.LongBinaryOperator;
import java.util.function.UnaryOperator;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

public class Arrays {

    // 该方法是泛型方法
	public static <T> List<T> asList(T... a) {
        return new ArrayList<>(a);
    }

    // 其余略
}
```

## 2.2 泛型类和泛型接口

泛型类语法：

```java
【修饰符】 class 类名<类型变量列表> 【extends 父类】 【implements 父接口们】{
    ...
}
```

泛型接口语法：

```java
【修饰符】 interface 接口名<类型变量列表> 【implements 父接口们】{
    ...
}
```

注意：

- `<类型变量列表>` ：可以是一个或多个类型变量，一般都使用单个的大写字母表示，如：`<T>` 、`<E>` 等。

- `<类型变量列表>` 中的类型变量不能作用于静态成员上。

- 在 Java 中，`<E>` 一般用于表示集合中的元素类型，`<K,V>` 一般用于表示 Map 集合中的键和值的类型，而 `<T>` 、`<U>`、`<S>` 一般用于表示任意类型。

- 什么时候使用泛型类或泛型接口？ 

  ① 当某个类的非静态实例变量的类型不确定，需要在创建对象或子类继承的时候才能确定。 

  ② 当某个类的非静态方法的形参类型不确定，需要在创建对象或子类继承的时候才能确定。 

  示例：我们要声明一个学生类，该学生包含姓名、成绩，而此时学生的成绩类型不确定，为什么呢，因为，语文老师希望成绩是“优秀”、“良好”、“及格”、“不及格”，数学老师希望成绩是 89.5 , 65.0，英语老师希望成绩是 'A' , 'B' , 'C' , 'D' , 'E' 。那么我们在设计这个学生类时，就可以使用泛型。 

```java
package com.github.generic.demo1;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 14:25
 */
public class Student<T> {
    
    private String name;

    private T score;

    public Student() {}

    public Student(String name, T score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public T getScore() {
        return this.score;
    }

    public void setScore(T score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" + "name='" + this.name + '\'' + ", score=" + this.score + '}';
    }
}
```

## 2.3 使用泛型类和泛型接口

- 在使用泛型类和泛型接口的时候，我们需要指定泛型变量的实际类型参数： 

  ① 实际类型参数必须是引用数据类型，不能是基本数据类型。 

  ② 在创建类的对象时指定类型变量对应的实际类型参数。 

-  示例： 

```java
package com.github.generic.demo1;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 14:26
 */
public class Test {
    public static void main(String[] args) {
        // 语文老师
        Student<String> stu1 = new Student<>("张三", "良好");
        System.out.println("stu1 = " + stu1); // stu1 = Student{name='张三', score=良好}
        // 数学老师
        Student<Double> stu2 = new Student<>("李四", 80.0);
        System.out.println("stu2 = " + stu2); // stu2 = Student{name='李四', score=80.0}
        // 英语老师
        Student<Character> stu3 = new Student<>("王五", 'A');
        System.out.println("stu3 = " + stu3); // stu3 = Student{name='王五', score=A}
    }
}
```

## 2.4 类型变量的上限

- 当在声明类型变量的时候，如果不希望这个类型变量代表任意的数据类型，而是某个系列的引用数据类型，那么可以设定类型变量的上限。

- 语法：

```java
<类型变量 extends 上限>
```

```java
<类型变量 extends 上限1 & 上限2>
```

注意：

① 如果多个上限中有类和接口，那么只能有一个类，并且必须写在左边。

② 如果多个上限中都是接口，且有多个，没有顺序要求。

③ 如果在声明 `<类型变量>` 时没有指定任何上限，则默认上下是 java.lang.Object 。

示例：声明一个两个数求和的工具类，要求两个加数必须是 Number 数字类型，并且实现 Comparable 接口。

```java
package com.github.generic.demo2;

import java.math.BigDecimal;
import java.math.BigInteger;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 14:59
 */
public class SumTools<T extends Number & Comparable<T>> {
    private T t1;

    private T t2;

    public SumTools(T t1, T t2) {
        this.t1 = t1;
        this.t2 = t2;
    }

    public T getSum() {
        if (this.t1 instanceof BigInteger) {
            return (T)((BigInteger)this.t1).add((BigInteger)this.t2);
        } else if (this.t1 instanceof BigDecimal) {
            return (T)((BigDecimal)this.t1).add((BigDecimal)this.t2);
        } else if (this.t1 instanceof Integer) {
            return (T)(Integer.valueOf((Integer)this.t1 + (Integer)this.t2));
        } else if (this.t1 instanceof Long) {
            return (T)(Long.valueOf((Long)this.t1 + (Long)this.t2));
        } else if (this.t1 instanceof Float) {
            return (T)(Float.valueOf((Float)this.t1 + (Float)this.t2));
        } else if (this.t1 instanceof Double) {
            return (T)(Double.valueOf((Double)this.t1 + (Double)this.t2));
        }
        throw new UnsupportedOperationException("不支持该操作");
    }
}
```

```java
package com.github.generic.demo2;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 15:02
 */
public class Test {
    public static void main(String[] args) {
        SumTools<Integer> sumTools = new SumTools<>(1, 2);
        Integer sum = sumTools.getSum();
        System.out.println("sum = " + sum);
    }
}
```

## 2.5 泛型擦除

- 当使用参数化类型的类或接口时，如果没有指定泛型，会发生泛型擦除，自动按照最左边的第一个上限处理。如果没有指定上限，上限即为 Object 。

## 2.6 泛型方法

- 在定义类、接口时可以声明 `<类型变量>` ，在该类的方法和属性定义、接口的方法定义中，这些 `<类型变量>` 可被当成普通类型来用。但是，在另外一些情况下， 

  ① 如果我们定义类、接口时没有使用 `<类型变量>` ，但是某个方法形参类型不确定时，可以单独这个方法定义 `<类型变量>` ；

  ② 另外我们之前说类和接口上的类型形参是不能用于静态方法中，那么当某个静态方法的形参类型不确定时，可以单独定义 `<类型变量>` 。

- JDK1.5 之后，还提供了泛型方法的支持。

```java
【修饰符】 <类型变量列表> 返回值类型 方法名(【形参列表】)【throws 异常列表】{
    //...
}
```

示例：

```java
package com.github.generic.demo3;

public class MyArrays {

    /**
     * 排序
     * 
     * @param arr
     * @param <T>
     */
    public static <T extends Comparable<T>> void sort(T[] arr) {
        for (int i = 1; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - i - 1; j++) {
                if (arr[j].compareTo(arr[j + 1]) > 0) {
                    T temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
    }
}
```

# 第三章：类型通配符（了解）

## 3.1 泛型指定限制问题

【问】声明一个方法，形参是 Collection，但是元素类型不确定，怎么办？

示例：方法形参声明为 `Collection<Object>`

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-29 17:20
 */
public class TestProblem {

    /**
     * @param col Collection<Object> 无法覆盖所有场景
     */
    public static void m1(Collection<Object> col) {
        for (Object o : col) {
            System.out.println("o = " + o);
        }
    }

    @Test
    public void test01() {
        m1(new ArrayList<Object>()); // 相当于 Collection<Object> col = new ArrayList<Object>();
        m1(new ArrayList<>()); // 相当于 Collection<Object> col = new ArrayList<>();
        m1(new ArrayList());// 相当于 Collection<Object> col = new ArrayList(); 会产生警告，因为 new ArrayList() 没有使用泛型，会产生泛型擦除现象
        // m1(new ArrayList<String>()); // 错误，相当于 Collection<Object> col = new ArrayList<String>(); 语法就不对
    }

}
```

- 示例：方法形参声明为 `Collection`

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-29 21:28
 */
public class TestGeneric {

    /**
     * @param coll 无法覆盖所有场景
     */
    public static void m2(Collection coll) {
        for (Object o : coll) {
            System.out.println("o = " + o);
        }
    }

    @Test
    public void test() {
        // 编译看左边，左边泛型擦除，此时泛型按照 Object 处理，右边泛型指定也没有用
        m2(new ArrayList<Object>()); // 相当于 Collection coll = new ArrayList<Object>();
        m2(new ArrayList<>()); // 相当于 Collection coll = new ArrayList<>(); 和上面的是等价的
        m2(new ArrayList()); // 相当于 Collection coll = new ArrayList(); 泛型擦除
        m2(new ArrayList<String>()); // 相当于 Collection coll = new ArrayList<String>();
    }
}
```

- 示例：方法形参声明为 `Collection<T>`

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
* @author 许大仙
* @version 1.0
* @since 2023-01-29 21:28
*/
public class TestGeneric {

    /**
* @param coll 无法覆盖所有场景
*/
    public static <T> void m3(Collection<T> coll) {
        for (T o : coll) {
            System.out.println("o = " + o);
        }
    }

    @Test
    public void test() {
        m3(new ArrayList<Object>()); // 相当于 Collection<Object> coll = new ArrayList<Object>();
        m3(new ArrayList<>()); // 相当于 Collection<Object> coll = new ArrayList<>(); 和上面的等价
        m3(new ArrayList()); // 相当于 Collection<Object> coll = new ArrayList(); // 有警告
        m3(new ArrayList<String>()); // 相当于 Collection<String> coll = new ArrayList<String>();

    }
}
```

## 3.2 类型通配符

当我们声明一个局部变量或形参的时候，这个局部变量或形参的类型是一个泛型类或泛型接口，例如：`Comparator<T>`，但是我们依然无法确认这个泛型类或泛型接口的变量 `<T>` 的具体类型，此时我们就需要考虑使用类型通配符 `<?>`。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-29 21:28
 */
public class TestGeneric {

    public static <T> void m4(Collection<?> coll) {
        for (Object o : coll) {
            System.out.println("o = " + o);
        }
    }

    @Test
    public void test() {
        // 右边泛型指定为任意类型或不指定都可以
        m4(new ArrayList<Object>()); // 相当于 Collection<?> coll = new ArrayList<Object>();
        m4(new ArrayList<>()); // 相当于 Collection<?> coll = new ArrayList<>();
        m4(new ArrayList()); // 相当于 Collection<?> coll = new ArrayList(); 
        m4(new ArrayList<String>()); // 相当于 Collection<?> coll = new ArrayList<String>();
    }
}
```

## 3.3 类型通配符的三种使用形式

### 3.3.1 `<?>` 任意类型

-  `<?>` 表示元素类型可以是任意类型的。 

- 注意事项： 

  读取 `List<?>` 的对象 list 中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它包含的都是 Object 。

  写入 `List<?>` 中的元素时，不行。因为我们不知道 List 的元素类型，我们不能向其中添加对象。唯一的例外是 null ，它是所有类型的成员。

  `<?>` 不能用来泛型方法声明上。

```java
// 编译错误
public static <?> void test(ArrayList<?> list){
}
```

<?>` 不能用来泛型类的声明上。

```java
// 编译错误
public GenericTypeClass<?>{
}
```

`<?>` 不能用在创建对象上，右边属于创建集合对象。

```java
// 编译错误
ArrayList<?> list2 = new ArrayList<?>();
```

- 其完整形式如下：

```java
类名<?> 或 接口名<?>
```

示例： 

```java
package com.github.generic.demo4;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 16:09
 */
public class Test {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("aa");
        list.add("cc");
        list.add("bb");

        read(list);
    }

    public static void read(List<?> list) {
        for (Object o : list) {
            System.out.println(o);
        }
    }
}
```

### 3.3.2 `<? extends 类型>` 类型通配符上限

- 其完整形式如下：

```java
类名<? extends 上限类型> 或 接口名<? extends 上限类型>
```

示例：

```java
package com.github.generic.demo5;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 14:25
 */
public class Student<T> {
    private String name;

    private T score;

    public Student() {}

    public Student(String name, T score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public T getScore() {
        return this.score;
    }

    public void setScore(T score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" + "name='" + this.name + '\'' + ", score=" + this.score + '}';
    }
}
```



```java
package com.github.generic.demo5;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 16:17
 */
public class StudentService {
    public static Student<? extends Comparable> max(Student<? extends Comparable>[] arr) {
        Student<? extends Comparable> max = arr[0];
        for (int i = 0; i < arr.length; i++) {
            if (arr[i].getScore().compareTo(max.getScore()) > 0) {
                max = arr[i];
            }
        }
        return max;
    }
}
```



```java
package com.github.generic.demo5;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2021-09-30 16:17
 */
public class Test {
    public static void main(String[] args) {
        Student<? extends Double>[] arr = new Student[3];
        arr[0] = new Student<>("张三", 90.5);
        arr[1] = new Student<>("李四", 80.5);
        arr[2] = new Student<>("王五", 94.5);

        Student<? extends Comparable> max = StudentService.max(arr);
        System.out.println(max);
    }
}
```



### 3.3.3 `<? super类型>` 类型通配符下限

- 其完整形式如下：

```java
类名<? super 下限类型> 或 接口名<? super 下限类型>
```

示例：

```java
package com.github.generic.demo6;

import java.util.Comparator;

public class MyArrays{
   public static <T> void sort(T[] arr, Comparator<? super T> c){
      for (int i = 1; i < arr.length; i++) {
         for (int j = 0; j < arr.length-i; j++) {
            if(c.compare(arr[j], arr[j+1])>0){
               T temp = arr[j];
               arr[j] = arr[j+1];
               arr[j+1] = temp;
            }
         }
      }
   }
}
```

## 3.4 类型通配符的理解

Java 中的类型通配符的主要目的就是：`让一个持有特定类型（比如：A 类型）的集合能够转换为持有 A 类型的子类或父类的集合`。可能不太好理解，让我细细道来。

首先，有这么几个类：

```java
package com.github.generic;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:12
 */
public class A {

    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
package com.github.generic;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:12
 */
public class B extends A {
    
}
package com.github.generic;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:13
 */
public class C extends A {

}
```

- 从上面的代码中，我们可以知道，类的层次结构如下所示：

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503779.png)

- 如果我们有两个 List 集合的变量：

```java
List<A> listA = new ArrayList<>();
List<B> listB = new ArrayList<>();
```

- 那么，listA 能赋值给 listB 吗？或者 listB 能赋值给 listA 吗？

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        List<A> listA = new ArrayList<>();
        List<B> listB = new ArrayList<>();

        listA = listB; // 错误，不可以
    }
}
```

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503226.png)

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        List<A> listA = new ArrayList<>();
        List<B> listB = new ArrayList<>();

        listB = listA; // 错误，不可以
    }
}
```

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503822.png)

那么，为什么不可以？其实，泛型解决了 ① 解决元素存储的安全性问题 ② 解决获取数据元素时，需要类型强制转换的问题，换言之，是将运行期的行为提前到了编译期，有助于减少代码安全等问题。

换个角度讲，如果上面的代码是可以运行的，假设 `listB = listA;` 是成立的，那么会出现下面的情况：

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        List<A> listA = new ArrayList<>();
        List<B> listB = new ArrayList<>();

        // listA 添加元素，可以添加 A、B、C 类型的元素
        listA.add(new A());
        listA.add(new B());
        listA.add(new C());

        // listB 添加元素，只能添加 B 类型的元素
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        
    }
}
```

- 从上面的代码，可以看出 listA 可以添加 A、B、C 类型的元素，而 listB 只能添加 B 类型的元素，一旦 `listB = listA;` 成立，那么其内存结构图，如下所示：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503717.png" alt="img" style="zoom:80%;" />

- 会出现奇怪的现象，在编译期我们知道 listB 中的数据都是 B 类型的元素，但是取数据的时候，却可以取出 A、B、C 类型的数据，这就违背了泛型设计的初衷了吧。
- 同理，当 `listA = listB;` 成立的时候，其内存结构图，如下所示：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503329.png" alt="img" style="zoom:80%;" />

- 也会出现奇怪的现象，在编译期我们知道 listA 中可以存放 A、B、C 类型的元素，并且我们也是这么做的，但是在取数据的时候，我们却只能取出 B 类型的数据，这也违背泛型设计的初衷了吧。

此处，小结一下：在类型变量确定的情况下，是不可以互相赋值的，即使类型变量存在继承的关系下。

- 那么，类型通配符到底解决了什么痛点？

当我们声明一个变量或形参的时候，这个变量或形参的类型是一个泛型类或泛型接口，例如：`Comparator<T>`，但是我们依然无法确认这个泛型类或泛型接口的变量 `<T>` 的具体类型，此时我们就需要考虑使用类型通配符 `<?>`。

- 当我们需要写一个通用方法，它可以操作含有特定类型元素的集合，这个时候就需要类型通配符了。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    /**
     * 该方法可以操作含有特定类型元素的集合
     *
     * @param list
     */
    public static void method(List<A> list) {
        for (A a : list) {
            System.out.println("a = " + a.getValue());
        }
    }

    @Test
    public void test() {

    }
}
```

- 根据上面的结论，我们知道，我们不能将一个 `List<B> listB = new ArrayList<>();` 或 `List<C> listC = new ArrayList<>(); ` 的变量 `listB` 或 `listC` 通过参数传递给这个方法。

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131503037.png" alt="img" style="zoom:80%;" />

- 而泛型通配符就可以解决这个问题，即：

- - 从一个泛型集合中读取元素。
  - 向一个泛型集合中插入元素。

- 并且泛型通配符有三种使用方式：

- - `<?>` 任意类型
  - `<? extends 类型>` 类型通配符上限
  - `<? super类型>` 类型通配符下限

注意：泛型通配符和类型变量很大的不同在于类型变量可没有下限，并且泛型通配符不能用于泛型类或泛型接口。

- 再次强调一下，泛型是编译期行为，在编译期就确定了什么类型的元素：
- 那么，我们修改通用方法，使用类型通配符来进行处理：

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    /**
     * ? 代表任意类型，就是告诉调用者可以传递包含任意类型元素的集合。
     * 或许，你会疑惑，为什么在方法内部只能是遍历元素，而不能添加元素？
     * 需要牢记一点，泛型是编译期行为，其实就是我声明了 list 集合中的元素都是 Object 类型及其子类型。
     * 假设可以添加元素，并且我添加的是 String 类型的元素，那么当用户调用方法传递是是 List 集合，但是集合中的元素是自定义类型，岂不是冲突了~
     *
     * @param list
     */
    public static void method(List<?> list) {
        for (Object o : list) {
            System.out.println("o = " + o.getClass());
        }
    }

    @Test
    public void test() {
        List<A> list = new ArrayList<>();
        list.add(new A());
        list.add(new A());
        list.add(new A());
        list.add(new A());

        method(list);

        List<B> listB = new ArrayList<>();
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        method(listB);
    }
}
```

- 当然，也可以使用类型通配符的上限来处理：

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    /**
     * ? extends A 代表下限，就是告诉调用者可以传递包含任意 A 及其子类类型元素的集合。
     *
     * @param list
     */
    public static void method(List<? extends A> list) {
        for (A o : list) {
            System.out.println("o = " + o.getValue()); // 调用的是 A 类的方法
        }
    }

    @Test
    public void test() {
        List<A> list = new ArrayList<>();
        list.add(new A());
        list.add(new A());
        list.add(new A());
        list.add(new A());

        method(list);

        List<B> listB = new ArrayList<>();
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        method(listB);

        List<String> strList = new ArrayList<>();
        strList.add("1");
        strList.add("2");
        strList.add("3");

        // method(strList); // 错误

    }
}
```

- 那么，如果是类型通配符的下限，怎么办？这个时候是可以向集合中插入该类型及其子类型的元素。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    /**
     * ? super A 代表下限，就是告诉调用者可以传递包含任意 A 或 A 类型父类及父接口的集合。
     *
     * @param list
     */
    public static void method(List<? super A> list) {
        // 遍历，之所以按照 Object 来处理，是因为 A 类型没有显示继承某个类，默认按照 Object 来处理
        for (Object o : list) {
            System.out.println("o = " + o);
        }

        list.add(new B());
        list.add(new A());
        list.add(new C());
    }

    @Test
    public void test() {
        List<A> list = new ArrayList<>();
        list.add(new A());
        list.add(new A());
        list.add(new A());
        list.add(new A());

        method(list);

        List<B> listB = new ArrayList<>();
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        // method(listB); 错误
    }
}
```

总结：

- 如果是类型通配符的上限（假设为 A），那么就需要从集合中取出元素最安全，其实就是告诉了调用者可以传递任何包含 A 及其子类元素的集合。
- 如果是类型通配符的下限（假设为 A），那么就可以向集合中添加元素最安全，其实就是告诉了调用者可以传递任何包含 A 及其父类元素的集合。

- 我觉得你可以到这里还是不能理解，那么我再拆分来说明，就拿上限来说：

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    /**
     * ? extends A 代表下限，就是告诉调用者可以传递包含任意 A 及其子类类型元素的集合。
     *
     * @param list
     */
    public static void method(List<? extends A> list) {
        for (A o : list) {
            System.out.println("o = " + o.getValue()); // 调用的是 A 类的方法
        }
    }

    @Test
    public void test() {
        List<A> list = new ArrayList<>();
        list.add(new A());
        list.add(new A());
        list.add(new A());
        list.add(new A());

        method(list);

        List<B> listB = new ArrayList<>();
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        method(listB);

        List<String> strList = new ArrayList<>();
        strList.add("1");
        strList.add("2");
        strList.add("3");

        // method(strList); // 错误

    }
}
```

- 之所以采用遍历，而不是赋值，其实就是面向对象的特性之一：动态的理解。

```java
public static void method(List<? extends A> list) {
    for (A o : list) {
        System.out.println("o = " + o.getValue()); // 调用的是 A 类的方法
    }
}
```

- 其实，动态不就是父类型的引用指向子类型的对象吗？当采用类型通配符的上限的时候，其实就是告诉调用者你需要传递包含 A 类型（及其子类型）元素的集合，我好做遍历等操作，但是却不能在方法中添加元素，那么为什么？因为如果添加的是 A 类的子类 C 元素到 list 集合中，而调用者传递的是包含 B 元素的 list 集合，那么就很尴尬了，list 集合中的到底是 C 元素还是 B 元素呢？

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    public static void method(List<? extends A> list) {

        // list.add(new C()); // 错误

        for (A o : list) {
            System.out.println("o = " + o.getValue()); // 调用的是 A 类的方法
        }
    }

    @Test
    public void test() {


        List<B> listB = new ArrayList<>();
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());
        listB.add(new B());

        method(listB);

    }
}
```

- 同理，类型通配符下限也是可以理解的，就是告诉调用者我已经在集合中添加了元素（包含修改等操作），你只需要传递一个集合，我就可以将元素传递给你。



## 3.5 使用类型通配符指定类型参数的问题

- 前面说了，类型通配符处理用于形参（方法）之外，也可以使用在局部变量上，但是却有如下的问题。

### 3.5.1 问题一

- 如果将 `泛型类<T>` 指定为 `泛型<?>`，那么该泛型类中所有参数都是 T 类型的方法或成员将无法使用。参数类型不是 T 类型的方法照常使用。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {


    @Test
    public void test() {

        Collection<?> coll = new ArrayList<>();

        // coll.add(1); // 错误
        // coll.add("abc"); // 错误

        // 之所以错误，是因为 ? 表示任意类型，添加任何元素到集合中都是有风险的，并且 add(E t) 方法使用了泛型 E，所以错误
    }
}
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.Arrays;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        // 取出元素的时候，是可以的
        List<?> nums = Arrays.asList(1, 3, 4);

        for (Object num : nums) {
            System.out.println("num = " + num);
        }
    }
}
```

### 3.5.2 问题二

- 如果把 "`泛型类<T>` 指定为 `泛型类<? extends 上限>`：那么该泛型类中所有参数是 T 类型的方法或成员都无法正常使用。参数类型不是 T 类型的方法照常使用。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        List<? extends Number> list = new ArrayList<>();
        // list.add(1); //错误
        // list.add(1.0); //错误

        // 因为 ? 表示未知的类型，<? extends Number> 代表 Number 类型的一种，
        // 而 Number 类型有很多实现类，如：Integer、BigInteger，你如果添加成功了，那么怎么取出啊？
    }
}
```

### 3.5.3 问题三

- 如果把 `泛型类<T>`指定为 `泛型类<? super 下限>`：那么该泛型类中所有参数是 T 类型的方法或成员都可以使用，但是有要求。参数类型不是 T 类型的方法照常使用。

泛型能更早的发现错误，如类型转换错误，通常在运行期才会发现，如果使用泛型，那么在编译期将会发现，通常错误发现的越早，越容易调试，越容易减少成本。

```java
package com.github.generic;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.Collection;

/**
 * @author 许大仙
 * @version 1.0
 * @since 2023-01-30 08:11
 */
public class GenericTest {

    @Test
    public void test() {
        Collection<? super Number> coll = new ArrayList<>();
        coll.add(1);
        coll.add(1.0);
        //  coll.add("hello"); 错误
    }
}
```

## 为什么使用泛型

```java
import java.util.*;

public class GenericTest01 {
	
	public static void main(String[] args) {
		List l = new ArrayList();
		l.add(1);
		l.add(2);
		l.add(3);
		
		for (Iterator iter=l.iterator(); iter.hasNext();) {
			
			//出现了java.lang.ClassCastException异常
			//这种转型错误时运行期发现了
			//错误发现的越早越好，最好在编译器能发现类似的错误
			//如果想在编译器发现类似的错误，必须使用泛型
			String s = (String)iter.next();
			System.out.println(s);
		}
	}	
}
```

### 使用泛型解决示例一

```java
import java.util.*;

public class GenericTest02 {
	
	public static void main(String[] args) {
		List<Integer> l = new ArrayList<Integer>();
		l.add(1);
		l.add(2);
		l.add(3);
		
		//不能将abc放到集合中，因为使用泛型，在编译器就可以返现错误
		//l.add("abc");
		
		for (Iterator<Integer> iter=l.iterator(); iter.hasNext();) {
			
			//因为使用泛型，在编译器就可以发现错误
			//String s = (String)iter.next();
			
			//使用泛型可以不用进行强制转换
			//Integer s = (Integer)iter.next();
			
			//可以直接取得相应的元素，使用泛型返回的是真正的类型
			Integer s = iter.next();
			System.out.println(s);
		}
	}	
}
```

### 采用泛型来改善自定义比较器

```java
import java.util.*;

public class GenericTest03 {
	
	public static void main(String[] args) {
		Person p1 = new Person();
		p1.name = "张三";
		p1.age = 20;
		
		Person p3 = new Person();
		p3.name = "张三";
		p3.age = 40;
		
		Person p2 = new Person();
		p2.name = "李四";
		p2.age = 30;

		Set<Person> set = new TreeSet<Person>();
		set.add(p1);
		set.add(p2);
		set.add(p3);
		
		for (Iterator<Person> iter=set.iterator(); iter.hasNext();) {
			Person p = iter.next();
			System.out.println("name=" + p.name + ", age=" + p.age);
		}
	}	
}

class Person implements Comparable<Person> {
	
	String name;
	
	int age;
	
	//使用了泛型类似的instanceof就不用再写了
	public int compareTo(Person o) {
		return (this.age - o.age);
	}
}
```

### 采用泛型改造Map

````java
import java.util.*;

public class GenericTest04 {
	
	public static void main(String[] args) {
		
		IdCard idCard1 = new IdCard();
		idCard1.cardNo = 223243244243243L;
		Person person1 = new Person();
		person1.name = "张三";
		
		IdCard idCard2 = new IdCard();
		idCard2.cardNo = 223243244244343L;
		Person person2 = new Person();
		person2.name = "李四";


		IdCard idCard3 = new IdCard();
		idCard3.cardNo = 223243244243243L;
		Person person3 = new Person();
		person3.name = "张三";
		
		Map<IdCard, Person> map = new HashMap<IdCard, Person>();
		map.put(idCard1, person1);
		map.put(idCard2, person2);
		map.put(idCard3, person3);
		
		//不能编译
		//map.put("1001", "王五");
		
		for (Iterator<Map.Entry<IdCard, Person>> iter=map.entrySet().iterator(); iter.hasNext();) {
			/*
			Map.Entry entry = (Map.Entry)iter.next();	
			IdCard idCard = (IdCard)entry.getKey();
			Person person = (Person)entry.getValue();
			*/
			Map.Entry<IdCard, Person> entry = iter.next();	
			
			//不能转换
			//String s = (String)entry.getKey();
			IdCard idCard = entry.getKey();
			Person person = entry.getValue();
			
			System.out.println(idCard.cardNo + ", " + person.name);
		}
		
	}	
		
}

class IdCard {
	
	long cardNo;
	
	//.........	
	
	public boolean equals(Object obj) {
		if (obj == this) {
			return true;	
		}	
		if (obj instanceof IdCard) {
			IdCard idCard = (IdCard)obj;
			if (this.cardNo == idCard.cardNo) {
				return true;	
			} 	 
		}
		return false;
	}
	
	public int hashCode() {
		return new Long(cardNo).hashCode();
	}
} 

class Person {
	
	String name;
}
````

### 自定义泛型

```java
import java.util.*;

public class GenericTest05 {
	
	private Object obj;
	
	public void setObj(Object obj) {
		this.obj = obj;
	}
	
	public Object getObj() {
		return obj;	
	}
		
	public static void main(String[] args) {
		
		GenericTest05 g = new GenericTest05();
		
		g.setObj("abcd");
		
		//抛出java.lang.ClassCastException错误
		//因为不知道Object到底是什么类型
		Integer i = (Integer)g.getObj();
	}	
		
}
```



```java
import java.util.*;

public class GenericTest06<T> {
	
	private T obj;
	
	public void setObj(T obj) {
		this.obj = obj;
	}
	
	public T getObj() {
		return obj;	
	}
		
	public static void main(String[] args) {
		
		GenericTest06<String> g = new GenericTest06<String>();
		
		g.setObj("abcd");
		
		//不能设置int类型
		//因为使用泛型规定只能设置为String类型
		//g.setObj(123);
		
		//不能转换，因为String类型
		//Integer i = (Integer)g.getObj();
		
		//使用泛型后不用再进行强制转换了
		//它返回的就是真正的类型
		String s = g.getObj();
	}	
		
}
```



```java
import java.util.*;

//泛型的标示符没有限制，只有符合java的标示符命名规范即可
//最好和JDK的泛型标识一样
public class GenericTest07<AAA> {
	
	private AAA obj;
	
	public void setObj(AAA obj) {
		this.obj = obj;
	}
	
	public AAA getObj() {
		return obj;	
	}
		
	public static void main(String[] args) {
		
		GenericTest07<String> g = new GenericTest07<String>();
		
		g.setObj("abcd");
		
		String s = g.getObj();
	}	
		
}
```



## 泛型类

泛型类（generic class）就是具有一个或多个类型变量的类。下面给出一个简单的泛型类例子：

```java
public class Pair<T> {

    private T first;
    private T second;

    public Pair() {
        first = null;
        second = null;
    }

    public Pair(T first, T second) {
        this.first = first;
        this.second = second;
    }

    public T getFirst() {
        return first;
    }

    public void setFirst(T first) {
        this.first = first;
    }

    public T getSecond() {
        return second;
    }

    public void setSecond(T second) {
        this.second = second;
    }
}
```

Pair 类引入了一个类型变量 T，用尖括号（<>）括起来，并放在类名的后面。

泛型类可以有多个类型变量。例如，可以定义 Pair 类，其中第一个域和第二个域使用不同的类型：`public class Pair<T, U> {...}`

泛型类中定义的类型变量可以用来指定方法的返回类型以及域和局部变量的类型。

类型变量使用大写形式，且比较短。一般，使用变量 E 表示集合的元素类型，K 和 V 分别表示表的关键字与值的类型。T（需要时还可以用临近的字母 U 和 S）表示“任意类型”。

泛型类的实例化比较简单，使用具体的类型替换类型变量就可以实现。例如：`Pair<String> pair = new Pair<>();`

## 泛型方法

泛型方法就是定义一个带有类型参数的简单方法。下面给出一个简单的泛型方法例子：

```java
public class ArrayAlg {
    
    public static <T> T getMiddle(T... a) {
        return a[a.length / 2];
    }
}
```

注意：类型变量放在修饰符（这里是 public static）的后面，返回类型的前面。

泛型方法可以定义在普通类中，也可以定义在泛型类中。

当调用一个泛型方法时，在方法名前的尖括号中放入具体的类型：`String middle = ArrayAlg.<String>getMiddle("John", "Q.", "Public");`，但是，一般我们在调用泛型方法的时候不需要显示的指定类型参数，编译器可以根据上下文推断出所调用的方法使用的真实类型，比如：当我们传入 getMiddle 方法的是一批字符串数据，则编译器会使用实参的类型 String[] 与泛型类型 T[] 进行匹配并推断出 T 一定是 String。也就是说，可以这样调用：`String middle = ArrayAlg.getMiddle("John", "Q.", "Public");`

大多数情况下，编译器都能够推断出真实类型。但是，当我们传入到 getMiddle 方法中的参数存在类型不一致的情况时，编译器也会提示错误。看一看下面这个例子：

```java
double middle = ArrayAlg.getMiddle(3.14, 1729, 0);
```

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131504179.png)

编译器将会自动打包参数为 1 个 Double 和 2 个 Integer 对象，而后寻找这些类的共同超类型。事实上，找到 2 个这样的超类型：Number 和 Comparable 接口，即表示可以将结果赋给两种类型。所以，这里建议将所有的参数都写成 double 值。

## 类型变量的限定

有时，类或方法需要对类型变量加以约束。比如下面这个例子，我们要计算数组中的最小元素：

```java
public class ArrayAlg {

    public static <T extends Comparable> T min(T[] a) { // almost correct
        if (a == null || a.length == 0) return null;
        T smallest = a[0];
        for (int i = 1; i < a.length; i++)
            if (smallest.compareTo(a[i]) > 0) smallest = a[i];
        return smallest;
    }
}
```

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131504661.png)

但是，编译器提示了一个问题，变量 smallest 类型为 T，这意味着它可以是任何一个类的对象。怎么才能确信 T 所属的类有 compareTo 方法呢？

解决这个问题的方案是将 T 限制为实现了 Comparable 接口的类：`public static <T extends Comparable> T min(T[] a) ...`。在讲到通配符类型的时候会进一步扩展该方法，使其更加通用。

另外，一个类型变量可以有多个限定，例如：`T extends Comparable & Serializable, U extends Comparable`，限定类型用“&”分隔，而逗号用来分隔类型变量。

在 Java 的继承中，可以根据需要拥有多个接口超类型，但限定中至多有一个类。如果用一个类作为限定，它必须是限定列表中的第一个。

## 泛型类型的继承规则

这里只介绍部分规则，还有一部分规则在介绍通配符类型的时候说明。泛型类型的继承规则用一幅图基本就可以描述清楚：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131504180.jpeg" alt="img" style="zoom: 50%;" />

如上图所示，泛型类可以扩展或实现其他的泛型类。例如，ArrayList<T> 类实现 List<T> 接口。这意味着，一个 ArrayList<Manager> 可以被转换为一个 List<Manager>。但是，一个 ArrayList<Manager> 不是一个 ArrayList <Employee> 或 List<Employee>，虽然 Manager 类继承了 Employee。

另外，永远可以将参数化类型转换为一个原始类型。例如，可以这样写：

```java
ArrayList<Manager> managers = new ArrayList<>();
List raws = managers;
raws.add("Manager");
```

如上所示，转换成原始类型之后，会失去泛型程序设计提供的附加安全性。raws 在添加新的元素的时候不会再检查元素的类型，当 raws 添加一个 "Manager" 字符串的时候，会抛出 ClassCastException 异常。

## 通配符类型

**我们先来看泛型的一些概念：**

- ArrayList<E> 中的 E 称为类型参数变量。
- ArrayList<Integer> 中的 Integer 称为实际类型参数。
- 整个 ArrayList<E> 称为泛型类型。
- 整个 ArrayList<Integer> 称为参数化的类型（ParameterizedType）。

**通配符的作用：**

1. 通配符是用来解决泛型无法协变的问题的。

1. 1. 协变指的是如果 Child 是 Parent 的子类，那么 List<Child> 也应该是 List<Parent> 的子类。但是，根据泛型类型的继承规则，我们知道泛型是不支持协变的。

1. 泛型 T 是一个确定的类型，而通配符则更为灵活或者说是不确定。
2. 通配符不是类型参数变量，或者说通配符和类型参数变量 T 不是一类东西。

1. 你可以理解成泛型 T 就像是一个变量，等着你将来传一个具体的类型使用的，而通配符则是一种规定，规定你能传哪些参数。

**通配符的使用方式：**

1. 通配符后面只允许有一个限定，例如`Pair<? extends Employee>`or`Pair<? super Manager>`。
2. 通配符主要用于的变量声明以及形参列表，不能用来定义泛型类、泛型接口、泛型方法。
3. 在实例化泛型类的时候也不可以使用通配符，例如`new Pair<?>()`。

### **通配符的子类型限定**

通配符有两种类型的限定，一种是子类型限定：`? extends Employee`，另一种是超类型限定：`? super Manager`。接下来分别介绍这两种类型的使用场景。

指定一个子类型限定：`? extends Employee`，这个通配符限制为 Employee 的所有子类型。

假设我们要编写一个打印雇员对信息的方法：

```java
public static void printBuddies(Pair<Employee> p) {
    Employee first = p.getFirst();
    Employee second = p.getSecond();
    System.out.println(first.getName() + " and " + second.getName() + " are buddies.");
}
```

正如前面讲到的，不能将 Pair<Manager> 传递给这个方法。解决的方法很简单，使用通配符类型：`public static void printBuddies(Pair<? extends Employee> p)`。

这里补充泛型类型的继承规则，类型`Pair<Manager>`是`Pair<? extends Employee>`的子类型：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131504340.jpeg" alt="img" style="zoom:50%;" />

使用通配符的子类型限定虽然解决了泛型协变的问题，但是这样也对泛型类的写操作产生限制，即只可以取值，不可以设值。

例如，如下代码，编译器会提示错误。

```java
Pair<Manager> managerBuddies = new Pair<>(ceo, cfo);
Pair<? extends Employee> wildcardBuddies = managerBuddies; // OK
wildcardBuddies.setFirst(lowlyEmployee); // compile-time error
```

当我们使用类型`Pair<? extends Employee>`的时候，其方法似乎是这样的：

```java
? extends Employee getFirst()
void setFirst(? extends Employee e)
```

编译器只知道 setFirst 方法需要一个 Employee 的子类型，具体什么类型不知道，所以它拒绝传递任何特定的类型。而使用 getFirst 方法不存在这个问题，因为 getFirst 方法的返回值肯定可以赋给一个 Employee 的引用。

### 通配符的超类型限定

接着，我们介绍另外一种类型，指定一个超类型限定（super type bound）：`? super Managere`，这个通配符限制为 Manager 的所有超类型。

案例：有一个经理的数组，想把奖金最高和最低的经理放在一个 Pair 对象中。在这里，Pair<Employee> 是合理的， Pair<Object> 也是合理的，下面的方法将可以接受任何适当的 Pair：

```java
public static void minmaxBonus(Manager[] a, Pair<? super Manager> result) {
    if (a.length == 0) return;
    Manager min = a[0];
    Manager max = a[0];
    for (int i = 1; i < a.length; i++) {
        if (min.getBonus() > a[i].getBonus()) min = a[i];
        if (max.getBonus() < a[i].getBonus()) max = a[i];
    }
    result.setFirst(min);
    result.setSecond(max);
}
```

minmaxBonus 方法的第二个参数没有写成`Pair<Manager> result`，而是使用通配符的方式，使得传参更为灵活。

根据上面的案例，补充泛型类型的继承规则，类型`Pair<Employee>`是`Pair<? super Manager>`的子类型：

<img src="https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131504298.jpeg" alt="img" style="zoom:50%;" />

同样的，使用通配符的超类型限定也有缺陷，它对泛型类的读操作产生限制，即只可以设值，不可以取值（也可以取值，只是 getFirst 方法只能赋给一个 Object）。

例如，当我们使用类型`Pair<? super Manager>`的时候，假设其方法是这样的：

```java
void setFirst(? super Manager e)
? super Manager getFirst()
```

这不是真正的 Java 语法，但是可以看出编译器知道些什么。编译器无法知道 setFirst 方法中参数的具体类型，只知道类型限定为 Manager 的父类，所以调用这个方法的时候不能传 Manager 的父类，比如类型为 Employee 或 Object 的参数，只能传 Manager 类型的对象，或者其子类型对象。另外，如果调用 getFirst，不能保证返回对象的类型，只能把它赋给一个 Object。

下面介绍超类型限定的另一种应用，是对类型变量的限定中介绍的例子的补充。因为 Comparable 接口本身就是一个泛型类型。声明如下：

```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```

所以我们可以对 ArrayAIg 类的 min 方法做如下优化：

```java
public static <T extends Comparable<T>> T min(T[] a)......
```

这样，如果需要计算一个 String 数组的最小值时，T 就是 String 类型，而 String 是 Comparable<String> 的子类型。但是，如果处理的是一个 LocalDate 数组时，会出现一个问题。LocalDate 实现了 ChronoLocalDate, 而 ChronoLocalDate 扩展了 Comparable<ChronoLocalDate>。因此， LocalDate 实现的是 Comparable<ChronoLocalDate> 而不是 Comparable<LocalDate>。

针对这种情况，通配符的超类型限定就派上用场了：

```java
public static <T extends Comparable<? super T>> T min(T[] a)......
```

现在 compareTo 方法写成：`int compareTo(? super T) `

有可能被声明为使用类型 T 的对象，也有可能使用 T 的超类型，这样无论如何，传递一个 T 类型的对象给 compareTo 方法都是安全的。 

还有一种常见的用法，作为一个函数式接口的参数类型，例如，Collection 接口有一个方法：`default boolean removeIf(Predicate<? super E> filter)`。

这个方法会删除所有满足给定谓词条件的元素。例如，如果你不喜欢有奇怪散列码的员工，就可以如下将他们删除：

```java
ArrayList<Employee> staff = ...;
Predicate<Object> oddHashCode = obj -> obj.hashCode() % 2 != 0;
staff.removeIf(oddHashCode);
```

你希望传入一个 Predicate<Object>，而不只是 Predicate<Employee>。Super 通配符可以使这个愿望成真。

### 无限定通配符

无限定通配符的格式：`?`，不限制任何类型。例如，Pair<?>，假设类型 Pair<?> 有以下方法：

```java
? getFirst()
void setFirst(?)
```

getFirst 的返回值只能赋给一个 Object，setFirst 方法不能被调用，甚至不能用 Object 调用。

Pair<?> 和原始 Pair 类型的本质不同在于：可以用任意 Object 对象调用原始 Pair 类的 setObject 方法。

无限定通配符有什么用呢？它对于许多简单的操作非常有用。例如，下面这个方法将用来测试一个 pair 是否包含一个 null 引用，它不需要实际的类型。

```java
public static boolean hasNulls(Pair<?> p) {
    return p.getFirst() == null || p.getSecond() == null;
}
```

## 类型擦除

Java 虚拟机中没有泛型的概念，编译器在将 .java 文件编译成 .class 文件的时候，会将代码中的泛型内容擦除。即擦除类型变量，替换为限定类型（无限定的变量替换为 Object）。

例如，泛型类 Pair<T>，类型擦除后的原始类型如下所示：

```java
public class Pair {

    private Object first;
    private Object second;

    public Pair(Object first, Object second) {
        this.first = first;
        this.second = second;
    }

    public Object getFirst() {
        return first;
    }

    public Object getSecond() {
        return second;
    }

    public void setFirst(Object first) {
        first = first;
    }

    public void setSecond(Object second) {
        second = second;
    }
}
```

因为 T 是一个无限定的变量，所以直接用 Object 替换。类型擦除后，Pair 就是一个普通的类。

如果泛型类使用了类型变量的限定，则原始类型用第一个限定的类型变量来替换。例如，声明了如下泛型类：

```java
public class Interval<T extends Comparable & Serializable> implements Serializable {

    private T lower;
    private T upper;
    ......
    public Interval(T first, T second) {
        if (first.compareTo(second) <= 0) { lower = first; upper = second; }
        else { lower = second; upper = first; }
    }
}
```

Interval 类型擦除后的内容如下所示：

```java
public class Interval implements Serializable {

    private Comparable lower;
    private Comparable upper;

    public Interval(Comparable first, Comparable second) { ...... }
}
```

这里有一个思考：如果我将 Interval 类中的限定调换一下，class Interval<T extends Serializable & Comparable> 会发生什么？

如果这样做，原始类型用 Serializable 替换 T，而编译器在必要时要向 Comparable 插入强制类型转换。所以，为了提高效率，建议将标签接口（即没有方法的接口）放在限定列表的末尾。

## 类型擦除对字节码的影响

先来看第一个情况，当程序调用泛型方法时，如果擦除返回类型，编译器需要插入强制类型转换。例如，看下面的调用代码：

```java
Pair<Employee> buddies = ...;
Employee buddy = buddies.getFirst();
```

擦除 getFirst 的返回类型后将返回 Object 类型。编译器自动插人 Employee 的强制类型转换。也就是说，编译器把这个方法调用翻译为两条虚拟机指令：

- 对原始方法 Pair.getFirst 的调用。
- 将返回的 Object 类型强制转换为 Employee 类型。

第二种情况，通过在类中自动生成一个桥方法（bridge method），以保证擦除类型后的代码仍然具有泛型的“多态性”。例如，DateInterval 继承 Pair，重写 setSecond 和 getSecond 方法：

```java
public class DateInterval extends Pair<LocalDate> {

    @Override
    public void setSecond(LocalDate second) {
        if (second.compareTo(getFirst()) >= 0)
            super.setSecond(second);
    }

    @Override
    public LocalDate getSecond() {
        return super.getSecond();
    }
}
```

DateInterval 类型擦除后：

```java
public class DateInterval extends Pair {
    
    @Override
    public void setSecond(LocalDate second) {
        ......
    }
    
    public LocalDate getSecond() {
        ......
    }
}
```

Pair 类型擦除后，setSecond 方法的参数类型是 Object，getSecond 方法的返回类型是 Object，而子类 DateInterval 的参数和返回类型是 LocalDate。所以，DateInterval 类中有两个 setSecond 方法，一个是自己的，一个是从 Pair 继承的。

在某些场景中，调用 DateInterval 类中的方法的时候，有可能会调用到从父类继承的那个 setSecond 方法。

我们的本意是重写父类的方法，可是类型擦除后，变成了重载，这样类型擦除和多态就有了冲突。

为了解决这个问题，编译器在 DateInterval 类中自动生成桥方法（bridge method）。我们来看下 DateInterval.class 反编译后的内容：

```java
package test8;

import java.time.LocalDate;
import java.time.chrono.ChronoLocalDate;

// Referenced classes of package test8:
//            Pair

public class DateInterval extends Pair
{

    public DateInterval()
    {
    }

    public void setSecond(LocalDate second)
    {
        if(second.compareTo((ChronoLocalDate)getFirst()) >= 0)
            super.setSecond(second);
    }

    public LocalDate getSecond()
    {
        return (LocalDate)super.getSecond();
    }

    public volatile void setSecond(Object obj)
    {
        setSecond((LocalDate)obj);
    }

    public volatile Object getSecond()
    {
        return getSecond();
    }
}
```

编译器在 DateInterval 类中新增了两个桥方法：

- `public volatile void setSecond(Object obj)`
- `public volatile Object getSecond()`

桥方法的内部其实是调用了我们自己的 setSecond 方法，

这样在 DateInterval 类中就有两个 getSecond 方法，它们都没有参数，唯一的不同是返回类型。在 Java 中，具有相同参数类型的两个方法是不合法的，但是在虚拟机中，可以用参数类型和返回类型确定一个方法。因此，编译器可能产生两个仅返回类型不同的方法字节码，虚拟机能够正确地处理这一情况。

## 约束与局限性

### 不能用基本类型实例化类型参数

创建 Pair 对象时，不能用基本类型替换类型参数 T：

```java
Pair<int> pair = new Pair<>(6, 8);
```

只能用非基本类型替换类型参数 T：

```java
Pair<Integer> pair = new Pair<>(6, 8);
```

Java 编译器会对 6 和 8 自动装箱：

```java
Pair pair = new Pair(Integer.valueOf(6), Integer.valueOf(8));
```

该限制的原因是，类型擦除之后，Pair 类中的 first，second 字段是 Object 类型，而 Object 不能存储 int 值。

### 泛型类型不能使用 instanceof 关键字和强制类型转换

因为编译器会擦除代码中的所有类型变量，所以运行时无法验证泛型类型。例如：

```java
if (a instanceof Pair<String>) // Error

if (a instanceof Pair<T>) // Error

Pair<String> p = (Pair<String>) a; // Warning--can only test that a is a Pair
```

试图查询一个对象是否属于某个泛型类型时，倘若使用 instanceof 会得到一个编译器错误，如果使用强制类型转换会得到一个警告。

同样的道理，getClass 方法总是返回原始类型。例如：

```java
Pair<String> stringPair = new Pair<>();
Pair<Employee> employeePair = new Pair<>();
System.out.println(stringPair.getClass() == employeePair.getClass());
```

打印 true，这是因为两次调用 getClass 都将返回 Pair.class。

### 不能创建参数化类型的数组

例如，以下代码编译错误：

```java
Pair<String>[] table = new Pair<String>[10]; // Error
```

数组有一个特性，即使把数组转换为 Object[]，它仍然会记住元素的类型，如果试图存储其他类型的元素，就会抛出一个 ArrayStoreException 异常：

```java
Object[] strings = new String[2];
strings[0] = "hi"; // OK
strings[1] = 100;  // An ArrayStoreException is thrown.
```

不过对于泛型类型，擦除会使这种机制无效。我们假设可以创建参数化类型的数组：

```java
Object[] stringLists = new List<String>[]; // compiler error, but pretend it's allowed
stringLists[0] = new ArrayList<String>();  // OK
stringLists[1] = new ArrayList<Integer>(); // An ArrayStoreException should be thrown,
                                           // but the runtime can't detect it.
```

如果允许参数化列表数组，则上面的代码将无法抛出所需的 ArrayStoreException。

需要说明的是，只是不允许创建这些数组，而声明类型为 Pair<String>[] 的变量仍是合法的，不过不能用 new Pair<String>[10] 初始化这个变量。

### Varargs 警告

上面我们已经了解到，Java 不支持泛型类型的数组。这一节中我们再来讨论一个相关的问题：向参数个数可变的方法传递一个泛型类型的实例。

例如，下面方法的参数个数是可变的：

```java
public static <T> void addAll(Collection<T> coll, T... ts) {
    for (T t : ts) coll.add(t);
}
```

实际上参数 ts 是一个数组，包含提供的所有实参。

执行如下代码，调用该方法：

```java
Collection<Pair<String>> table = new ArrayList<>();
Pair<String> pair1 = new Pair<>();
Pair<String> pair2 = new Pair<>();
addAll(table, pair1, pair2);
```

为了调用这个方法，Java 虚拟机必须建立一个 Pair<String> 数组，这就违反了前面的规则。不过，对于这种情况，规则有所放松，你只会得到一个警告，而不是错误。

![img](https://imge-store.oss-cn-beijing.aliyuncs.com/blog/202308131505812.png)

可以采用两种方法来抑制这个警告。一种方法是为包含 addAll 调用的方法增加注解 @SuppressWarnings("unchecked")。或者在 Java SE 7 中，还可以用 @SafeVarargs 直接标注 addAll 方法：

```java
@SafeVarargs
public static <T> void addAll(Collection<T> coll, T... ts)
```

### 不能实例化类型变量

不能使用像 new T(...)，new T[...] 或 T.class 这样的表达式中的类型变量。

例如，下面的 Pair<T> 构造器就是非法的：

```java
public Pair() { first = new T(); second = new T(); } // Error
```

类型擦除将 T 改变成 Object，我们的本意肯定不希望调用 new Object()。 在 Java SE 8 之后，最好的解决办法是让调用者提供一个构造器表达式。

```java
Pair<String> p = Pair.makePair(String::new);

public static <T> Pair<T> makePair(Supplier<T> constr) {
    return new Pair<>(constr.get(), constr.get());
}
```

makePair 方法接收一个 Supplier<T>，这是一个函数式接口，表示一个无参数而且返回类型为 T 的函数。

比较传统的解决方法是通过反射调用 Class.newInstance 方法来构造泛型对象。另外，表达式 T.class 是不合法的，因为它会擦除为 Object.class，所以需要将 Class 对象作为实参传给 makePair 方法：

```java
Pair<String> p = Pair.makePair(String.class);

public static <T> Pair<T> makePair(Class<T> cl) {
    try {
        return new Pair<>(cl.newInstance(), cl.newInstance());
    } catch (Exception ex) {
        return null;
    }
}
```

### 不能构造泛型数组

就像不能实例化一个泛型实例一样，也不能实例化数组。比如下面的例子：

```java
public static <T extends Comparable> T[] minmax(T[] a) {
    T[] mm = new T[2]; // Error
    ......
}
```

我们本意是根据传入的不同类型创建不同的数组，但是类型擦除会让这个方法永远只能构造 Comparable[2] 数组。

和上面的处理方法类似，提供一个数组构造器表达式：

```java
String[] ss = ArrayAlg.minmax(String[]::new, "Tom", "Dick", "Harry");
```

构造器表达式 String[]::new 指示一个函数，给定所需的长度，会构造一个指定长度的 String 数组。

```java
public static <T extends Comparable> T[] minmax(IntFunction<T[]> constr, T... a) {
    T[] mm = constr.apply(2);
    ......
}
```

比较老式的方法是利用反射，调用 Array.newInstance：

```java
public static <T extends Comparable> T[] minmax(T... a) {
    T[] mm = (T[]) Array.newInstance(a.getClass().getComponentType(), 2);
    ......
}
```

### 泛型类的静态上下文中类型变量无效

不能在静态域或方法中引用类型变量。例如，无法实现如下功能：

```java
public class Singleton<T> {

    private static T singleInstance; // Error

    public static T getSingleInstance() { // Error
        if (singleInstance == null) construct new instance of T
        return singleInstance;
    }
}
```

这个限制只存在于泛型类中，假设允许在静态域或方法中引用类型变量，那么就需要考虑一个问题，我们如何为该类型变量指定一个真实类型？

泛型类是在实例化的时候指定真实类型的（Pair<String> pair = new Pair<>();），而静态成员显然不能在实例化的时候才指定真实类型。

### 不能抛出或捕获泛型类的实例

既不能抛出也不能捕获泛型类对象。甚至泛型类扩展 Throwable 都是不合法的。例如，以下定义就不能正常编译：

```java
public class Problem<T> extends Exception { /* ... */ } // Error can't extend Throwable
```

catch 子句中不能使用类型变量。例如，以下方法将不能编译：

```java
public static <T extends Throwable> void doWork(Class<T> t) {
    try {
        // do work
    } catch (T e) { // Error -- can't catch type variable
        Logger.global.info(...)
    }
}
```

不过，在异常规范中使用类型变量是允许的。以下方法是合法的：

```java
public static <T extends Throwable> void doWork(T t) throws T { // OK
    try {
        // do work
    } catch (Throwable realCause) {
        t.initCause(realCause);
        throw t;
    }
}
```

### 注意擦除后的冲突

当泛型类型被擦除时，无法创建引发冲突的条件。例如，像下面这样将 equals 方法添加到 Pair 类中：

```java
public class Pair<T> {
    public boolean equals(T value) {
        return first.equals(value) && second.equals(value);
    }
}
```

当定义成 Pair<String> 的时候，理论上，它存在两个 equals 方法：

- boolean equals(String) // defined in Pair<T>
- boolean equals(Object) // inherited from Object

其实，类型擦除后，boolean equals(T) 就是 boolean equals(Object)，这时就与 Object.equals 方法发生冲突。补救的方法是重新命名引发错误的方法。

另外一个原则是：要想支持擦除的转换，就需要强行限制一个类或类型变量不能同时成为两个接口类型的子类，且这两个接口是同一接口的不同参数化。

例如，以下代码是错误的：

```java
class Employee implements Comparab1e<Employee> { ... }

class Manager extends Employee implements Comparable<Manager> { ... } // Error
```

Manager 会实现 Comparable<Employee> 和 Comparable<Manager>，这是同一接口的不同参数化。

这一限制与类型擦除的关系并不十分明确。毕竟，Employee 和 Manager 类型擦除后是正确的：

```java
class Employee implements Comparab1e { ... }

class Manager extends Employee implements Comparable { ... } 
```

根据类型擦除对字节码的影响中的描述，猜测有可能与合成的桥方法（bridge method）产生冲突。如果按照上面的实现方式，类型擦除后 Manager 类会出现如下两种桥方法：

```java
public int compareTo(Object other) { return compareTo((Employee) other); }

public int compareTo(Object other) { return compareTo((Manager) other); }
```

显然是不允许出现这种情况的，所以会有上面的限制。



## 枚举类

Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。

Java 枚举类使用 enum 关键字来定义，各个常量使用逗号分割。比如，定义个星期的枚举类：

```java
public enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```

枚举类通常用来定义常量，可以将有关联关系的常量组织起来，使代码更加易读、安全，并且还可以使用枚举提供的方法。

### 枚举的比较

使用 enum 定义的枚举类是一种引用类型。前面我们讲过，引用类型比较，要使用 equals() 方法，如果使用 == 比较，它比较的是两个引用类型的变量是否指向同一个对象。因此，引用类型比较，要使用 equals() 方法，但 enum 类型可以例外。

这是因为 enum 类型的每个常量在 JVM 中只有一个唯一实例，所以可以直接用 == 比较：

```java
if (day == Weekday.FRI) { // ok!
}
```

### 枚举的本质

通过 enum 定义的枚举类，和其他的 class 有什么区别？

答案是没有任何区别。enum 定义的类型就是 class，只不过它有以下几个特点：

- 定义的 enum 类型总是继承自 java.lang.Enum，且无法被继承；
- 只能定义出 enum 的实例，而无法通过 new 操作符创建 enum 的实例；
- 定义的每个实例都是引用类型的唯一实例；
- 可以将 enum 类型用于 switch 语句。

例如，我们定义的 Weekday 枚举类：

```java
public enum Weekday {
    SUN, MON, TUE, WED, THU, FRI, SAT;
}
```

编译器编译出的 class 大概就像这样：

```java
// 继承自 Enum，标记为 final class
public final class Weekday extends Enum
{

    public static Weekday[] values()
    {
        return (Weekday[])$VALUES.clone();
    }

    public static Weekday valueOf(String name)
    {
        return (Weekday)Enum.valueOf(test12/Weekday, name);
    }

    // private 构造方法，确保外部无法调用 new 操作符:
    private Weekday(String s, int i)
    {
        super(s, i);
    }

    // 每个实例均为全局唯一:
    public static final Weekday SUN;
    public static final Weekday MON;
    public static final Weekday TUE;
    public static final Weekday WED;
    public static final Weekday THU;
    public static final Weekday FRI;
    public static final Weekday SAT;
    private static final Weekday $VALUES[];

    static 
    {
        SUN = new Weekday("SUN", 0);
        MON = new Weekday("MON", 1);
        TUE = new Weekday("TUE", 2);
        WED = new Weekday("WED", 3);
        THU = new Weekday("THU", 4);
        FRI = new Weekday("FRI", 5);
        SAT = new Weekday("SAT", 6);
        $VALUES = (new Weekday[] {
            SUN, MON, TUE, WED, THU, FRI, SAT
        });
    }
}
```

所以，编译后的 enum 类和普通 class 并没有任何区别。但是我们自己无法按定义普通 class 那样来定义 enum，必须使用 enum 关键字，这是 Java 语法规定的。

### 枚举的方法

根据编译后的源码，我们知道 enum 类型总是继承自 java.lang.Enum，它提供了一些基本方法：

- `values()`：返回 enum 实例的数组，而且该数组中的元素严格保持在 enum 中声明时的顺序；
- `valueOf()`：返回带指定名称的指定枚举类型的枚举常量；
- `name()`：返回实例名；
- `ordinal()`：返回实例声明时的次序，从 0 开始；
- `getDeclaringClass()`：返回实例所属的 enum 类型；
- `equals() `：判断是否为同一个对象。

此外，java.lang.Enum 实现了 Comparable 和 Serializable 接口，所以也提供 `compareTo()` 方法。

### 自定义属性和方法

我们在使用枚举的时候不会只定义枚举实例名，还会定义一些属性和方法，方便我们使用。

枚举可以添加普通方法、静态方法、抽象方法、构造方法，枚举也可以实现接口，但是，枚举不能继承。

比如上面的 Weekday 枚举，我们可以添加如下属性和方法：

```java
public enum Weekday {

    SUN(0, "Sunday"),
    MON(1, "Monday"),
    TUE(2, "Tuesday"),
    WED(3, "Wednesday"),
    THU(4, "Thursday"),
    FRI(5, "Friday"),
    SAT(6, "Saturday");

    private final int index;

    private final String name;

    private Weekday(int index, String name) {
        this.index = index;
        this.name = name;
    }

    public static String getNameByIndex(int index) {

        for (Weekday weekday : values()) {
            if (weekday.getIndex() == index) {
                return weekday.getName();
            }
        }
        return null;
    }

    public int getIndex() {
        return index;
    }

    public String getName() {
        return name;
    }
}
```

### 总结

- Java 使用 enum 定义枚举类型，它被编译器编译为 final class Xxx extends Enum { … }；
- 可以为 enum 编写构造方法、字段和方法；
- enum 的构造方法要声明为 private，字段建议声明为 private final。



Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。

Java 枚举类使用 enum 关键字来定义，各个常量使用逗号 , 来分割。

例如定义一个颜色的枚举类。

```java
enum Color 
{ 
    RED, GREEN, BLUE; 
} 
```

以上枚举类 Color 颜色常量有 RED, GREEN, BLUE，分别表示红色，绿色，蓝色。

使用实例：

```java
enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}
```

执行以上代码输出结果为：

```java
RED
```

### 内部类中使用枚举

枚举类也可以声明在内部类中：

```java
public class Test
{
    enum Color
    {
        RED, GREEN, BLUE;
    }
 
    // 执行输出结果
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
    }
}
```

执行以上代码输出结果为：

```java
RED
```

每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。

以上的枚举类 Color 转化在内部类实现：

```java
class Color
{
     public static final Color RED = new Color();
     public static final Color BLUE = new Color();
     public static final Color GREEN = new Color();
}
```

### 迭代枚举元素

可以使用 for 语句来迭代枚举元素：

```java
enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
  public static void main(String[] args) {
    for (Color myVar : Color.values()) {
      System.out.println(myVar);
    }
  }
}
```

执行以上代码输出结果为：

```java
RED
GREEN
BLUE
```

### 在 switch 中使用枚举类

枚举类常应用于 switch 语句中：

```java
enum Color
{
    RED, GREEN, BLUE;
}
public class MyClass {
  public static void main(String[] args) {
    Color myVar = Color.BLUE;

    switch(myVar) {
      case RED:
        System.out.println("红色");
        break;
      case GREEN:
         System.out.println("绿色");
        break;
      case BLUE:
        System.out.println("蓝色");
        break;
    }
  }
}
```

执行以上代码输出结果为：

```java
蓝色
```

### values(), ordinal() 和 valueOf() 方法

enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Serializable 和 java.lang.Comparable 两个接口。

values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：

- values() 返回枚举类中所有的值。
- ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。
- valueOf()方法返回指定字符串值的枚举常量。

```java
enum Color
{
    RED, GREEN, BLUE;
}
 
public class Test
{
    public static void main(String[] args)
    {
        // 调用 values()
        Color[] arr = Color.values();
 
        // 迭代枚举
        for (Color col : arr)
        {
            // 查看索引
            System.out.println(col + " at index " + col.ordinal());
        }
 
        // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException
        System.out.println(Color.valueOf("RED"));
        // System.out.println(Color.valueOf("WHITE"));
    }
}
```

执行以上代码输出结果为：

```java
RED at index 0
GREEN at index 1
BLUE at index 2
RED
```

### 枚举类成员

枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用。

枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。

```java
enum Color
{
    RED, GREEN, BLUE;
 
    // 构造函数
    private Color()
    {
        System.out.println("Constructor called for : " + this.toString());
    }
 
    public void colorInfo()
    {
        System.out.println("Universal Color");
    }
}
 
public class Test
{    
    // 输出
    public static void main(String[] args)
    {
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    }
}
```

执行以上代码输出结果为：

```java
Constructor called for : RED
Constructor called for : GREEN
Constructor called for : BLUE
RED
Universal Color
```

### 响应工具

```java

public enum ResultCode {

    SUCCESS(1000,"成功"),
    ERROR(1001,"失败"),
    USERNAME_NOT_FOUND(1002,"用户名未找到");

    private Integer code;
    private String msg;

    private ResultCode(){}

    private ResultCode(Integer code,String msg){
        this.code = code;
        this.msg = msg;
    }

    public Integer getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }
}

```

